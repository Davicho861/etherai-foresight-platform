94650127705af3cc71a181e423083f6b
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _express = _interopRequireDefault(require("express"));
var _path = _interopRequireDefault(require("path"));
var foodSecurityService = _interopRequireWildcard(require("../services/worldBankService.js"));
var _cryptoService = _interopRequireDefault(require("../services/cryptoService.js"));
var climateServiceModule = _interopRequireWildcard(require("../services/climateService.js"));
var communityResilienceServiceModule = _interopRequireWildcard(require("../services/communityResilienceService.js"));
var predictionEngineModule = _interopRequireWildcard(require("../services/predictionEngine.js"));
var generativeAIServiceModule = _interopRequireWildcard(require("../services/generativeAIService.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); } // Static imports so Jest can mock these modules reliably in tests
// Resolve a stable __dirname for this module in both ESM and CommonJS
// test environments. Some test runners (Jest + babel-jest) may not
// support `import.meta.url` during transformation, which causes
// "Cannot use 'import.meta' outside a module" errors. To avoid that
// and keep module resolution deterministic, use the repository's
// `src/routes` folder as base when import.meta is unavailable.
const _dirname = _path.default.resolve(process.cwd(), 'src', 'routes');
const router = _express.default.Router();

// Helper to dynamically load a module.
// Prefer CommonJS `require` when available so Jest's module mocks (which
// commonly patch `require`) are applied. Fallback to dynamic import for
// true ESM modules or when require isn't available.
async function safeLoad(modulePath) {
  const fullPath = _path.default.resolve(_dirname, modulePath);
  // Try require first for better compatibility with Jest mocks
  try {
    // eslint-disable-next-line global-require, import/no-dynamic-require
    if (typeof require === 'function') {
      // Try requiring by the original module path first so Jest's module
      // mocking (which uses the module id as declared in tests) is applied.
      try {
        const modById = require(modulePath);
        return modById && modById.__esModule ? modById.default || modById : modById;
      } catch (e) {
        // If that fails, fall back to absolute resolution
      }
      const resolved = require.resolve(fullPath);
      const mod = require(resolved);
      return mod && mod.__esModule ? mod.default || mod : mod;
    }
  } catch (reqErr) {
    // Not fatal: fall through to dynamic import
    // console.debug(`safeLoad require failed for ${modulePath}:`, reqErr.message);
  }

  // Dynamic import fallback (for ESM-only modules)
  try {
    const mod = await (specifier => new Promise(r => r(`${specifier}`)).then(s => _interopRequireWildcard(require(s))))(fullPath);
    return mod && mod.default ? mod.default : mod;
  } catch (importErr) {
    console.error(`Error loading module ${modulePath} via import():`, importErr);
    throw new Error(`Failed to load module: ${modulePath}`);
  }
}

// Helper: given a loaded module, return a usable service object.
function getServiceInstance(mod) {
  if (!mod) return null;
  // If module is a constructor (class or function), instantiate it.
  if (typeof mod === 'function') {
    try {
      return new mod();
    } catch (e) {
      // If it's a factory function that returns an object when called
      try {
        return mod();
      } catch (err) {
        return mod;
      }
    }
  }
  // If module is an object with a default class, instantiate default
  if (mod && typeof mod === 'object' && mod.default && typeof mod.default === 'function') {
    try {
      return new mod.default();
    } catch (e) {
      try {
        return mod.default();
      } catch (err) {
        return mod.default || mod;
      }
    }
  }
  // Otherwise return the module as-is (it may be an object of functions)
  return mod;
}

// GET /api/global-risk/food-security 
router.get('/food-security', async (req, res) => {
  try {
    // Use the statically imported module (tests mock this module)
    const foodService = getServiceInstance(foodSecurityService) || foodSecurityService;
    const data = typeof foodService.getFoodSecurityIndex === 'function' ? await foodService.getFoodSecurityIndex() : await (foodService.getFoodSecurityIndex || foodService);
    res.status(200).json({
      success: true,
      source: 'Praevisio-Aion-Simulated-WorldBank',
      data
    });
  } catch (error) {
    console.error('Error retrieving food security data:', error);
    res.status(500).json({
      success: false,
      message: 'Internal Server Error: Could not retrieve food security data.'
    });
  }
});

// GET /api/global-risk/crypto-volatility
router.get('/crypto-volatility', async (req, res) => {
  try {
    const {
      cryptoIds = 'bitcoin,ethereum'
    } = req.query;
    const cryptoList = cryptoIds.split(',').map(id => id.trim());
    // Use statically imported crypto module so Jest's mockImplementation is used
    const cryptoService = getServiceInstance(_cryptoService.default) || _cryptoService.default;
    const serviceData = typeof cryptoService.getCryptoMarketAnalysis === 'function' ? await cryptoService.getCryptoMarketAnalysis(cryptoList) : await (cryptoService.getCryptoMarketAnalysis || cryptoService)(cryptoList);

    // Normalize/augment returned service data for backward compatibility
    if (serviceData && typeof serviceData === 'object') {
      // If the service provides a volatilityIndex, expose it as `value` to match tests
      if (serviceData.volatilityIndex !== undefined) {
        serviceData.value = serviceData.volatilityIndex;
      }
      // Add unit and topic defaults if not present
      serviceData.unit = serviceData.unit || '%';
      serviceData.topic = serviceData.topic || 'crypto-volatility';
      // Ensure timestamp exists
      serviceData.timestamp = serviceData.timestamp || new Date().toISOString();
    }
    res.status(200).json({
      success: true,
      status: 'OK',
      source: 'Praevisio-Aion-CryptoService',
      timestamp: new Date().toISOString(),
      data: serviceData
    });
  } catch (error) {
    console.error('Error retrieving crypto volatility data:', error);
    res.status(500).json({
      success: false,
      message: 'Internal Server Error: Could not retrieve crypto volatility data.'
    });
  }
});

// GET /api/global-risk/climate-extremes
router.get('/climate-extremes', async (req, res) => {
  try {
    const climateService = getServiceInstance(climateServiceModule) || climateServiceModule;
    const serviceData = typeof climateService.getClimateExtremesIndex === 'function' ? await climateService.getClimateExtremesIndex() : await (climateService.getClimateExtremesIndex || climateService);
    res.status(200).json({
      success: true,
      source: 'Praevisio-Aion-NASA-POWER-Integration',
      timestamp: new Date().toISOString(),
      data: serviceData
    });
  } catch (error) {
    console.error('Error retrieving climate extremes data:', error);
    res.status(500).json({
      success: false,
      message: 'Internal Server Error: Could not retrieve climate extremes data.'
    });
  }
});

// GET /api/global-risk/community-resilience
router.get('/community-resilience', async (req, res) => {
  try {
    const {
      countries = 'COL,PER,ARG',
      days = 30
    } = req.query;
    const countryList = Array.isArray(countries) ? countries : countries.split(',').map(c => c.trim()).filter(Boolean);
    const communityService = getServiceInstance(communityResilienceServiceModule) || communityResilienceServiceModule;
    const serviceData = typeof communityService.getCommunityResilienceIndex === 'function' ? await communityService.getCommunityResilienceIndex(countryList, Number(days)) : await (communityService.getCommunityResilienceIndex || communityService)(countryList, Number(days));

    // Build a normalized metric value: 100 - averageResilience
    const avg = serviceData?.globalResilienceAssessment?.averageResilience;
    const value = typeof avg === 'number' ? Math.round(100 - avg) : undefined;
    const data = {
      timestamp: serviceData?.timestamp || new Date().toISOString(),
      topic: 'community-resilience',
      unit: '%',
      value,
      resilienceAnalysis: serviceData?.resilienceAnalysis || {},
      globalResilienceAssessment: serviceData?.globalResilienceAssessment || {}
    };
    res.status(200).json({
      success: true,
      status: 'OK',
      source: 'Praevisio-Aion-CommunityResilienceAgent',
      timestamp: new Date().toISOString(),
      data
    });
  } catch (error) {
    console.error('Error retrieving community resilience data:', error);
    res.status(500).json({
      success: false,
      message: 'Internal Server Error: Could not retrieve community resilience data.'
    });
  }
});

/**
 * @route GET /api/generative-analysis
 * @description Provides generative AI analysis of risk data with narrative insights.
 * @access Public
 */
router.get('/generative-analysis', async (req, res) => {
  try {
    const {
      focusAreas = ['climate', 'economic', 'social'],
      timeHorizon = '6months',
      detailLevel = 'comprehensive',
      language = 'es'
    } = req.query;
    const predictionService = getServiceInstance(predictionEngineModule) || predictionEngineModule;
    const riskData = typeof predictionService.getRiskIndices === 'function' ? await predictionService.getRiskIndices() : await (predictionService.getRiskIndices || predictionService);
    const genService = getServiceInstance(generativeAIServiceModule) || generativeAIServiceModule;
    const options = {
      focusAreas: Array.isArray(focusAreas) ? focusAreas : focusAreas.split(',').map(a => a.trim()),
      timeHorizon,
      detailLevel,
      language
    };
    const narrative = typeof genService.generatePredictiveNarrative === 'function' ? await genService.generatePredictiveNarrative(riskData, options) : await (genService.generatePredictiveNarrative || genService)(riskData, options);
    res.status(200).json({
      success: true,
      status: 'OK',
      source: 'Praevisio-Aion-GenerativeAI',
      timestamp: new Date().toISOString(),
      data: narrative
    });
  } catch (error) {
    console.error('Error generating AI analysis:', error);
    res.status(500).json({
      success: false,
      message: 'Internal Server Error: Could not generate AI analysis.'
    });
  }
});
var _default = exports.default = router;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfZXhwcmVzcyIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJyZXF1aXJlIiwiX3BhdGgiLCJmb29kU2VjdXJpdHlTZXJ2aWNlIiwiX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQiLCJfY3J5cHRvU2VydmljZSIsImNsaW1hdGVTZXJ2aWNlTW9kdWxlIiwiY29tbXVuaXR5UmVzaWxpZW5jZVNlcnZpY2VNb2R1bGUiLCJwcmVkaWN0aW9uRW5naW5lTW9kdWxlIiwiZ2VuZXJhdGl2ZUFJU2VydmljZU1vZHVsZSIsImUiLCJfX2VzTW9kdWxlIiwiZGVmYXVsdCIsInQiLCJXZWFrTWFwIiwiciIsIm4iLCJvIiwiaSIsImYiLCJfX3Byb3RvX18iLCJoYXMiLCJnZXQiLCJzZXQiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIl9fZGlybmFtZSIsInBhdGgiLCJyZXNvbHZlIiwicHJvY2VzcyIsImN3ZCIsInJvdXRlciIsImV4cHJlc3MiLCJSb3V0ZXIiLCJzYWZlTG9hZCIsIm1vZHVsZVBhdGgiLCJmdWxsUGF0aCIsIm1vZEJ5SWQiLCJyZXNvbHZlZCIsIm1vZCIsInJlcUVyciIsInNwZWNpZmllciIsIlByb21pc2UiLCJ0aGVuIiwicyIsImltcG9ydEVyciIsImNvbnNvbGUiLCJlcnJvciIsIkVycm9yIiwiZ2V0U2VydmljZUluc3RhbmNlIiwiZXJyIiwicmVxIiwicmVzIiwiZm9vZFNlcnZpY2UiLCJkYXRhIiwiZ2V0Rm9vZFNlY3VyaXR5SW5kZXgiLCJzdGF0dXMiLCJqc29uIiwic3VjY2VzcyIsInNvdXJjZSIsIm1lc3NhZ2UiLCJjcnlwdG9JZHMiLCJxdWVyeSIsImNyeXB0b0xpc3QiLCJzcGxpdCIsIm1hcCIsImlkIiwidHJpbSIsImNyeXB0b1NlcnZpY2UiLCJDcnlwdG9TZXJ2aWNlTW9kdWxlIiwic2VydmljZURhdGEiLCJnZXRDcnlwdG9NYXJrZXRBbmFseXNpcyIsInZvbGF0aWxpdHlJbmRleCIsInVuZGVmaW5lZCIsInZhbHVlIiwidW5pdCIsInRvcGljIiwidGltZXN0YW1wIiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwiY2xpbWF0ZVNlcnZpY2UiLCJnZXRDbGltYXRlRXh0cmVtZXNJbmRleCIsImNvdW50cmllcyIsImRheXMiLCJjb3VudHJ5TGlzdCIsIkFycmF5IiwiaXNBcnJheSIsImMiLCJmaWx0ZXIiLCJCb29sZWFuIiwiY29tbXVuaXR5U2VydmljZSIsImdldENvbW11bml0eVJlc2lsaWVuY2VJbmRleCIsIk51bWJlciIsImF2ZyIsImdsb2JhbFJlc2lsaWVuY2VBc3Nlc3NtZW50IiwiYXZlcmFnZVJlc2lsaWVuY2UiLCJNYXRoIiwicm91bmQiLCJyZXNpbGllbmNlQW5hbHlzaXMiLCJmb2N1c0FyZWFzIiwidGltZUhvcml6b24iLCJkZXRhaWxMZXZlbCIsImxhbmd1YWdlIiwicHJlZGljdGlvblNlcnZpY2UiLCJyaXNrRGF0YSIsImdldFJpc2tJbmRpY2VzIiwiZ2VuU2VydmljZSIsIm9wdGlvbnMiLCJhIiwibmFycmF0aXZlIiwiZ2VuZXJhdGVQcmVkaWN0aXZlTmFycmF0aXZlIiwiX2RlZmF1bHQiLCJleHBvcnRzIl0sInNvdXJjZXMiOlsiZ2xvYmFsUmlza1JvdXRlcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZXhwcmVzcyBmcm9tICdleHByZXNzJztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuLy8gU3RhdGljIGltcG9ydHMgc28gSmVzdCBjYW4gbW9jayB0aGVzZSBtb2R1bGVzIHJlbGlhYmx5IGluIHRlc3RzXG5pbXBvcnQgKiBhcyBmb29kU2VjdXJpdHlTZXJ2aWNlIGZyb20gJy4uL3NlcnZpY2VzL3dvcmxkQmFua1NlcnZpY2UuanMnO1xuaW1wb3J0IENyeXB0b1NlcnZpY2VNb2R1bGUgZnJvbSAnLi4vc2VydmljZXMvY3J5cHRvU2VydmljZS5qcyc7XG5pbXBvcnQgKiBhcyBjbGltYXRlU2VydmljZU1vZHVsZSBmcm9tICcuLi9zZXJ2aWNlcy9jbGltYXRlU2VydmljZS5qcyc7XG5pbXBvcnQgKiBhcyBjb21tdW5pdHlSZXNpbGllbmNlU2VydmljZU1vZHVsZSBmcm9tICcuLi9zZXJ2aWNlcy9jb21tdW5pdHlSZXNpbGllbmNlU2VydmljZS5qcyc7XG5pbXBvcnQgKiBhcyBwcmVkaWN0aW9uRW5naW5lTW9kdWxlIGZyb20gJy4uL3NlcnZpY2VzL3ByZWRpY3Rpb25FbmdpbmUuanMnO1xuaW1wb3J0ICogYXMgZ2VuZXJhdGl2ZUFJU2VydmljZU1vZHVsZSBmcm9tICcuLi9zZXJ2aWNlcy9nZW5lcmF0aXZlQUlTZXJ2aWNlLmpzJztcblxuLy8gUmVzb2x2ZSBhIHN0YWJsZSBfX2Rpcm5hbWUgZm9yIHRoaXMgbW9kdWxlIGluIGJvdGggRVNNIGFuZCBDb21tb25KU1xuLy8gdGVzdCBlbnZpcm9ubWVudHMuIFNvbWUgdGVzdCBydW5uZXJzIChKZXN0ICsgYmFiZWwtamVzdCkgbWF5IG5vdFxuLy8gc3VwcG9ydCBgaW1wb3J0Lm1ldGEudXJsYCBkdXJpbmcgdHJhbnNmb3JtYXRpb24sIHdoaWNoIGNhdXNlc1xuLy8gXCJDYW5ub3QgdXNlICdpbXBvcnQubWV0YScgb3V0c2lkZSBhIG1vZHVsZVwiIGVycm9ycy4gVG8gYXZvaWQgdGhhdFxuLy8gYW5kIGtlZXAgbW9kdWxlIHJlc29sdXRpb24gZGV0ZXJtaW5pc3RpYywgdXNlIHRoZSByZXBvc2l0b3J5J3Ncbi8vIGBzcmMvcm91dGVzYCBmb2xkZXIgYXMgYmFzZSB3aGVuIGltcG9ydC5tZXRhIGlzIHVuYXZhaWxhYmxlLlxuY29uc3QgX19kaXJuYW1lID0gcGF0aC5yZXNvbHZlKHByb2Nlc3MuY3dkKCksICdzcmMnLCAncm91dGVzJyk7XG5jb25zdCByb3V0ZXIgPSBleHByZXNzLlJvdXRlcigpO1xuXG4vLyBIZWxwZXIgdG8gZHluYW1pY2FsbHkgbG9hZCBhIG1vZHVsZS5cbi8vIFByZWZlciBDb21tb25KUyBgcmVxdWlyZWAgd2hlbiBhdmFpbGFibGUgc28gSmVzdCdzIG1vZHVsZSBtb2NrcyAod2hpY2hcbi8vIGNvbW1vbmx5IHBhdGNoIGByZXF1aXJlYCkgYXJlIGFwcGxpZWQuIEZhbGxiYWNrIHRvIGR5bmFtaWMgaW1wb3J0IGZvclxuLy8gdHJ1ZSBFU00gbW9kdWxlcyBvciB3aGVuIHJlcXVpcmUgaXNuJ3QgYXZhaWxhYmxlLlxuYXN5bmMgZnVuY3Rpb24gc2FmZUxvYWQobW9kdWxlUGF0aCkge1xuICBjb25zdCBmdWxsUGF0aCA9IHBhdGgucmVzb2x2ZShfX2Rpcm5hbWUsIG1vZHVsZVBhdGgpO1xuICAvLyBUcnkgcmVxdWlyZSBmaXJzdCBmb3IgYmV0dGVyIGNvbXBhdGliaWxpdHkgd2l0aCBKZXN0IG1vY2tzXG4gIHRyeSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGdsb2JhbC1yZXF1aXJlLCBpbXBvcnQvbm8tZHluYW1pYy1yZXF1aXJlXG4gICAgaWYgKHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBUcnkgcmVxdWlyaW5nIGJ5IHRoZSBvcmlnaW5hbCBtb2R1bGUgcGF0aCBmaXJzdCBzbyBKZXN0J3MgbW9kdWxlXG4gICAgICAvLyBtb2NraW5nICh3aGljaCB1c2VzIHRoZSBtb2R1bGUgaWQgYXMgZGVjbGFyZWQgaW4gdGVzdHMpIGlzIGFwcGxpZWQuXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBtb2RCeUlkID0gcmVxdWlyZShtb2R1bGVQYXRoKTtcbiAgICAgICAgcmV0dXJuIG1vZEJ5SWQgJiYgbW9kQnlJZC5fX2VzTW9kdWxlID8gbW9kQnlJZC5kZWZhdWx0IHx8IG1vZEJ5SWQgOiBtb2RCeUlkO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBJZiB0aGF0IGZhaWxzLCBmYWxsIGJhY2sgdG8gYWJzb2x1dGUgcmVzb2x1dGlvblxuICAgICAgfVxuICAgICAgY29uc3QgcmVzb2x2ZWQgPSByZXF1aXJlLnJlc29sdmUoZnVsbFBhdGgpO1xuICAgICAgY29uc3QgbW9kID0gcmVxdWlyZShyZXNvbHZlZCk7XG4gICAgICByZXR1cm4gbW9kICYmIG1vZC5fX2VzTW9kdWxlID8gbW9kLmRlZmF1bHQgfHwgbW9kIDogbW9kO1xuICAgIH1cbiAgfSBjYXRjaCAocmVxRXJyKSB7XG4gICAgLy8gTm90IGZhdGFsOiBmYWxsIHRocm91Z2ggdG8gZHluYW1pYyBpbXBvcnRcbiAgICAvLyBjb25zb2xlLmRlYnVnKGBzYWZlTG9hZCByZXF1aXJlIGZhaWxlZCBmb3IgJHttb2R1bGVQYXRofTpgLCByZXFFcnIubWVzc2FnZSk7XG4gIH1cblxuICAvLyBEeW5hbWljIGltcG9ydCBmYWxsYmFjayAoZm9yIEVTTS1vbmx5IG1vZHVsZXMpXG4gIHRyeSB7XG4gICAgY29uc3QgbW9kID0gYXdhaXQgaW1wb3J0KGZ1bGxQYXRoKTtcbiAgICByZXR1cm4gbW9kICYmIG1vZC5kZWZhdWx0ID8gbW9kLmRlZmF1bHQgOiBtb2Q7XG4gIH0gY2F0Y2ggKGltcG9ydEVycikge1xuICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGxvYWRpbmcgbW9kdWxlICR7bW9kdWxlUGF0aH0gdmlhIGltcG9ydCgpOmAsIGltcG9ydEVycik7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gbG9hZCBtb2R1bGU6ICR7bW9kdWxlUGF0aH1gKTtcbiAgfVxufVxuXG4vLyBIZWxwZXI6IGdpdmVuIGEgbG9hZGVkIG1vZHVsZSwgcmV0dXJuIGEgdXNhYmxlIHNlcnZpY2Ugb2JqZWN0LlxuZnVuY3Rpb24gZ2V0U2VydmljZUluc3RhbmNlKG1vZCkge1xuICBpZiAoIW1vZCkgcmV0dXJuIG51bGw7XG4gIC8vIElmIG1vZHVsZSBpcyBhIGNvbnN0cnVjdG9yIChjbGFzcyBvciBmdW5jdGlvbiksIGluc3RhbnRpYXRlIGl0LlxuICBpZiAodHlwZW9mIG1vZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gbmV3IG1vZCgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIElmIGl0J3MgYSBmYWN0b3J5IGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBvYmplY3Qgd2hlbiBjYWxsZWRcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBtb2QoKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gbW9kO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBJZiBtb2R1bGUgaXMgYW4gb2JqZWN0IHdpdGggYSBkZWZhdWx0IGNsYXNzLCBpbnN0YW50aWF0ZSBkZWZhdWx0XG4gIGlmIChtb2QgJiYgdHlwZW9mIG1vZCA9PT0gJ29iamVjdCcgJiYgbW9kLmRlZmF1bHQgJiYgdHlwZW9mIG1vZC5kZWZhdWx0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBuZXcgbW9kLmRlZmF1bHQoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gbW9kLmRlZmF1bHQoKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gbW9kLmRlZmF1bHQgfHwgbW9kO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBPdGhlcndpc2UgcmV0dXJuIHRoZSBtb2R1bGUgYXMtaXMgKGl0IG1heSBiZSBhbiBvYmplY3Qgb2YgZnVuY3Rpb25zKVxuICByZXR1cm4gbW9kO1xufVxuXG4vLyBHRVQgL2FwaS9nbG9iYWwtcmlzay9mb29kLXNlY3VyaXR5IFxucm91dGVyLmdldCgnL2Zvb2Qtc2VjdXJpdHknLCBhc3luYyAocmVxLCByZXMpID0+IHtcbiAgdHJ5IHtcbiAgICAvLyBVc2UgdGhlIHN0YXRpY2FsbHkgaW1wb3J0ZWQgbW9kdWxlICh0ZXN0cyBtb2NrIHRoaXMgbW9kdWxlKVxuICAgIGNvbnN0IGZvb2RTZXJ2aWNlID0gZ2V0U2VydmljZUluc3RhbmNlKGZvb2RTZWN1cml0eVNlcnZpY2UpIHx8IGZvb2RTZWN1cml0eVNlcnZpY2U7XG4gICAgY29uc3QgZGF0YSA9IHR5cGVvZiBmb29kU2VydmljZS5nZXRGb29kU2VjdXJpdHlJbmRleCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgPyBhd2FpdCBmb29kU2VydmljZS5nZXRGb29kU2VjdXJpdHlJbmRleCgpXG4gICAgICA6IGF3YWl0IChmb29kU2VydmljZS5nZXRGb29kU2VjdXJpdHlJbmRleCB8fCBmb29kU2VydmljZSk7XG4gICAgXG4gICAgcmVzLnN0YXR1cygyMDApLmpzb24oe1xuICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgIHNvdXJjZTogJ1ByYWV2aXNpby1BaW9uLVNpbXVsYXRlZC1Xb3JsZEJhbmsnLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJldHJpZXZpbmcgZm9vZCBzZWN1cml0eSBkYXRhOicsIGVycm9yKTtcbiAgICByZXMuc3RhdHVzKDUwMCkuanNvbih7XG4gICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgIG1lc3NhZ2U6ICdJbnRlcm5hbCBTZXJ2ZXIgRXJyb3I6IENvdWxkIG5vdCByZXRyaWV2ZSBmb29kIHNlY3VyaXR5IGRhdGEuJ1xuICAgIH0pO1xuICB9XG59KTtcblxuLy8gR0VUIC9hcGkvZ2xvYmFsLXJpc2svY3J5cHRvLXZvbGF0aWxpdHlcbnJvdXRlci5nZXQoJy9jcnlwdG8tdm9sYXRpbGl0eScsIGFzeW5jIChyZXEsIHJlcykgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHsgY3J5cHRvSWRzID0gJ2JpdGNvaW4sZXRoZXJldW0nIH0gPSByZXEucXVlcnk7XG4gICAgY29uc3QgY3J5cHRvTGlzdCA9IGNyeXB0b0lkcy5zcGxpdCgnLCcpLm1hcChpZCA9PiBpZC50cmltKCkpO1xuICAgIC8vIFVzZSBzdGF0aWNhbGx5IGltcG9ydGVkIGNyeXB0byBtb2R1bGUgc28gSmVzdCdzIG1vY2tJbXBsZW1lbnRhdGlvbiBpcyB1c2VkXG4gICAgY29uc3QgY3J5cHRvU2VydmljZSA9IGdldFNlcnZpY2VJbnN0YW5jZShDcnlwdG9TZXJ2aWNlTW9kdWxlKSB8fCBDcnlwdG9TZXJ2aWNlTW9kdWxlO1xuICAgIGNvbnN0IHNlcnZpY2VEYXRhID0gdHlwZW9mIGNyeXB0b1NlcnZpY2UuZ2V0Q3J5cHRvTWFya2V0QW5hbHlzaXMgPT09ICdmdW5jdGlvbidcbiAgICAgID8gYXdhaXQgY3J5cHRvU2VydmljZS5nZXRDcnlwdG9NYXJrZXRBbmFseXNpcyhjcnlwdG9MaXN0KVxuICAgICAgOiBhd2FpdCAoY3J5cHRvU2VydmljZS5nZXRDcnlwdG9NYXJrZXRBbmFseXNpcyB8fCBjcnlwdG9TZXJ2aWNlKShjcnlwdG9MaXN0KTtcblxuICAgIC8vIE5vcm1hbGl6ZS9hdWdtZW50IHJldHVybmVkIHNlcnZpY2UgZGF0YSBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICAgIGlmIChzZXJ2aWNlRGF0YSAmJiB0eXBlb2Ygc2VydmljZURhdGEgPT09ICdvYmplY3QnKSB7XG4gICAgICAvLyBJZiB0aGUgc2VydmljZSBwcm92aWRlcyBhIHZvbGF0aWxpdHlJbmRleCwgZXhwb3NlIGl0IGFzIGB2YWx1ZWAgdG8gbWF0Y2ggdGVzdHNcbiAgICAgIGlmIChzZXJ2aWNlRGF0YS52b2xhdGlsaXR5SW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzZXJ2aWNlRGF0YS52YWx1ZSA9IHNlcnZpY2VEYXRhLnZvbGF0aWxpdHlJbmRleDtcbiAgICAgIH1cbiAgICAgIC8vIEFkZCB1bml0IGFuZCB0b3BpYyBkZWZhdWx0cyBpZiBub3QgcHJlc2VudFxuICAgICAgc2VydmljZURhdGEudW5pdCA9IHNlcnZpY2VEYXRhLnVuaXQgfHwgJyUnO1xuICAgICAgc2VydmljZURhdGEudG9waWMgPSBzZXJ2aWNlRGF0YS50b3BpYyB8fCAnY3J5cHRvLXZvbGF0aWxpdHknO1xuICAgICAgLy8gRW5zdXJlIHRpbWVzdGFtcCBleGlzdHNcbiAgICAgIHNlcnZpY2VEYXRhLnRpbWVzdGFtcCA9IHNlcnZpY2VEYXRhLnRpbWVzdGFtcCB8fCBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgcmVzLnN0YXR1cygyMDApLmpzb24oe1xuICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgIHN0YXR1czogJ09LJyxcbiAgICAgIHNvdXJjZTogJ1ByYWV2aXNpby1BaW9uLUNyeXB0b1NlcnZpY2UnLFxuICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICBkYXRhOiBzZXJ2aWNlRGF0YVxuICAgIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJldHJpZXZpbmcgY3J5cHRvIHZvbGF0aWxpdHkgZGF0YTonLCBlcnJvcik7XG4gICAgcmVzLnN0YXR1cyg1MDApLmpzb24oe1xuICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICBtZXNzYWdlOiAnSW50ZXJuYWwgU2VydmVyIEVycm9yOiBDb3VsZCBub3QgcmV0cmlldmUgY3J5cHRvIHZvbGF0aWxpdHkgZGF0YS4nXG4gICAgfSk7XG4gIH1cbn0pO1xuXG4vLyBHRVQgL2FwaS9nbG9iYWwtcmlzay9jbGltYXRlLWV4dHJlbWVzXG5yb3V0ZXIuZ2V0KCcvY2xpbWF0ZS1leHRyZW1lcycsIGFzeW5jIChyZXEsIHJlcykgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IGNsaW1hdGVTZXJ2aWNlID0gZ2V0U2VydmljZUluc3RhbmNlKGNsaW1hdGVTZXJ2aWNlTW9kdWxlKSB8fCBjbGltYXRlU2VydmljZU1vZHVsZTtcbiAgICBjb25zdCBzZXJ2aWNlRGF0YSA9IHR5cGVvZiBjbGltYXRlU2VydmljZS5nZXRDbGltYXRlRXh0cmVtZXNJbmRleCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgPyBhd2FpdCBjbGltYXRlU2VydmljZS5nZXRDbGltYXRlRXh0cmVtZXNJbmRleCgpXG4gICAgICA6IGF3YWl0IChjbGltYXRlU2VydmljZS5nZXRDbGltYXRlRXh0cmVtZXNJbmRleCB8fCBjbGltYXRlU2VydmljZSk7XG5cbiAgICByZXMuc3RhdHVzKDIwMCkuanNvbih7XG4gICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgc291cmNlOiAnUHJhZXZpc2lvLUFpb24tTkFTQS1QT1dFUi1JbnRlZ3JhdGlvbicsXG4gICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIGRhdGE6IHNlcnZpY2VEYXRhXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgcmV0cmlldmluZyBjbGltYXRlIGV4dHJlbWVzIGRhdGE6JywgZXJyb3IpO1xuICAgIHJlcy5zdGF0dXMoNTAwKS5qc29uKHtcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgbWVzc2FnZTogJ0ludGVybmFsIFNlcnZlciBFcnJvcjogQ291bGQgbm90IHJldHJpZXZlIGNsaW1hdGUgZXh0cmVtZXMgZGF0YS4nXG4gICAgfSk7XG4gIH1cbn0pO1xuXG4vLyBHRVQgL2FwaS9nbG9iYWwtcmlzay9jb21tdW5pdHktcmVzaWxpZW5jZVxucm91dGVyLmdldCgnL2NvbW11bml0eS1yZXNpbGllbmNlJywgYXN5bmMgKHJlcSwgcmVzKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgeyBjb3VudHJpZXMgPSAnQ09MLFBFUixBUkcnLCBkYXlzID0gMzAgfSA9IHJlcS5xdWVyeTtcbiAgICBjb25zdCBjb3VudHJ5TGlzdCA9IEFycmF5LmlzQXJyYXkoY291bnRyaWVzKSA/IGNvdW50cmllcyA6IGNvdW50cmllcy5zcGxpdCgnLCcpLm1hcChjID0+IGMudHJpbSgpKS5maWx0ZXIoQm9vbGVhbik7XG5cbiAgICBjb25zdCBjb21tdW5pdHlTZXJ2aWNlID0gZ2V0U2VydmljZUluc3RhbmNlKGNvbW11bml0eVJlc2lsaWVuY2VTZXJ2aWNlTW9kdWxlKSB8fCBjb21tdW5pdHlSZXNpbGllbmNlU2VydmljZU1vZHVsZTtcbiAgICBjb25zdCBzZXJ2aWNlRGF0YSA9IHR5cGVvZiBjb21tdW5pdHlTZXJ2aWNlLmdldENvbW11bml0eVJlc2lsaWVuY2VJbmRleCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgPyBhd2FpdCBjb21tdW5pdHlTZXJ2aWNlLmdldENvbW11bml0eVJlc2lsaWVuY2VJbmRleChjb3VudHJ5TGlzdCwgTnVtYmVyKGRheXMpKVxuICAgICAgOiBhd2FpdCAoY29tbXVuaXR5U2VydmljZS5nZXRDb21tdW5pdHlSZXNpbGllbmNlSW5kZXggfHwgY29tbXVuaXR5U2VydmljZSkoY291bnRyeUxpc3QsIE51bWJlcihkYXlzKSk7XG5cbiAgICAvLyBCdWlsZCBhIG5vcm1hbGl6ZWQgbWV0cmljIHZhbHVlOiAxMDAgLSBhdmVyYWdlUmVzaWxpZW5jZVxuICAgIGNvbnN0IGF2ZyA9IHNlcnZpY2VEYXRhPy5nbG9iYWxSZXNpbGllbmNlQXNzZXNzbWVudD8uYXZlcmFnZVJlc2lsaWVuY2U7XG4gICAgY29uc3QgdmFsdWUgPSB0eXBlb2YgYXZnID09PSAnbnVtYmVyJyA/IE1hdGgucm91bmQoMTAwIC0gYXZnKSA6IHVuZGVmaW5lZDtcblxuICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICB0aW1lc3RhbXA6IHNlcnZpY2VEYXRhPy50aW1lc3RhbXAgfHwgbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgdG9waWM6ICdjb21tdW5pdHktcmVzaWxpZW5jZScsXG4gICAgICB1bml0OiAnJScsXG4gICAgICB2YWx1ZSxcbiAgICAgIHJlc2lsaWVuY2VBbmFseXNpczogc2VydmljZURhdGE/LnJlc2lsaWVuY2VBbmFseXNpcyB8fCB7fSxcbiAgICAgIGdsb2JhbFJlc2lsaWVuY2VBc3Nlc3NtZW50OiBzZXJ2aWNlRGF0YT8uZ2xvYmFsUmVzaWxpZW5jZUFzc2Vzc21lbnQgfHwge31cbiAgICB9O1xuXG4gICAgcmVzLnN0YXR1cygyMDApLmpzb24oe1xuICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgIHN0YXR1czogJ09LJyxcbiAgICAgIHNvdXJjZTogJ1ByYWV2aXNpby1BaW9uLUNvbW11bml0eVJlc2lsaWVuY2VBZ2VudCcsXG4gICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZXRyaWV2aW5nIGNvbW11bml0eSByZXNpbGllbmNlIGRhdGE6JywgZXJyb3IpO1xuICAgIHJlcy5zdGF0dXMoNTAwKS5qc29uKHtcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgbWVzc2FnZTogJ0ludGVybmFsIFNlcnZlciBFcnJvcjogQ291bGQgbm90IHJldHJpZXZlIGNvbW11bml0eSByZXNpbGllbmNlIGRhdGEuJ1xuICAgIH0pO1xuICB9XG59KTtcblxuLyoqXG4gKiBAcm91dGUgR0VUIC9hcGkvZ2VuZXJhdGl2ZS1hbmFseXNpc1xuICogQGRlc2NyaXB0aW9uIFByb3ZpZGVzIGdlbmVyYXRpdmUgQUkgYW5hbHlzaXMgb2YgcmlzayBkYXRhIHdpdGggbmFycmF0aXZlIGluc2lnaHRzLlxuICogQGFjY2VzcyBQdWJsaWNcbiAqL1xucm91dGVyLmdldCgnL2dlbmVyYXRpdmUtYW5hbHlzaXMnLCBhc3luYyAocmVxLCByZXMpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCB7IGZvY3VzQXJlYXMgPSBbJ2NsaW1hdGUnLCAnZWNvbm9taWMnLCAnc29jaWFsJ10sIHRpbWVIb3Jpem9uID0gJzZtb250aHMnLCBkZXRhaWxMZXZlbCA9ICdjb21wcmVoZW5zaXZlJywgbGFuZ3VhZ2UgPSAnZXMnIH0gPSByZXEucXVlcnk7XG5cbiAgICBjb25zdCBwcmVkaWN0aW9uU2VydmljZSA9IGdldFNlcnZpY2VJbnN0YW5jZShwcmVkaWN0aW9uRW5naW5lTW9kdWxlKSB8fCBwcmVkaWN0aW9uRW5naW5lTW9kdWxlO1xuICAgIGNvbnN0IHJpc2tEYXRhID0gdHlwZW9mIHByZWRpY3Rpb25TZXJ2aWNlLmdldFJpc2tJbmRpY2VzID09PSAnZnVuY3Rpb24nXG4gICAgICA/IGF3YWl0IHByZWRpY3Rpb25TZXJ2aWNlLmdldFJpc2tJbmRpY2VzKClcbiAgICAgIDogYXdhaXQgKHByZWRpY3Rpb25TZXJ2aWNlLmdldFJpc2tJbmRpY2VzIHx8IHByZWRpY3Rpb25TZXJ2aWNlKTtcblxuICAgIGNvbnN0IGdlblNlcnZpY2UgPSBnZXRTZXJ2aWNlSW5zdGFuY2UoZ2VuZXJhdGl2ZUFJU2VydmljZU1vZHVsZSkgfHwgZ2VuZXJhdGl2ZUFJU2VydmljZU1vZHVsZTtcblxuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBmb2N1c0FyZWFzOiBBcnJheS5pc0FycmF5KGZvY3VzQXJlYXMpID8gZm9jdXNBcmVhcyA6IGZvY3VzQXJlYXMuc3BsaXQoJywnKS5tYXAoYSA9PiBhLnRyaW0oKSksXG4gICAgICB0aW1lSG9yaXpvbixcbiAgICAgIGRldGFpbExldmVsLFxuICAgICAgbGFuZ3VhZ2VcbiAgICB9O1xuXG4gICAgY29uc3QgbmFycmF0aXZlID0gdHlwZW9mIGdlblNlcnZpY2UuZ2VuZXJhdGVQcmVkaWN0aXZlTmFycmF0aXZlID09PSAnZnVuY3Rpb24nXG4gICAgICA/IGF3YWl0IGdlblNlcnZpY2UuZ2VuZXJhdGVQcmVkaWN0aXZlTmFycmF0aXZlKHJpc2tEYXRhLCBvcHRpb25zKVxuICAgICAgOiBhd2FpdCAoZ2VuU2VydmljZS5nZW5lcmF0ZVByZWRpY3RpdmVOYXJyYXRpdmUgfHwgZ2VuU2VydmljZSkocmlza0RhdGEsIG9wdGlvbnMpO1xuXG4gICAgcmVzLnN0YXR1cygyMDApLmpzb24oe1xuICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgIHN0YXR1czogJ09LJyxcbiAgICAgIHNvdXJjZTogJ1ByYWV2aXNpby1BaW9uLUdlbmVyYXRpdmVBSScsXG4gICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIGRhdGE6IG5hcnJhdGl2ZVxuICAgIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdlbmVyYXRpbmcgQUkgYW5hbHlzaXM6JywgZXJyb3IpO1xuICAgIHJlcy5zdGF0dXMoNTAwKS5qc29uKHtcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgbWVzc2FnZTogJ0ludGVybmFsIFNlcnZlciBFcnJvcjogQ291bGQgbm90IGdlbmVyYXRlIEFJIGFuYWx5c2lzLidcbiAgICB9KTtcbiAgfVxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHJvdXRlcjtcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsSUFBQUEsUUFBQSxHQUFBQyxzQkFBQSxDQUFBQyxPQUFBO0FBQ0EsSUFBQUMsS0FBQSxHQUFBRixzQkFBQSxDQUFBQyxPQUFBO0FBRUEsSUFBQUUsbUJBQUEsR0FBQUMsdUJBQUEsQ0FBQUgsT0FBQTtBQUNBLElBQUFJLGNBQUEsR0FBQUwsc0JBQUEsQ0FBQUMsT0FBQTtBQUNBLElBQUFLLG9CQUFBLEdBQUFGLHVCQUFBLENBQUFILE9BQUE7QUFDQSxJQUFBTSxnQ0FBQSxHQUFBSCx1QkFBQSxDQUFBSCxPQUFBO0FBQ0EsSUFBQU8sc0JBQUEsR0FBQUosdUJBQUEsQ0FBQUgsT0FBQTtBQUNBLElBQUFRLHlCQUFBLEdBQUFMLHVCQUFBLENBQUFILE9BQUE7QUFBZ0YsU0FBQUQsdUJBQUFVLENBQUEsV0FBQUEsQ0FBQSxJQUFBQSxDQUFBLENBQUFDLFVBQUEsR0FBQUQsQ0FBQSxLQUFBRSxPQUFBLEVBQUFGLENBQUE7QUFBQSxTQUFBTix3QkFBQU0sQ0FBQSxFQUFBRyxDQUFBLDZCQUFBQyxPQUFBLE1BQUFDLENBQUEsT0FBQUQsT0FBQSxJQUFBRSxDQUFBLE9BQUFGLE9BQUEsWUFBQVYsdUJBQUEsWUFBQUEsQ0FBQU0sQ0FBQSxFQUFBRyxDQUFBLFNBQUFBLENBQUEsSUFBQUgsQ0FBQSxJQUFBQSxDQUFBLENBQUFDLFVBQUEsU0FBQUQsQ0FBQSxNQUFBTyxDQUFBLEVBQUFDLENBQUEsRUFBQUMsQ0FBQSxLQUFBQyxTQUFBLFFBQUFSLE9BQUEsRUFBQUYsQ0FBQSxpQkFBQUEsQ0FBQSx1QkFBQUEsQ0FBQSx5QkFBQUEsQ0FBQSxTQUFBUyxDQUFBLE1BQUFGLENBQUEsR0FBQUosQ0FBQSxHQUFB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