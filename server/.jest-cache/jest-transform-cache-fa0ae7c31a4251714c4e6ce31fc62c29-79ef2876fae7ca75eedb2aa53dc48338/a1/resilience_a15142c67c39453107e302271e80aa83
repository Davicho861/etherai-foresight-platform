7027ab45f2b55d23182727fe6c51ca38
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CircuitBreaker = void 0;
exports.fetchWithTimeout = fetchWithTimeout;
exports.isJsonResponse = isJsonResponse;
exports.retryWithBackoff = retryWithBackoff;
/**
 * Utilidades de resiliencia para APIs externas
 * Incluye retry logic, circuit breaker y timeouts
 */

class CircuitBreaker {
  constructor(failureThreshold = 3, recoveryTimeout = 60000) {
    this.failureThreshold = failureThreshold;
    this.recoveryTimeout = recoveryTimeout;
    this.failureCount = 0;
    this.lastFailureTime = null;
    this.state = 'CLOSED'; // CLOSED, OPEN, HALF_OPEN
  }
  async execute(fn) {
    if (this.state === 'OPEN') {
      if (Date.now() - this.lastFailureTime > this.recoveryTimeout) {
        this.state = 'HALF_OPEN';
      } else {
        throw new Error('Circuit breaker is OPEN');
      }
    }
    try {
      const result = await fn();
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }
  onSuccess() {
    this.failureCount = 0;
    this.state = 'CLOSED';
  }
  onFailure() {
    this.failureCount++;
    this.lastFailureTime = Date.now();
    if (this.failureCount >= this.failureThreshold) {
      this.state = 'OPEN';
    }
  }
}
exports.CircuitBreaker = CircuitBreaker;
async function retryWithBackoff(fn, maxRetries = 3, baseDelay = 1000, maxDelay = 10000) {
  let lastError;
  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error;
      if (attempt === maxRetries) {
        break;
      }

      // Exponential backoff with jitter
      const delay = Math.min(baseDelay * Math.pow(2, attempt), maxDelay);
      const jitter = Math.random() * 0.1 * delay;
      const totalDelay = delay + jitter;
      console.log(`Retry attempt ${attempt + 1}/${maxRetries} after ${totalDelay.toFixed(0)}ms: ${error.message}`);
      await new Promise(resolve => setTimeout(resolve, totalDelay));
    }
  }
  throw lastError;
}
async function fetchWithTimeout(url, options = {}, timeout = 10000) {
  const controller = new AbortController();

  // Create a timeout promise that rejects after `timeout` ms.
  // We still call controller.abort() to keep behavior when real fetch supports it,
  // but also race the fetch against this timeout so mocked fetches that ignore
  // the signal don't hang the test.
  let timeoutId;
  const timeoutPromise = new Promise((_, reject) => {
    timeoutId = setTimeout(() => {
      try {
        controller.abort();
      } catch (e) {}
      reject(new Error(`Request timeout after ${timeout}ms`));
    }, timeout);
  });
  try {
    // Provide conservative default headers to reduce chance of being blocked by upstream providers
    const defaultHeaders = {
      'User-Agent': 'Praevisio/1.0 (+https://praevisio.local)',
      'Accept': 'application/json, text/plain, */*'
    };
    const mergedOptions = {
      ...options,
      headers: {
        ...(options.headers || {}),
        ...defaultHeaders
      },
      signal: controller.signal
    };
    const response = await Promise.race([fetch(url, mergedOptions), timeoutPromise]);
    clearTimeout(timeoutId);
    return response;
  } catch (error) {
    clearTimeout(timeoutId);
    // If the fetch was aborted and produced an AbortError, normalize the message
    if (error && error.name === 'AbortError') {
      throw new Error(`Request timeout after ${timeout}ms`);
    }
    throw error;
  }
}
function isJsonResponse(response) {
  const contentType = response.headers.get('content-type');
  return !!(contentType && contentType.includes('application/json'));
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJDaXJjdWl0QnJlYWtlciIsImNvbnN0cnVjdG9yIiwiZmFpbHVyZVRocmVzaG9sZCIsInJlY292ZXJ5VGltZW91dCIsImZhaWx1cmVDb3VudCIsImxhc3RGYWlsdXJlVGltZSIsInN0YXRlIiwiZXhlY3V0ZSIsImZuIiwiRGF0ZSIsIm5vdyIsIkVycm9yIiwicmVzdWx0Iiwib25TdWNjZXNzIiwiZXJyb3IiLCJvbkZhaWx1cmUiLCJleHBvcnRzIiwicmV0cnlXaXRoQmFja29mZiIsIm1heFJldHJpZXMiLCJiYXNlRGVsYXkiLCJtYXhEZWxheSIsImxhc3RFcnJvciIsImF0dGVtcHQiLCJkZWxheSIsIk1hdGgiLCJtaW4iLCJwb3ciLCJqaXR0ZXIiLCJyYW5kb20iLCJ0b3RhbERlbGF5IiwiY29uc29sZSIsImxvZyIsInRvRml4ZWQiLCJtZXNzYWdlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwiZmV0Y2hXaXRoVGltZW91dCIsInVybCIsIm9wdGlvbnMiLCJ0aW1lb3V0IiwiY29udHJvbGxlciIsIkFib3J0Q29udHJvbGxlciIsInRpbWVvdXRJZCIsInRpbWVvdXRQcm9taXNlIiwiXyIsInJlamVjdCIsImFib3J0IiwiZSIsImRlZmF1bHRIZWFkZXJzIiwibWVyZ2VkT3B0aW9ucyIsImhlYWRlcnMiLCJzaWduYWwiLCJyZXNwb25zZSIsInJhY2UiLCJmZXRjaCIsImNsZWFyVGltZW91dCIsIm5hbWUiLCJpc0pzb25SZXNwb25zZSIsImNvbnRlbnRUeXBlIiwiZ2V0IiwiaW5jbHVkZXMiXSwic291cmNlcyI6WyJyZXNpbGllbmNlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVXRpbGlkYWRlcyBkZSByZXNpbGllbmNpYSBwYXJhIEFQSXMgZXh0ZXJuYXNcbiAqIEluY2x1eWUgcmV0cnkgbG9naWMsIGNpcmN1aXQgYnJlYWtlciB5IHRpbWVvdXRzXG4gKi9cblxuY2xhc3MgQ2lyY3VpdEJyZWFrZXIge1xuICBjb25zdHJ1Y3RvcihmYWlsdXJlVGhyZXNob2xkID0gMywgcmVjb3ZlcnlUaW1lb3V0ID0gNjAwMDApIHtcbiAgICB0aGlzLmZhaWx1cmVUaHJlc2hvbGQgPSBmYWlsdXJlVGhyZXNob2xkO1xuICAgIHRoaXMucmVjb3ZlcnlUaW1lb3V0ID0gcmVjb3ZlcnlUaW1lb3V0O1xuICAgIHRoaXMuZmFpbHVyZUNvdW50ID0gMDtcbiAgICB0aGlzLmxhc3RGYWlsdXJlVGltZSA9IG51bGw7XG4gICAgdGhpcy5zdGF0ZSA9ICdDTE9TRUQnOyAvLyBDTE9TRUQsIE9QRU4sIEhBTEZfT1BFTlxuICB9XG5cbiAgYXN5bmMgZXhlY3V0ZShmbikge1xuICAgIGlmICh0aGlzLnN0YXRlID09PSAnT1BFTicpIHtcbiAgICAgIGlmIChEYXRlLm5vdygpIC0gdGhpcy5sYXN0RmFpbHVyZVRpbWUgPiB0aGlzLnJlY292ZXJ5VGltZW91dCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gJ0hBTEZfT1BFTic7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NpcmN1aXQgYnJlYWtlciBpcyBPUEVOJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGZuKCk7XG4gICAgICB0aGlzLm9uU3VjY2VzcygpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5vbkZhaWx1cmUoKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIG9uU3VjY2VzcygpIHtcbiAgICB0aGlzLmZhaWx1cmVDb3VudCA9IDA7XG4gICAgdGhpcy5zdGF0ZSA9ICdDTE9TRUQnO1xuICB9XG5cbiAgb25GYWlsdXJlKCkge1xuICAgIHRoaXMuZmFpbHVyZUNvdW50Kys7XG4gICAgdGhpcy5sYXN0RmFpbHVyZVRpbWUgPSBEYXRlLm5vdygpO1xuICAgIGlmICh0aGlzLmZhaWx1cmVDb3VudCA+PSB0aGlzLmZhaWx1cmVUaHJlc2hvbGQpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSAnT1BFTic7XG4gICAgfVxuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJldHJ5V2l0aEJhY2tvZmYoZm4sIG1heFJldHJpZXMgPSAzLCBiYXNlRGVsYXkgPSAxMDAwLCBtYXhEZWxheSA9IDEwMDAwKSB7XG4gIGxldCBsYXN0RXJyb3I7XG5cbiAgZm9yIChsZXQgYXR0ZW1wdCA9IDA7IGF0dGVtcHQgPD0gbWF4UmV0cmllczsgYXR0ZW1wdCsrKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCBmbigpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsYXN0RXJyb3IgPSBlcnJvcjtcblxuICAgICAgaWYgKGF0dGVtcHQgPT09IG1heFJldHJpZXMpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIC8vIEV4cG9uZW50aWFsIGJhY2tvZmYgd2l0aCBqaXR0ZXJcbiAgICAgIGNvbnN0IGRlbGF5ID0gTWF0aC5taW4oYmFzZURlbGF5ICogTWF0aC5wb3coMiwgYXR0ZW1wdCksIG1heERlbGF5KTtcbiAgICAgIGNvbnN0IGppdHRlciA9IE1hdGgucmFuZG9tKCkgKiAwLjEgKiBkZWxheTtcbiAgICAgIGNvbnN0IHRvdGFsRGVsYXkgPSBkZWxheSArIGppdHRlcjtcblxuICAgICAgY29uc29sZS5sb2coYFJldHJ5IGF0dGVtcHQgJHthdHRlbXB0ICsgMX0vJHttYXhSZXRyaWVzfSBhZnRlciAke3RvdGFsRGVsYXkudG9GaXhlZCgwKX1tczogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIHRvdGFsRGVsYXkpKTtcbiAgICB9XG4gIH1cblxuICB0aHJvdyBsYXN0RXJyb3I7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGZldGNoV2l0aFRpbWVvdXQodXJsLCBvcHRpb25zID0ge30sIHRpbWVvdXQgPSAxMDAwMCkge1xuICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuXG4gIC8vIENyZWF0ZSBhIHRpbWVvdXQgcHJvbWlzZSB0aGF0IHJlamVjdHMgYWZ0ZXIgYHRpbWVvdXRgIG1zLlxuICAvLyBXZSBzdGlsbCBjYWxsIGNvbnRyb2xsZXIuYWJvcnQoKSB0byBrZWVwIGJlaGF2aW9yIHdoZW4gcmVhbCBmZXRjaCBzdXBwb3J0cyBpdCxcbiAgLy8gYnV0IGFsc28gcmFjZSB0aGUgZmV0Y2ggYWdhaW5zdCB0aGlzIHRpbWVvdXQgc28gbW9ja2VkIGZldGNoZXMgdGhhdCBpZ25vcmVcbiAgLy8gdGhlIHNpZ25hbCBkb24ndCBoYW5nIHRoZSB0ZXN0LlxuICBsZXQgdGltZW91dElkO1xuICBjb25zdCB0aW1lb3V0UHJvbWlzZSA9IG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IHtcbiAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRyeSB7IGNvbnRyb2xsZXIuYWJvcnQoKTsgfSBjYXRjaCAoZSkge31cbiAgICAgIHJlamVjdChuZXcgRXJyb3IoYFJlcXVlc3QgdGltZW91dCBhZnRlciAke3RpbWVvdXR9bXNgKSk7XG4gICAgfSwgdGltZW91dCk7XG4gIH0pO1xuXG4gIHRyeSB7XG4gICAgLy8gUHJvdmlkZSBjb25zZXJ2YXRpdmUgZGVmYXVsdCBoZWFkZXJzIHRvIHJlZHVjZSBjaGFuY2Ugb2YgYmVpbmcgYmxvY2tlZCBieSB1cHN0cmVhbSBwcm92aWRlcnNcbiAgICBjb25zdCBkZWZhdWx0SGVhZGVycyA9IHtcbiAgICAgICdVc2VyLUFnZW50JzogJ1ByYWV2aXNpby8xLjAgKCtodHRwczovL3ByYWV2aXNpby5sb2NhbCknLFxuICAgICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L3BsYWluLCAqLyonXG4gICAgfTtcbiAgICBjb25zdCBtZXJnZWRPcHRpb25zID0geyAuLi5vcHRpb25zLCBoZWFkZXJzOiB7IC4uLihvcHRpb25zLmhlYWRlcnMgfHwge30pLCAuLi5kZWZhdWx0SGVhZGVycyB9LCBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsIH07XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBQcm9taXNlLnJhY2UoW1xuICAgICAgZmV0Y2godXJsLCBtZXJnZWRPcHRpb25zKSxcbiAgICAgIHRpbWVvdXRQcm9taXNlXG4gICAgXSk7XG5cbiAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgLy8gSWYgdGhlIGZldGNoIHdhcyBhYm9ydGVkIGFuZCBwcm9kdWNlZCBhbiBBYm9ydEVycm9yLCBub3JtYWxpemUgdGhlIG1lc3NhZ2VcbiAgICBpZiAoZXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gJ0Fib3J0RXJyb3InKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlcXVlc3QgdGltZW91dCBhZnRlciAke3RpbWVvdXR9bXNgKTtcbiAgICB9XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNKc29uUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgY29uc3QgY29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJyk7XG4gIHJldHVybiAhIShjb250ZW50VHlwZSAmJiBjb250ZW50VHlwZS5pbmNsdWRlcygnYXBwbGljYXRpb24vanNvbicpKTtcbn1cblxuZXhwb3J0IHsgQ2lyY3VpdEJyZWFrZXIsIHJldHJ5V2l0aEJhY2tvZmYsIGZldGNoV2l0aFRpbWVvdXQsIGlzSnNvblJlc3BvbnNlIH07Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNQSxjQUFjLENBQUM7RUFDbkJDLFdBQVdBLENBQUNDLGdCQUFnQixHQUFHLENBQUMsRUFBRUMsZUFBZSxHQUFHLEtBQUssRUFBRTtJQUN6RCxJQUFJLENBQUNELGdCQUFnQixHQUFHQSxnQkFB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QUssRUFBRTtFQUNsRSxNQUFNQyxVQUFVLEdBQUcsSUFBSUMsZUFBZSxDQUFDLENBQUM7O0VBRXhDO0VBQ0E7RUFDQTtFQUNBO0VBQ0EsSUFBSUMsU0FBUztFQUNiLE1BQU1DLGNBQWMsR0FBRyxJQUFJVixPQUFPLENBQUMsQ0FBQ1csQ0FBQyxFQUFFQyxNQUFNLEtBQUs7SUFDaERILFNBQVMsR0FBR1AsVUFBVSxDQUFDLE1BQU07TUFDM0IsSUFBSTtRQUFFSyxVQUFVLENBQUNNLEtBQUssQ0FBQyxDQUFDO01BQUUsQ0FBQyxDQUFDLE9BQU9DLENBQUMsRUFBRSxDQUFDO01BQ3ZDRixNQUFNLENBQUMsSUFBSW5DLEtBQUssQ0FBQyx5QkFBeUI2QixPQUFPLElBQUksQ0FBQyxDQUFDO0lBQ3pELENBQUMsRUFBRUEsT0FBTyxDQUFDO0VBQ2IsQ0FBQyxDQUFDO0VBRUYsSUFBSTtJQUNGO0lBQ0EsTUFBTVMsY0FBYyxHQUFHO01BQ3JCLFlBQVksRUFBRSwwQ0FBMEM7TUFDeEQsUUFBUSxFQUFFO0lBQ1osQ0FBQztJQUNELE1BQU1DLGFBQWEsR0FBRztNQUFFLEdBQUdYLE9BQU87TUFBRVksT0FBTyxFQUFFO1FBQUUsSUFBSVosT0FBTyxDQUFDWSxPQUFPLElBQUksQ0FBQyxDQUFDLENBQUM7UUFBRSxHQUFHRjtNQUFlLENBQUM7TUFBRUcsTUFBTSxFQUFFWCxVQUFVLENBQUNXO0lBQU8sQ0FBQztJQUMzSCxNQUFNQyxRQUFRLEdBQUcsTUFBTW5CLE9BQU8sQ0FBQ29CLElBQUksQ0FBQyxDQUNsQ0MsS0FBSyxDQUFDakIsR0FBRyxFQUFFWSxhQUFhLENBQUMsRUFDekJOLGNBQWMsQ0FDZixDQUFDO0lBRUZZLFlBQVksQ0FBQ2IsU0FBUyxDQUFDO0lBQ3ZCLE9BQU9VLFFBQVE7RUFDakIsQ0FBQyxDQUFDLE9BQU92QyxLQUFLLEVBQUU7SUFDZDBDLFlBQVksQ0FBQ2IsU0FBUyxDQUFDO0lBQ3ZCO0lBQ0EsSUFBSTdCLEtBQUssSUFBSUEsS0FBSyxDQUFDMkMsSUFBSSxLQUFLLFlBQVksRUFBRTtNQUN4QyxNQUFNLElBQUk5QyxLQUFLLENBQUMseUJBQXlCNkIsT0FBTyxJQUFJLENBQUM7SUFDdkQ7SUFDQSxNQUFNMUIsS0FBSztFQUNiO0FBQ0Y7QUFFQSxTQUFTNEMsY0FBY0EsQ0FBQ0wsUUFBUSxFQUFFO0VBQ2hDLE1BQU1NLFdBQVcsR0FBR04sUUFBUSxDQUFDRixPQUFPLENBQUNTLEdBQUcsQ0FBQyxjQUFjLENBQUM7RUFDeEQsT0FBTyxDQUFDLEVBQUVELFdBQVcsSUFBSUEsV0FBVyxDQUFDRSxRQUFRLENBQUMsa0JBQWtCLENBQUMsQ0FBQztBQUNwRSIsImlnbm9yZUxpc3QiOltdfQ==