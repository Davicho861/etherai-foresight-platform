{"version":3,"names":["_outvariant","require","_deferredpromise","InterceptorError","Error","constructor","message","name","Object","setPrototypeOf","prototype","kRequestHandled","Symbol","kResponsePromise","RequestController","request","DeferredPromise","respondWith","response","invariant","as","method","url","resolve","errorWith","reason","emitAsync","emitter","eventName","data","listeners","length","listener","apply","_until","isObject","value","loose","toString","call","startsWith","isPropertyAccessible","obj","key","e","createServerErrorResponse","body","Response","JSON","stringify","stack","status","statusText","headers","isResponseError","type","isResponseLike","isNodeLikeError","error","handleRequest","options","handleResponse","onError","onRequestError","onResponse","handleResponseError","result","once","requestId","pendingRequestId","controller","state","requestAbortPromise","signal","aborted","reject","addEventListener","until","requestListenersPromise","Promise","race","rejectionReason","listenerCount","unhandledExceptionController","then","nextResult"],"sources":["../../src/RequestController.ts","../../src/InterceptorError.ts","../../src/utils/emitAsync.ts","../../src/utils/handleRequest.ts","../../src/utils/isObject.ts","../../src/utils/isPropertyAccessible.ts","../../src/utils/responseUtils.ts","../../src/utils/isNodeLikeError.ts"],"sourcesContent":["import { invariant } from 'outvariant'\nimport { DeferredPromise } from '@open-draft/deferred-promise'\nimport { InterceptorError } from './InterceptorError'\n\nconst kRequestHandled = Symbol('kRequestHandled')\nexport const kResponsePromise = Symbol('kResponsePromise')\n\nexport class RequestController {\n  /**\n   * Internal response promise.\n   * Available only for the library internals to grab the\n   * response instance provided by the developer.\n   * @note This promise cannot be rejected. It's either infinitely\n   * pending or resolved with whichever Response was passed to `respondWith()`.\n   */\n  [kResponsePromise]: DeferredPromise<\n    Response | Record<string, any> | undefined\n  >;\n\n  /**\n   * Internal flag indicating if this request has been handled.\n   * @note The response promise becomes \"fulfilled\" on the next tick.\n   */\n  [kRequestHandled]: boolean\n\n  constructor(private request: Request) {\n    this[kRequestHandled] = false\n    this[kResponsePromise] = new DeferredPromise()\n  }\n\n  /**\n   * Respond to this request with the given `Response` instance.\n   * @example\n   * controller.respondWith(new Response())\n   * controller.respondWith(Response.json({ id }))\n   * controller.respondWith(Response.error())\n   */\n  public respondWith(response: Response): void {\n    invariant.as(\n      InterceptorError,\n      !this[kRequestHandled],\n      'Failed to respond to the \"%s %s\" request: the \"request\" event has already been handled.',\n      this.request.method,\n      this.request.url\n    )\n\n    this[kRequestHandled] = true\n    this[kResponsePromise].resolve(response)\n\n    /**\n     * @note The request controller doesn't do anything\n     * apart from letting the interceptor await the response\n     * provided by the developer through the response promise.\n     * Each interceptor implements the actual respondWith/errorWith\n     * logic based on that interceptor's needs.\n     */\n  }\n\n  /**\n   * Error this request with the given reason.\n   *\n   * @example\n   * controller.errorWith()\n   * controller.errorWith(new Error('Oops!'))\n   * controller.errorWith({ message: 'Oops!'})\n   */\n  public errorWith(reason?: Error | Record<string, any>): void {\n    invariant.as(\n      InterceptorError,\n      !this[kRequestHandled],\n      'Failed to error the \"%s %s\" request: the \"request\" event has already been handled.',\n      this.request.method,\n      this.request.url\n    )\n\n    this[kRequestHandled] = true\n\n    /**\n     * @note Resolve the response promise, not reject.\n     * This helps us differentiate between unhandled exceptions\n     * and intended errors (\"errorWith\") while waiting for the response.\n     */\n    this[kResponsePromise].resolve(reason)\n  }\n}\n","export class InterceptorError extends Error {\n  constructor(message?: string) {\n    super(message)\n    this.name = 'InterceptorError'\n    Object.setPrototypeOf(this, InterceptorError.prototype)\n  }\n}\n","import { Emitter, EventMap } from 'strict-event-emitter'\n\n/**\n * Emits an event on the given emitter but executes\n * the listeners sequentially. This accounts for asynchronous\n * listeners (e.g. those having \"sleep\" and handling the request).\n */\nexport async function emitAsync<\n  Events extends EventMap,\n  EventName extends keyof Events\n>(\n  emitter: Emitter<Events>,\n  eventName: EventName,\n  ...data: Events[EventName]\n): Promise<void> {\n  const listeners = emitter.listeners(eventName)\n\n  if (listeners.length === 0) {\n    return\n  }\n\n  for (const listener of listeners) {\n    await listener.apply(emitter, data)\n  }\n}\n","import type { Emitter } from 'strict-event-emitter'\nimport { DeferredPromise } from '@open-draft/deferred-promise'\nimport { until } from '@open-draft/until'\nimport type { HttpRequestEventMap } from '../glossary'\nimport { emitAsync } from './emitAsync'\nimport { kResponsePromise, RequestController } from '../RequestController'\nimport {\n  createServerErrorResponse,\n  isResponseError,\n  isResponseLike,\n  ResponseError,\n} from './responseUtils'\nimport { InterceptorError } from '../InterceptorError'\nimport { isNodeLikeError } from './isNodeLikeError'\nimport { isObject } from './isObject'\n\ninterface HandleRequestOptions {\n  requestId: string\n  request: Request\n  emitter: Emitter<HttpRequestEventMap>\n  controller: RequestController\n\n  /**\n   * Called when the request has been handled\n   * with the given `Response` instance.\n   */\n  onResponse: (response: Response) => void | Promise<void>\n\n  /**\n   * Called when the request has been handled\n   * with the given `Response.error()` instance.\n   */\n  onRequestError: (response: ResponseError) => void\n\n  /**\n   * Called when an unhandled error happens during the\n   * request handling. This is never a thrown error/response.\n   */\n  onError: (error: unknown) => void\n}\n\n/**\n * @returns {Promise<boolean>} Indicates whether the request has been handled.\n */\nexport async function handleRequest(\n  options: HandleRequestOptions\n): Promise<boolean> {\n  const handleResponse = async (\n    response: Response | Error | Record<string, any>\n  ) => {\n    if (response instanceof Error) {\n      options.onError(response)\n      return true\n    }\n\n    // Handle \"Response.error()\" instances.\n    if (isResponseError(response)) {\n      options.onRequestError(response)\n      return true\n    }\n\n    /**\n     * Handle normal responses or response-like objects.\n     * @note This must come before the arbitrary object check\n     * since Response instances are, in fact, objects.\n     */\n    if (isResponseLike(response)) {\n      await options.onResponse(response)\n      return true\n    }\n\n    // Handle arbitrary objects provided to `.errorWith(reason)`.\n    if (isObject(response)) {\n      options.onError(response)\n      return true\n    }\n\n    return false\n  }\n\n  const handleResponseError = async (error: unknown): Promise<boolean> => {\n    // Forward the special interceptor error instances\n    // to the developer. These must not be handled in any way.\n    if (error instanceof InterceptorError) {\n      throw result.error\n    }\n\n    // Support mocking Node.js-like errors.\n    if (isNodeLikeError(error)) {\n      options.onError(error)\n      return true\n    }\n\n    // Handle thrown responses.\n    if (error instanceof Response) {\n      return await handleResponse(error)\n    }\n\n    return false\n  }\n\n  // Add the last \"request\" listener to check if the request\n  // has been handled in any way. If it hasn't, resolve the\n  // response promise with undefined.\n  options.emitter.once('request', ({ requestId: pendingRequestId }) => {\n    if (pendingRequestId !== options.requestId) {\n      return\n    }\n\n    if (options.controller[kResponsePromise].state === 'pending') {\n      options.controller[kResponsePromise].resolve(undefined)\n    }\n  })\n\n  const requestAbortPromise = new DeferredPromise<void, unknown>()\n\n  /**\n   * @note `signal` is not always defined in React Native.\n   */\n  if (options.request.signal) {\n    if (options.request.signal.aborted) {\n      requestAbortPromise.reject(options.request.signal.reason)\n    } else {\n      options.request.signal.addEventListener(\n        'abort',\n        () => {\n          requestAbortPromise.reject(options.request.signal.reason)\n        },\n        { once: true }\n      )\n    }\n  }\n\n  const result = await until(async () => {\n    // Emit the \"request\" event and wait until all the listeners\n    // for that event are finished (e.g. async listeners awaited).\n    // By the end of this promise, the developer cannot affect the\n    // request anymore.\n    const requestListenersPromise = emitAsync(options.emitter, 'request', {\n      requestId: options.requestId,\n      request: options.request,\n      controller: options.controller,\n    })\n\n    await Promise.race([\n      // Short-circuit the request handling promise if the request gets aborted.\n      requestAbortPromise,\n      requestListenersPromise,\n      options.controller[kResponsePromise],\n    ])\n\n    // The response promise will settle immediately once\n    // the developer calls either \"respondWith\" or \"errorWith\".\n    return await options.controller[kResponsePromise]\n  })\n\n  // Handle the request being aborted while waiting for the request listeners.\n  if (requestAbortPromise.state === 'rejected') {\n    options.onError(requestAbortPromise.rejectionReason)\n    return true\n  }\n\n  if (result.error) {\n    // Handle the error during the request listener execution.\n    // These can be thrown responses or request errors.\n    if (await handleResponseError(result.error)) {\n      return true\n    }\n\n    // If the developer has added \"unhandledException\" listeners,\n    // allow them to handle the error. They can translate it to a\n    // mocked response, network error, or forward it as-is.\n    if (options.emitter.listenerCount('unhandledException') > 0) {\n      // Create a new request controller just for the unhandled exception case.\n      // This is needed because the original controller might have been already\n      // interacted with (e.g. \"respondWith\" or \"errorWith\" called on it).\n      const unhandledExceptionController = new RequestController(\n        options.request\n      )\n\n      await emitAsync(options.emitter, 'unhandledException', {\n        error: result.error,\n        request: options.request,\n        requestId: options.requestId,\n        controller: unhandledExceptionController,\n      }).then(() => {\n        // If all the \"unhandledException\" listeners have finished\n        // but have not handled the response in any way, preemptively\n        // resolve the pending response promise from the new controller.\n        // This prevents it from hanging forever.\n        if (\n          unhandledExceptionController[kResponsePromise].state === 'pending'\n        ) {\n          unhandledExceptionController[kResponsePromise].resolve(undefined)\n        }\n      })\n\n      const nextResult = await until(\n        () => unhandledExceptionController[kResponsePromise]\n      )\n\n      /**\n       * @note Handle the result of the unhandled controller\n       * in the same way as the original request controller.\n       * The exception here is that thrown errors within the\n       * \"unhandledException\" event do NOT result in another\n       * emit of the same event. They are forwarded as-is.\n       */\n      if (nextResult.error) {\n        return handleResponseError(nextResult.error)\n      }\n\n      if (nextResult.data) {\n        return handleResponse(nextResult.data)\n      }\n    }\n\n    // Otherwise, coerce unhandled exceptions to a 500 Internal Server Error response.\n    options.onResponse(createServerErrorResponse(result.error))\n    return true\n  }\n\n  /**\n   * Handle a mocked Response instance.\n   * @note That this can also be an Error in case\n   * the developer called \"errorWith\". This differentiates\n   * unhandled exceptions from intended errors.\n   */\n  if (result.data) {\n    return handleResponse(result.data)\n  }\n\n  // In all other cases, consider the request unhandled.\n  return false\n}\n","/**\n * Determines if a given value is an instance of object.\n */\nexport function isObject<T>(value: any, loose = false): value is T {\n  return loose\n    ? Object.prototype.toString.call(value).startsWith('[object ')\n    : Object.prototype.toString.call(value) === '[object Object]'\n}\n","/**\n * A function that validates if property access is possible on an object\n * without throwing. It returns `true` if the property access is possible\n * and `false` otherwise.\n *\n * Environments like miniflare will throw on property access on certain objects\n * like Request and Response, for unimplemented properties.\n */\nexport function isPropertyAccessible<Obj extends Record<string, any>>(\n  obj: Obj,\n  key: keyof Obj\n) {\n  try {\n    obj[key]\n    return true\n  } catch {\n    return false\n  }\n}\n","import { isObject } from './isObject'\nimport { isPropertyAccessible } from './isPropertyAccessible'\n\n/**\n * Creates a generic 500 Unhandled Exception response.\n */\nexport function createServerErrorResponse(body: unknown): Response {\n  return new Response(\n    JSON.stringify(\n      body instanceof Error\n        ? {\n            name: body.name,\n            message: body.message,\n            stack: body.stack,\n          }\n        : body\n    ),\n    {\n      status: 500,\n      statusText: 'Unhandled Exception',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n    }\n  )\n}\n\nexport type ResponseError = Response & { type: 'error' }\n\n/**\n * Check if the given response is a `Response.error()`.\n *\n * @note Some environments, like Miniflare (Cloudflare) do not\n * implement the \"Response.type\" property and throw on its access.\n * Safely check if we can access \"type\" on \"Response\" before continuing.\n * @see https://github.com/mswjs/msw/issues/1834\n */\nexport function isResponseError(response: unknown): response is ResponseError {\n  return (\n    response != null &&\n    response instanceof Response &&\n    isPropertyAccessible(response, 'type') &&\n    response.type === 'error'\n  )\n}\n\n/**\n * Check if the given value is a `Response` or a Response-like object.\n * This is different from `value instanceof Response` because it supports\n * custom `Response` constructors, like the one when using Undici directly.\n */\nexport function isResponseLike(value: unknown): value is Response {\n  return (\n    isObject<Record<string, any>>(value, true) &&\n    isPropertyAccessible(value, 'status') &&\n    isPropertyAccessible(value, 'statusText') &&\n    isPropertyAccessible(value, 'bodyUsed')\n  )\n}\n","export function isNodeLikeError(\n  error: unknown\n): error is NodeJS.ErrnoException {\n  if (error == null) {\n    return false\n  }\n\n  if (!(error instanceof Error)) {\n    return false\n  }\n\n  return 'code' in error && 'errno' in error\n}\n"],"mappings":"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","ignoreList":[]}