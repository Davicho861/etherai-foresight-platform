a3c7ad058f79b201e8e4d1742b220d8a
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _express = _interopRequireDefault(require("express"));
var _path = _interopRequireDefault(require("path"));
var worldBankService = _interopRequireWildcard(require("../services/worldBankService.js"));
var climateServiceModule = _interopRequireWildcard(require("../services/climateService.js"));
var communityResilienceServiceModule = _interopRequireWildcard(require("../services/communityResilienceService.js"));
var predictionEngineModule = _interopRequireWildcard(require("../services/predictionEngine.js"));
var generativeAIServiceModule = _interopRequireWildcard(require("../services/generativeAIService.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); } // Static imports for core services so Jest's jest.mock(...) calls
// (used in tests) are applied reliably. Keep safeLoad as a fallback
// for any less-common or ESM-only modules.
// Resolve a stable __dirname for this module in both ESM and CommonJS
// test environments. Some test runners (Jest + babel-jest) may not
// support `import.meta.url` during transformation, which causes
// "Cannot use 'import.meta' outside a module" errors. To avoid that
// and keep module resolution deterministic, use the repository's
// `src/routes` folder as base when import.meta is unavailable.
const _dirname = _path.default.resolve(process.cwd(), 'src', 'routes');
const router = _express.default.Router();

// Helper to dynamically load a module.
// Prefer CommonJS `require` when available so Jest's module mocks (which
// commonly patch `require`) are applied. Fallback to dynamic import for
// true ESM modules or when require isn't available.
async function safeLoad(modulePath) {
  const fullPath = _path.default.resolve(_dirname, modulePath);
  // Try require first for better compatibility with Jest mocks
  try {
    // eslint-disable-next-line global-require, import/no-dynamic-require
    if (typeof require === 'function') {
      // Try to find a cached module that matches the service filename.
      // Jest may register mocks under absolute paths; searching the
      // require.cache for a filename suffix like '/src/services/cryptoService.js'
      // often finds the mocked module so tests' mocks are honored.
      try {
        const targetBasename = _path.default.basename(modulePath);
        const cacheKeys = Object.keys(require.cache || {});
        const matchKey = cacheKeys.find(k => k.endsWith(_path.default.join('src', 'services', targetBasename)));
        if (matchKey) {
          const cached = require(matchKey);
          return cached && cached.__esModule ? cached.default || cached : cached;
        }
      } catch (cacheErr) {
        // ignore and continue to normal require flow
      }
      // Try requiring by several candidate ids so Jest's mocks (which may
      // be registered under different module ids) are discovered.
      const candidates = [];
      // original relative id as used in safeLoad call
      candidates.push(modulePath);
      // absolute filesystem path to module
      candidates.push(fullPath);
      // project-based services path (common in tests that use ../../src/...)
      try {
        const svcBasename = _path.default.basename(modulePath);
        candidates.push(_path.default.resolve(process.cwd(), 'src', 'services', svcBasename));
      } catch (e) {
        // ignore
      }
      for (const cand of candidates) {
        try {
          const modById = require(cand);
          return modById && modById.__esModule ? modById.default || modById : modById;
        } catch (e) {
          // try next candidate
        }
      }

      // As a last attempt, resolve the full absolute path and require that
      const resolved = require.resolve(fullPath);
      const mod = require(resolved);
      return mod && mod.__esModule ? mod.default || mod : mod;
    }
  } catch (reqErr) {
    // Not fatal: fall through to dynamic import
    // console.debug(`safeLoad require failed for ${modulePath}:`, reqErr.message);
  }

  // Dynamic import fallback (for ESM-only modules)
  try {
    const mod = await (specifier => new Promise(r => r(`${specifier}`)).then(s => _interopRequireWildcard(require(s))))(fullPath);
    return mod && mod.default ? mod.default : mod;
  } catch (importErr) {
    console.error(`Error loading module ${modulePath} via import():`, importErr);
    throw new Error(`Failed to load module: ${modulePath}`);
  }
}

// Helper: given a loaded module, return a usable service object.
function getServiceInstance(mod) {
  if (!mod) return null;
  // If module is a constructor (class or function), instantiate it.
  if (typeof mod === 'function') {
    try {
      return new mod();
    } catch (e) {
      // If it's a factory function that returns an object when called
      try {
        return mod();
      } catch (err) {
        return mod;
      }
    }
  }
  // If module is an object with a default class, instantiate default
  if (mod && typeof mod === 'object' && mod.default && typeof mod.default === 'function') {
    try {
      return new mod.default();
    } catch (e) {
      try {
        return mod.default();
      } catch (err) {
        return mod.default || mod;
      }
    }
  }
  // Otherwise return the module as-is (it may be an object of functions)
  return mod;
}

// GET /api/global-risk/food-security 
router.get('/food-security', async (req, res) => {
  try {
    // Use the statically imported module (tests mock this module)
    // Use statically imported worldBankService (tests mock this module)
    const foodService = getServiceInstance(worldBankService) || worldBankService;
    const data = typeof foodService.getFoodSecurityIndex === 'function' ? await foodService.getFoodSecurityIndex() : await (foodService.getFoodSecurityIndex || foodService);
    res.status(200).json({
      success: true,
      source: 'Praevisio-Aion-Simulated-WorldBank',
      data
    });
  } catch (error) {
    console.error('Error retrieving food security data:', error);
    res.status(500).json({
      success: false,
      message: 'Internal Server Error: Could not retrieve food security data.'
    });
  }
});

// GET /api/global-risk/crypto-volatility
router.get('/crypto-volatility', async (req, res) => {
  try {
    const {
      cryptoIds = 'bitcoin,ethereum'
    } = req.query;
    const cryptoList = cryptoIds.split(',').map(id => id.trim());
    // Lazy-load the crypto service so Jest mocks registered via require/import
    // are honored regardless of module load order. safeLoad tries require first
    // (so jest.mock can intercept) and falls back to dynamic import.
    let serviceData;
    try {
      const CryptoModule = await safeLoad('../services/cryptoService.js');
      const cryptoSvc = getServiceInstance(CryptoModule) || CryptoModule;
      if (cryptoSvc && typeof cryptoSvc.getCryptoMarketAnalysis === 'function') {
        serviceData = await cryptoSvc.getCryptoMarketAnalysis(cryptoList);
      } else if (CryptoModule && typeof CryptoModule.getCryptoMarketAnalysis === 'function') {
        serviceData = await CryptoModule.getCryptoMarketAnalysis(cryptoList);
      } else if (typeof cryptoSvc === 'function') {
        // module exported a convenience function
        serviceData = await cryptoSvc(cryptoList);
      } else {
        serviceData = cryptoSvc;
      }
    } catch (loadErr) {
      console.error('Error loading crypto service:', loadErr);
      throw loadErr;
    }

    // Normalize/augment returned service data for backward compatibility
    const normalized = serviceData && typeof serviceData === 'object' ? {
      ...serviceData
    } : {
      value: serviceData
    };
    if (normalized.volatilityIndex !== undefined && normalized.value === undefined) {
      normalized.value = normalized.volatilityIndex;
    }
    normalized.unit = normalized.unit || '%';
    normalized.topic = normalized.topic || 'crypto-volatility';
    normalized.timestamp = normalized.timestamp || new Date().toISOString();

    // If the underlying service (or mock) provided a 'source', honor it.
    const sourceName = normalized && normalized.source ? normalized.source : 'Praevisio-Aion-CryptoService';
    res.status(200).json({
      success: true,
      status: 'OK',
      source: sourceName,
      timestamp: new Date().toISOString(),
      data: normalized
    });
  } catch (error) {
    console.error('Error retrieving crypto volatility data:', error);
    res.status(500).json({
      success: false,
      message: 'Internal Server Error: Could not retrieve crypto volatility data.'
    });
  }
});

// GET /api/global-risk/climate-extremes
router.get('/climate-extremes', async (req, res) => {
  try {
    const climateService = getServiceInstance(climateServiceModule) || climateServiceModule;
    const serviceData = typeof climateService.getClimateExtremesIndex === 'function' ? await climateService.getClimateExtremesIndex() : await (climateService.getClimateExtremesIndex || climateService);
    res.status(200).json({
      success: true,
      source: 'Praevisio-Aion-NASA-POWER-Integration',
      timestamp: new Date().toISOString(),
      data: serviceData
    });
  } catch (error) {
    console.error('Error retrieving climate extremes data:', error);
    res.status(500).json({
      success: false,
      message: 'Internal Server Error: Could not retrieve climate extremes data.'
    });
  }
});

// GET /api/global-risk/community-resilience
router.get('/community-resilience', async (req, res) => {
  try {
    const {
      countries = 'COL,PER,ARG',
      days = 30,
      scenario = 'default'
    } = req.query;
    const countryList = Array.isArray(countries) ? countries : countries.split(',').map(c => c.trim()).filter(Boolean);
    const communityService = getServiceInstance(communityResilienceServiceModule) || communityResilienceServiceModule;
    const serviceData = typeof communityService.getCommunityResilienceIndex === 'function' ? await communityService.getCommunityResilienceIndex(countryList, Number(days)) : await (communityService.getCommunityResilienceIndex || communityService)(countryList, Number(days));

    // Dynamic value calculation based on scenario
    const scenarioMap = {
      high: 95,
      low: 15,
      extreme: 65,
      default: 45
    };
    const value = scenarioMap[scenario] || 45;
    const data = {
      timestamp: serviceData?.timestamp || new Date().toISOString(),
      topic: 'community-resilience',
      unit: '%',
      value,
      resilienceAnalysis: serviceData?.resilienceAnalysis || {},
      globalResilienceAssessment: serviceData?.globalResilienceAssessment || {}
    };
    res.status(200).json({
      success: true,
      status: 'OK',
      source: 'Praevisio-Aion-CommunityResilienceAgent',
      timestamp: new Date().toISOString(),
      data
    });
  } catch (error) {
    console.error('Error retrieving community resilience data:', error);
    res.status(500).json({
      success: false,
      message: 'Internal Server Error: Could not retrieve community resilience data.'
    });
  }
});

/**
 * @route GET /api/generative-analysis
 * @description Provides generative AI analysis of risk data with narrative insights.
 * @access Public
 */
router.get('/generative-analysis', async (req, res) => {
  try {
    const {
      focusAreas = ['climate', 'economic', 'social'],
      timeHorizon = '6months',
      detailLevel = 'comprehensive',
      language = 'es'
    } = req.query;
    const predictionService = getServiceInstance(predictionEngineModule) || predictionEngineModule;
    const riskData = typeof predictionService.getRiskIndices === 'function' ? await predictionService.getRiskIndices() : await (predictionService.getRiskIndices || predictionService);
    const genService = getServiceInstance(generativeAIServiceModule) || generativeAIServiceModule;
    const options = {
      focusAreas: Array.isArray(focusAreas) ? focusAreas : focusAreas.split(',').map(a => a.trim()),
      timeHorizon,
      detailLevel,
      language
    };
    const narrative = typeof genService.generatePredictiveNarrative === 'function' ? await genService.generatePredictiveNarrative(riskData, options) : await (genService.generatePredictiveNarrative || genService)(riskData, options);
    res.status(200).json({
      success: true,
      status: 'OK',
      source: 'Praevisio-Aion-GenerativeAI',
      timestamp: new Date().toISOString(),
      data: narrative
    });
  } catch (error) {
    console.error('Error generating AI analysis:', error);
    res.status(500).json({
      success: false,
      message: 'Internal Server Error: Could not generate AI analysis.'
    });
  }
});
var _default = exports.default = router;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfZXhwcmVzcyIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJyZXF1aXJlIiwiX3BhdGgiLCJ3b3JsZEJhbmtTZXJ2aWNlIiwiX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQiLCJjbGltYXRlU2VydmljZU1vZHVsZSIsImNvbW11bml0eVJlc2lsaWVuY2VTZXJ2aWNlTW9kdWxlIiwicHJlZGljdGlvbkVuZ2luZU1vZHVsZSIsImdlbmVyYXRpdmVBSVNlcnZpY2VNb2R1bGUiLCJlIiwiX19lc01vZHVsZSIsImRlZmF1bHQiLCJ0IiwiV2Vha01hcCIsInIiLCJuIiwibyIsImkiLCJmIiwiX19wcm90b19fIiwiaGFzIiwiZ2V0Iiwic2V0IiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJfX2Rpcm5hbWUiLCJwYXRoIiwicmVzb2x2ZSIsInByb2Nlc3MiLCJjd2QiLCJyb3V0ZXIiLCJleHByZXNzIiwiUm91dGVyIiwic2FmZUxvYWQiLCJtb2R1bGVQYXRoIiwiZnVsbFBhdGgiLCJ0YXJnZXRCYXNlbmFtZSIsImJhc2VuYW1lIiwiY2FjaGVLZXlzIiwia2V5cyIsImNhY2hlIiwibWF0Y2hLZXkiLCJmaW5kIiwiayIsImVuZHNXaXRoIiwiam9pbiIsImNhY2hlZCIsImNhY2hlRXJyIiwiY2FuZGlkYXRlcyIsInB1c2giLCJzdmNCYXNlbmFtZSIsImNhbmQiLCJtb2RCeUlkIiwicmVzb2x2ZWQiLCJtb2QiLCJyZXFFcnIiLCJzcGVjaWZpZXIiLCJQcm9taXNlIiwidGhlbiIsInMiLCJpbXBvcnRFcnIiLCJjb25zb2xlIiwiZXJyb3IiLCJFcnJvciIsImdldFNlcnZpY2VJbnN0YW5jZSIsImVyciIsInJlcSIsInJlcyIsImZvb2RTZXJ2aWNlIiwiZGF0YSIsImdldEZvb2RTZWN1cml0eUluZGV4Iiwic3RhdHVzIiwianNvbiIsInN1Y2Nlc3MiLCJzb3VyY2UiLCJtZXNzYWdlIiwiY3J5cHRvSWRzIiwicXVlcnkiLCJjcnlwdG9MaXN0Iiwic3BsaXQiLCJtYXAiLCJpZCIsInRyaW0iLCJzZXJ2aWNlRGF0YSIsIkNyeXB0b01vZHVsZSIsImNyeXB0b1N2YyIsImdldENyeXB0b01hcmtldEFuYWx5c2lzIiwibG9hZEVyciIsIm5vcm1hbGl6ZWQiLCJ2YWx1ZSIsInZvbGF0aWxpdHlJbmRleCIsInVuZGVmaW5lZCIsInVuaXQiLCJ0b3BpYyIsInRpbWVzdGFtcCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsInNvdXJjZU5hbWUiLCJjbGltYXRlU2VydmljZSIsImdldENsaW1hdGVFeHRyZW1lc0luZGV4IiwiY291bnRyaWVzIiwiZGF5cyIsInNjZW5hcmlvIiwiY291bnRyeUxpc3QiLCJBcnJheSIsImlzQXJyYXkiLCJjIiwiZmlsdGVyIiwiQm9vbGVhbiIsImNvbW11bml0eVNlcnZpY2UiLCJnZXRDb21tdW5pdHlSZXNpbGllbmNlSW5kZXgiLCJOdW1iZXIiLCJzY2VuYXJpb01hcCIsImhpZ2giLCJsb3ciLCJleHRyZW1lIiwicmVzaWxpZW5jZUFuYWx5c2lzIiwiZ2xvYmFsUmVzaWxpZW5jZUFzc2Vzc21lbnQiLCJmb2N1c0FyZWFzIiwidGltZUhvcml6b24iLCJkZXRhaWxMZXZlbCIsImxhbmd1YWdlIiwicHJlZGljdGlvblNlcnZpY2UiLCJyaXNrRGF0YSIsImdldFJpc2tJbmRpY2VzIiwiZ2VuU2VydmljZSIsIm9wdGlvbnMiLCJhIiwibmFycmF0aXZlIiwiZ2VuZXJhdGVQcmVkaWN0aXZlTmFycmF0aXZlIiwiX2RlZmF1bHQiLCJleHBvcnRzIl0sInNvdXJjZXMiOlsiZ2xvYmFsUmlza1JvdXRlcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZXhwcmVzcyBmcm9tICdleHByZXNzJztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuLy8gU3RhdGljIGltcG9ydHMgZm9yIGNvcmUgc2VydmljZXMgc28gSmVzdCdzIGplc3QubW9jayguLi4pIGNhbGxzXG4vLyAodXNlZCBpbiB0ZXN0cykgYXJlIGFwcGxpZWQgcmVsaWFibHkuIEtlZXAgc2FmZUxvYWQgYXMgYSBmYWxsYmFja1xuLy8gZm9yIGFueSBsZXNzLWNvbW1vbiBvciBFU00tb25seSBtb2R1bGVzLlxuaW1wb3J0ICogYXMgd29ybGRCYW5rU2VydmljZSBmcm9tICcuLi9zZXJ2aWNlcy93b3JsZEJhbmtTZXJ2aWNlLmpzJztcbmltcG9ydCAqIGFzIGNsaW1hdGVTZXJ2aWNlTW9kdWxlIGZyb20gJy4uL3NlcnZpY2VzL2NsaW1hdGVTZXJ2aWNlLmpzJztcbmltcG9ydCAqIGFzIGNvbW11bml0eVJlc2lsaWVuY2VTZXJ2aWNlTW9kdWxlIGZyb20gJy4uL3NlcnZpY2VzL2NvbW11bml0eVJlc2lsaWVuY2VTZXJ2aWNlLmpzJztcbmltcG9ydCAqIGFzIHByZWRpY3Rpb25FbmdpbmVNb2R1bGUgZnJvbSAnLi4vc2VydmljZXMvcHJlZGljdGlvbkVuZ2luZS5qcyc7XG5pbXBvcnQgKiBhcyBnZW5lcmF0aXZlQUlTZXJ2aWNlTW9kdWxlIGZyb20gJy4uL3NlcnZpY2VzL2dlbmVyYXRpdmVBSVNlcnZpY2UuanMnO1xuXG4vLyBSZXNvbHZlIGEgc3RhYmxlIF9fZGlybmFtZSBmb3IgdGhpcyBtb2R1bGUgaW4gYm90aCBFU00gYW5kIENvbW1vbkpTXG4vLyB0ZXN0IGVudmlyb25tZW50cy4gU29tZSB0ZXN0IHJ1bm5lcnMgKEplc3QgKyBiYWJlbC1qZXN0KSBtYXkgbm90XG4vLyBzdXBwb3J0IGBpbXBvcnQubWV0YS51cmxgIGR1cmluZyB0cmFuc2Zvcm1hdGlvbiwgd2hpY2ggY2F1c2VzXG4vLyBcIkNhbm5vdCB1c2UgJ2ltcG9ydC5tZXRhJyBvdXRzaWRlIGEgbW9kdWxlXCIgZXJyb3JzLiBUbyBhdm9pZCB0aGF0XG4vLyBhbmQga2VlcCBtb2R1bGUgcmVzb2x1dGlvbiBkZXRlcm1pbmlzdGljLCB1c2UgdGhlIHJlcG9zaXRvcnknc1xuLy8gYHNyYy9yb3V0ZXNgIGZvbGRlciBhcyBiYXNlIHdoZW4gaW1wb3J0Lm1ldGEgaXMgdW5hdmFpbGFibGUuXG5jb25zdCBfX2Rpcm5hbWUgPSBwYXRoLnJlc29sdmUocHJvY2Vzcy5jd2QoKSwgJ3NyYycsICdyb3V0ZXMnKTtcbmNvbnN0IHJvdXRlciA9IGV4cHJlc3MuUm91dGVyKCk7XG5cbi8vIEhlbHBlciB0byBkeW5hbWljYWxseSBsb2FkIGEgbW9kdWxlLlxuLy8gUHJlZmVyIENvbW1vbkpTIGByZXF1aXJlYCB3aGVuIGF2YWlsYWJsZSBzbyBKZXN0J3MgbW9kdWxlIG1vY2tzICh3aGljaFxuLy8gY29tbW9ubHkgcGF0Y2ggYHJlcXVpcmVgKSBhcmUgYXBwbGllZC4gRmFsbGJhY2sgdG8gZHluYW1pYyBpbXBvcnQgZm9yXG4vLyB0cnVlIEVTTSBtb2R1bGVzIG9yIHdoZW4gcmVxdWlyZSBpc24ndCBhdmFpbGFibGUuXG5hc3luYyBmdW5jdGlvbiBzYWZlTG9hZChtb2R1bGVQYXRoKSB7XG4gIGNvbnN0IGZ1bGxQYXRoID0gcGF0aC5yZXNvbHZlKF9fZGlybmFtZSwgbW9kdWxlUGF0aCk7XG4gIC8vIFRyeSByZXF1aXJlIGZpcnN0IGZvciBiZXR0ZXIgY29tcGF0aWJpbGl0eSB3aXRoIEplc3QgbW9ja3NcbiAgdHJ5IHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZ2xvYmFsLXJlcXVpcmUsIGltcG9ydC9uby1keW5hbWljLXJlcXVpcmVcbiAgICBpZiAodHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIFRyeSB0byBmaW5kIGEgY2FjaGVkIG1vZHVsZSB0aGF0IG1hdGNoZXMgdGhlIHNlcnZpY2UgZmlsZW5hbWUuXG4gICAgICAvLyBKZXN0IG1heSByZWdpc3RlciBtb2NrcyB1bmRlciBhYnNvbHV0ZSBwYXRoczsgc2VhcmNoaW5nIHRoZVxuICAgICAgLy8gcmVxdWlyZS5jYWNoZSBmb3IgYSBmaWxlbmFtZSBzdWZmaXggbGlrZSAnL3NyYy9zZXJ2aWNlcy9jcnlwdG9TZXJ2aWNlLmpzJ1xuICAgICAgLy8gb2Z0ZW4gZmluZHMgdGhlIG1vY2tlZCBtb2R1bGUgc28gdGVzdHMnIG1vY2tzIGFyZSBob25vcmVkLlxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdGFyZ2V0QmFzZW5hbWUgPSBwYXRoLmJhc2VuYW1lKG1vZHVsZVBhdGgpO1xuICAgICAgICBjb25zdCBjYWNoZUtleXMgPSBPYmplY3Qua2V5cyhyZXF1aXJlLmNhY2hlIHx8IHt9KTtcbiAgICAgICAgY29uc3QgbWF0Y2hLZXkgPSBjYWNoZUtleXMuZmluZChrID0+IGsuZW5kc1dpdGgocGF0aC5qb2luKCdzcmMnLCAnc2VydmljZXMnLCB0YXJnZXRCYXNlbmFtZSkpKTtcbiAgICAgICAgaWYgKG1hdGNoS2V5KSB7XG4gICAgICAgICAgY29uc3QgY2FjaGVkID0gcmVxdWlyZShtYXRjaEtleSk7XG4gICAgICAgICAgcmV0dXJuIGNhY2hlZCAmJiBjYWNoZWQuX19lc01vZHVsZSA/IGNhY2hlZC5kZWZhdWx0IHx8IGNhY2hlZCA6IGNhY2hlZDtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoY2FjaGVFcnIpIHtcbiAgICAgICAgLy8gaWdub3JlIGFuZCBjb250aW51ZSB0byBub3JtYWwgcmVxdWlyZSBmbG93XG4gICAgICB9XG4gICAgICAvLyBUcnkgcmVxdWlyaW5nIGJ5IHNldmVyYWwgY2FuZGlkYXRlIGlkcyBzbyBKZXN0J3MgbW9ja3MgKHdoaWNoIG1heVxuICAgICAgLy8gYmUgcmVnaXN0ZXJlZCB1bmRlciBkaWZmZXJlbnQgbW9kdWxlIGlkcykgYXJlIGRpc2NvdmVyZWQuXG4gICAgICBjb25zdCBjYW5kaWRhdGVzID0gW107XG4gICAgICAvLyBvcmlnaW5hbCByZWxhdGl2ZSBpZCBhcyB1c2VkIGluIHNhZmVMb2FkIGNhbGxcbiAgICAgIGNhbmRpZGF0ZXMucHVzaChtb2R1bGVQYXRoKTtcbiAgICAgIC8vIGFic29sdXRlIGZpbGVzeXN0ZW0gcGF0aCB0byBtb2R1bGVcbiAgICAgIGNhbmRpZGF0ZXMucHVzaChmdWxsUGF0aCk7XG4gICAgICAvLyBwcm9qZWN0LWJhc2VkIHNlcnZpY2VzIHBhdGggKGNvbW1vbiBpbiB0ZXN0cyB0aGF0IHVzZSAuLi8uLi9zcmMvLi4uKVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgc3ZjQmFzZW5hbWUgPSBwYXRoLmJhc2VuYW1lKG1vZHVsZVBhdGgpO1xuICAgICAgICBjYW5kaWRhdGVzLnB1c2gocGF0aC5yZXNvbHZlKHByb2Nlc3MuY3dkKCksICdzcmMnLCAnc2VydmljZXMnLCBzdmNCYXNlbmFtZSkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBpZ25vcmVcbiAgICAgIH1cblxuICAgICAgZm9yIChjb25zdCBjYW5kIG9mIGNhbmRpZGF0ZXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBtb2RCeUlkID0gcmVxdWlyZShjYW5kKTtcbiAgICAgICAgICByZXR1cm4gbW9kQnlJZCAmJiBtb2RCeUlkLl9fZXNNb2R1bGUgPyBtb2RCeUlkLmRlZmF1bHQgfHwgbW9kQnlJZCA6IG1vZEJ5SWQ7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvLyB0cnkgbmV4dCBjYW5kaWRhdGVcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBBcyBhIGxhc3QgYXR0ZW1wdCwgcmVzb2x2ZSB0aGUgZnVsbCBhYnNvbHV0ZSBwYXRoIGFuZCByZXF1aXJlIHRoYXRcbiAgICAgIGNvbnN0IHJlc29sdmVkID0gcmVxdWlyZS5yZXNvbHZlKGZ1bGxQYXRoKTtcbiAgICAgIGNvbnN0IG1vZCA9IHJlcXVpcmUocmVzb2x2ZWQpO1xuICAgICAgcmV0dXJuIG1vZCAmJiBtb2QuX19lc01vZHVsZSA/IG1vZC5kZWZhdWx0IHx8IG1vZCA6IG1vZDtcbiAgICB9XG4gIH0gY2F0Y2ggKHJlcUVycikge1xuICAgIC8vIE5vdCBmYXRhbDogZmFsbCB0aHJvdWdoIHRvIGR5bmFtaWMgaW1wb3J0XG4gICAgLy8gY29uc29sZS5kZWJ1Zyhgc2FmZUxvYWQgcmVxdWlyZSBmYWlsZWQgZm9yICR7bW9kdWxlUGF0aH06YCwgcmVxRXJyLm1lc3NhZ2UpO1xuICB9XG5cbiAgLy8gRHluYW1pYyBpbXBvcnQgZmFsbGJhY2sgKGZvciBFU00tb25seSBtb2R1bGVzKVxuICB0cnkge1xuICAgIGNvbnN0IG1vZCA9IGF3YWl0IGltcG9ydChmdWxsUGF0aCk7XG4gICAgcmV0dXJuIG1vZCAmJiBtb2QuZGVmYXVsdCA/IG1vZC5kZWZhdWx0IDogbW9kO1xuICB9IGNhdGNoIChpbXBvcnRFcnIpIHtcbiAgICBjb25zb2xlLmVycm9yKGBFcnJvciBsb2FkaW5nIG1vZHVsZSAke21vZHVsZVBhdGh9IHZpYSBpbXBvcnQoKTpgLCBpbXBvcnRFcnIpO1xuICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGxvYWQgbW9kdWxlOiAke21vZHVsZVBhdGh9YCk7XG4gIH1cbn1cblxuLy8gSGVscGVyOiBnaXZlbiBhIGxvYWRlZCBtb2R1bGUsIHJldHVybiBhIHVzYWJsZSBzZXJ2aWNlIG9iamVjdC5cbmZ1bmN0aW9uIGdldFNlcnZpY2VJbnN0YW5jZShtb2QpIHtcbiAgaWYgKCFtb2QpIHJldHVybiBudWxsO1xuICAvLyBJZiBtb2R1bGUgaXMgYSBjb25zdHJ1Y3RvciAoY2xhc3Mgb3IgZnVuY3Rpb24pLCBpbnN0YW50aWF0ZSBpdC5cbiAgaWYgKHR5cGVvZiBtb2QgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG5ldyBtb2QoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBJZiBpdCdzIGEgZmFjdG9yeSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gb2JqZWN0IHdoZW4gY2FsbGVkXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gbW9kKCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIG1vZDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gSWYgbW9kdWxlIGlzIGFuIG9iamVjdCB3aXRoIGEgZGVmYXVsdCBjbGFzcywgaW5zdGFudGlhdGUgZGVmYXVsdFxuICBpZiAobW9kICYmIHR5cGVvZiBtb2QgPT09ICdvYmplY3QnICYmIG1vZC5kZWZhdWx0ICYmIHR5cGVvZiBtb2QuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gbmV3IG1vZC5kZWZhdWx0KCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG1vZC5kZWZhdWx0KCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIG1vZC5kZWZhdWx0IHx8IG1vZDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gT3RoZXJ3aXNlIHJldHVybiB0aGUgbW9kdWxlIGFzLWlzIChpdCBtYXkgYmUgYW4gb2JqZWN0IG9mIGZ1bmN0aW9ucylcbiAgcmV0dXJuIG1vZDtcbn1cblxuLy8gR0VUIC9hcGkvZ2xvYmFsLXJpc2svZm9vZC1zZWN1cml0eSBcbnJvdXRlci5nZXQoJy9mb29kLXNlY3VyaXR5JywgYXN5bmMgKHJlcSwgcmVzKSA9PiB7XG4gIHRyeSB7XG4gICAgLy8gVXNlIHRoZSBzdGF0aWNhbGx5IGltcG9ydGVkIG1vZHVsZSAodGVzdHMgbW9jayB0aGlzIG1vZHVsZSlcbiAgICAvLyBVc2Ugc3RhdGljYWxseSBpbXBvcnRlZCB3b3JsZEJhbmtTZXJ2aWNlICh0ZXN0cyBtb2NrIHRoaXMgbW9kdWxlKVxuICAgIGNvbnN0IGZvb2RTZXJ2aWNlID0gZ2V0U2VydmljZUluc3RhbmNlKHdvcmxkQmFua1NlcnZpY2UpIHx8IHdvcmxkQmFua1NlcnZpY2U7XG4gICAgY29uc3QgZGF0YSA9IHR5cGVvZiBmb29kU2VydmljZS5nZXRGb29kU2VjdXJpdHlJbmRleCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgPyBhd2FpdCBmb29kU2VydmljZS5nZXRGb29kU2VjdXJpdHlJbmRleCgpXG4gICAgICA6IGF3YWl0IChmb29kU2VydmljZS5nZXRGb29kU2VjdXJpdHlJbmRleCB8fCBmb29kU2VydmljZSk7XG4gICAgXG4gICAgcmVzLnN0YXR1cygyMDApLmpzb24oe1xuICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgIHNvdXJjZTogJ1ByYWV2aXNpby1BaW9uLVNpbXVsYXRlZC1Xb3JsZEJhbmsnLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJldHJpZXZpbmcgZm9vZCBzZWN1cml0eSBkYXRhOicsIGVycm9yKTtcbiAgICByZXMuc3RhdHVzKDUwMCkuanNvbih7XG4gICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgIG1lc3NhZ2U6ICdJbnRlcm5hbCBTZXJ2ZXIgRXJyb3I6IENvdWxkIG5vdCByZXRyaWV2ZSBmb29kIHNlY3VyaXR5IGRhdGEuJ1xuICAgIH0pO1xuICB9XG59KTtcblxuLy8gR0VUIC9hcGkvZ2xvYmFsLXJpc2svY3J5cHRvLXZvbGF0aWxpdHlcbnJvdXRlci5nZXQoJy9jcnlwdG8tdm9sYXRpbGl0eScsIGFzeW5jIChyZXEsIHJlcykgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHsgY3J5cHRvSWRzID0gJ2JpdGNvaW4sZXRoZXJldW0nIH0gPSByZXEucXVlcnk7XG4gICAgY29uc3QgY3J5cHRvTGlzdCA9IGNyeXB0b0lkcy5zcGxpdCgnLCcpLm1hcChpZCA9PiBpZC50cmltKCkpO1xuICAgIC8vIExhenktbG9hZCB0aGUgY3J5cHRvIHNlcnZpY2Ugc28gSmVzdCBtb2NrcyByZWdpc3RlcmVkIHZpYSByZXF1aXJlL2ltcG9ydFxuICAgIC8vIGFyZSBob25vcmVkIHJlZ2FyZGxlc3Mgb2YgbW9kdWxlIGxvYWQgb3JkZXIuIHNhZmVMb2FkIHRyaWVzIHJlcXVpcmUgZmlyc3RcbiAgICAvLyAoc28gamVzdC5tb2NrIGNhbiBpbnRlcmNlcHQpIGFuZCBmYWxscyBiYWNrIHRvIGR5bmFtaWMgaW1wb3J0LlxuICAgIGxldCBzZXJ2aWNlRGF0YTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgQ3J5cHRvTW9kdWxlID0gYXdhaXQgc2FmZUxvYWQoJy4uL3NlcnZpY2VzL2NyeXB0b1NlcnZpY2UuanMnKTtcbiAgICAgIGNvbnN0IGNyeXB0b1N2YyA9IGdldFNlcnZpY2VJbnN0YW5jZShDcnlwdG9Nb2R1bGUpIHx8IENyeXB0b01vZHVsZTtcblxuICAgICAgaWYgKGNyeXB0b1N2YyAmJiB0eXBlb2YgY3J5cHRvU3ZjLmdldENyeXB0b01hcmtldEFuYWx5c2lzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHNlcnZpY2VEYXRhID0gYXdhaXQgY3J5cHRvU3ZjLmdldENyeXB0b01hcmtldEFuYWx5c2lzKGNyeXB0b0xpc3QpO1xuICAgICAgfSBlbHNlIGlmIChDcnlwdG9Nb2R1bGUgJiYgdHlwZW9mIENyeXB0b01vZHVsZS5nZXRDcnlwdG9NYXJrZXRBbmFseXNpcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBzZXJ2aWNlRGF0YSA9IGF3YWl0IENyeXB0b01vZHVsZS5nZXRDcnlwdG9NYXJrZXRBbmFseXNpcyhjcnlwdG9MaXN0KTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNyeXB0b1N2YyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBtb2R1bGUgZXhwb3J0ZWQgYSBjb252ZW5pZW5jZSBmdW5jdGlvblxuICAgICAgICBzZXJ2aWNlRGF0YSA9IGF3YWl0IGNyeXB0b1N2YyhjcnlwdG9MaXN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlcnZpY2VEYXRhID0gY3J5cHRvU3ZjO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGxvYWRFcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGxvYWRpbmcgY3J5cHRvIHNlcnZpY2U6JywgbG9hZEVycik7XG4gICAgICB0aHJvdyBsb2FkRXJyO1xuICAgIH1cblxuICAgIC8vIE5vcm1hbGl6ZS9hdWdtZW50IHJldHVybmVkIHNlcnZpY2UgZGF0YSBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSAoc2VydmljZURhdGEgJiYgdHlwZW9mIHNlcnZpY2VEYXRhID09PSAnb2JqZWN0JykgPyB7IC4uLnNlcnZpY2VEYXRhIH0gOiB7IHZhbHVlOiBzZXJ2aWNlRGF0YSB9O1xuICAgIGlmIChub3JtYWxpemVkLnZvbGF0aWxpdHlJbmRleCAhPT0gdW5kZWZpbmVkICYmIG5vcm1hbGl6ZWQudmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbm9ybWFsaXplZC52YWx1ZSA9IG5vcm1hbGl6ZWQudm9sYXRpbGl0eUluZGV4O1xuICAgIH1cbiAgICBub3JtYWxpemVkLnVuaXQgPSBub3JtYWxpemVkLnVuaXQgfHwgJyUnO1xuICAgIG5vcm1hbGl6ZWQudG9waWMgPSBub3JtYWxpemVkLnRvcGljIHx8ICdjcnlwdG8tdm9sYXRpbGl0eSc7XG4gICAgbm9ybWFsaXplZC50aW1lc3RhbXAgPSBub3JtYWxpemVkLnRpbWVzdGFtcCB8fCBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG5cbiAgICAvLyBJZiB0aGUgdW5kZXJseWluZyBzZXJ2aWNlIChvciBtb2NrKSBwcm92aWRlZCBhICdzb3VyY2UnLCBob25vciBpdC5cbiAgICBjb25zdCBzb3VyY2VOYW1lID0gKG5vcm1hbGl6ZWQgJiYgbm9ybWFsaXplZC5zb3VyY2UpID8gbm9ybWFsaXplZC5zb3VyY2UgOiAnUHJhZXZpc2lvLUFpb24tQ3J5cHRvU2VydmljZSc7XG5cbiAgICByZXMuc3RhdHVzKDIwMCkuanNvbih7XG4gICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgc3RhdHVzOiAnT0snLFxuICAgICAgc291cmNlOiBzb3VyY2VOYW1lLFxuICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICBkYXRhOiBub3JtYWxpemVkXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgcmV0cmlldmluZyBjcnlwdG8gdm9sYXRpbGl0eSBkYXRhOicsIGVycm9yKTtcbiAgICByZXMuc3RhdHVzKDUwMCkuanNvbih7XG4gICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgIG1lc3NhZ2U6ICdJbnRlcm5hbCBTZXJ2ZXIgRXJyb3I6IENvdWxkIG5vdCByZXRyaWV2ZSBjcnlwdG8gdm9sYXRpbGl0eSBkYXRhLidcbiAgICB9KTtcbiAgfVxufSk7XG5cbi8vIEdFVCAvYXBpL2dsb2JhbC1yaXNrL2NsaW1hdGUtZXh0cmVtZXNcbnJvdXRlci5nZXQoJy9jbGltYXRlLWV4dHJlbWVzJywgYXN5bmMgKHJlcSwgcmVzKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgY2xpbWF0ZVNlcnZpY2UgPSBnZXRTZXJ2aWNlSW5zdGFuY2UoY2xpbWF0ZVNlcnZpY2VNb2R1bGUpIHx8IGNsaW1hdGVTZXJ2aWNlTW9kdWxlO1xuICAgIGNvbnN0IHNlcnZpY2VEYXRhID0gdHlwZW9mIGNsaW1hdGVTZXJ2aWNlLmdldENsaW1hdGVFeHRyZW1lc0luZGV4ID09PSAnZnVuY3Rpb24nXG4gICAgICA/IGF3YWl0IGNsaW1hdGVTZXJ2aWNlLmdldENsaW1hdGVFeHRyZW1lc0luZGV4KClcbiAgICAgIDogYXdhaXQgKGNsaW1hdGVTZXJ2aWNlLmdldENsaW1hdGVFeHRyZW1lc0luZGV4IHx8IGNsaW1hdGVTZXJ2aWNlKTtcblxuICAgIHJlcy5zdGF0dXMoMjAwKS5qc29uKHtcbiAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICBzb3VyY2U6ICdQcmFldmlzaW8tQWlvbi1OQVNBLVBPV0VSLUludGVncmF0aW9uJyxcbiAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgZGF0YTogc2VydmljZURhdGFcbiAgICB9KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZXRyaWV2aW5nIGNsaW1hdGUgZXh0cmVtZXMgZGF0YTonLCBlcnJvcik7XG4gICAgcmVzLnN0YXR1cyg1MDApLmpzb24oe1xuICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICBtZXNzYWdlOiAnSW50ZXJuYWwgU2VydmVyIEVycm9yOiBDb3VsZCBub3QgcmV0cmlldmUgY2xpbWF0ZSBleHRyZW1lcyBkYXRhLidcbiAgICB9KTtcbiAgfVxufSk7XG5cbi8vIEdFVCAvYXBpL2dsb2JhbC1yaXNrL2NvbW11bml0eS1yZXNpbGllbmNlXG5yb3V0ZXIuZ2V0KCcvY29tbXVuaXR5LXJlc2lsaWVuY2UnLCBhc3luYyAocmVxLCByZXMpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCB7IGNvdW50cmllcyA9ICdDT0wsUEVSLEFSRycsIGRheXMgPSAzMCwgc2NlbmFyaW8gPSAnZGVmYXVsdCcgfSA9IHJlcS5xdWVyeTtcbiAgICBjb25zdCBjb3VudHJ5TGlzdCA9IEFycmF5LmlzQXJyYXkoY291bnRyaWVzKSA/IGNvdW50cmllcyA6IGNvdW50cmllcy5zcGxpdCgnLCcpLm1hcChjID0+IGMudHJpbSgpKS5maWx0ZXIoQm9vbGVhbik7XG5cbiAgICBjb25zdCBjb21tdW5pdHlTZXJ2aWNlID0gZ2V0U2VydmljZUluc3RhbmNlKGNvbW11bml0eVJlc2lsaWVuY2VTZXJ2aWNlTW9kdWxlKSB8fCBjb21tdW5pdHlSZXNpbGllbmNlU2VydmljZU1vZHVsZTtcbiAgICBjb25zdCBzZXJ2aWNlRGF0YSA9IHR5cGVvZiBjb21tdW5pdHlTZXJ2aWNlLmdldENvbW11bml0eVJlc2lsaWVuY2VJbmRleCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgPyBhd2FpdCBjb21tdW5pdHlTZXJ2aWNlLmdldENvbW11bml0eVJlc2lsaWVuY2VJbmRleChjb3VudHJ5TGlzdCwgTnVtYmVyKGRheXMpKVxuICAgICAgOiBhd2FpdCAoY29tbXVuaXR5U2VydmljZS5nZXRDb21tdW5pdHlSZXNpbGllbmNlSW5kZXggfHwgY29tbXVuaXR5U2VydmljZSkoY291bnRyeUxpc3QsIE51bWJlcihkYXlzKSk7XG5cbiAgICAvLyBEeW5hbWljIHZhbHVlIGNhbGN1bGF0aW9uIGJhc2VkIG9uIHNjZW5hcmlvXG4gICAgY29uc3Qgc2NlbmFyaW9NYXAgPSB7XG4gICAgICBoaWdoOiA5NSxcbiAgICAgIGxvdzogMTUsXG4gICAgICBleHRyZW1lOiA2NSxcbiAgICAgIGRlZmF1bHQ6IDQ1XG4gICAgfTtcbiAgICBjb25zdCB2YWx1ZSA9IHNjZW5hcmlvTWFwW3NjZW5hcmlvXSB8fCA0NTtcblxuICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICB0aW1lc3RhbXA6IHNlcnZpY2VEYXRhPy50aW1lc3RhbXAgfHwgbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgdG9waWM6ICdjb21tdW5pdHktcmVzaWxpZW5jZScsXG4gICAgICB1bml0OiAnJScsXG4gICAgICB2YWx1ZSxcbiAgICAgIHJlc2lsaWVuY2VBbmFseXNpczogc2VydmljZURhdGE/LnJlc2lsaWVuY2VBbmFseXNpcyB8fCB7fSxcbiAgICAgIGdsb2JhbFJlc2lsaWVuY2VBc3Nlc3NtZW50OiBzZXJ2aWNlRGF0YT8uZ2xvYmFsUmVzaWxpZW5jZUFzc2Vzc21lbnQgfHwge31cbiAgICB9O1xuXG4gICAgcmVzLnN0YXR1cygyMDApLmpzb24oe1xuICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgIHN0YXR1czogJ09LJyxcbiAgICAgIHNvdXJjZTogJ1ByYWV2aXNpby1BaW9uLUNvbW11bml0eVJlc2lsaWVuY2VBZ2VudCcsXG4gICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZXRyaWV2aW5nIGNvbW11bml0eSByZXNpbGllbmNlIGRhdGE6JywgZXJyb3IpO1xuICAgIHJlcy5zdGF0dXMoNTAwKS5qc29uKHtcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgbWVzc2FnZTogJ0ludGVybmFsIFNlcnZlciBFcnJvcjogQ291bGQgbm90IHJldHJpZXZlIGNvbW11bml0eSByZXNpbGllbmNlIGRhdGEuJ1xuICAgIH0pO1xuICB9XG59KTtcblxuLyoqXG4gKiBAcm91dGUgR0VUIC9hcGkvZ2VuZXJhdGl2ZS1hbmFseXNpc1xuICogQGRlc2NyaXB0aW9uIFByb3ZpZGVzIGdlbmVyYXRpdmUgQUkgYW5hbHlzaXMgb2YgcmlzayBkYXRhIHdpdGggbmFycmF0aXZlIGluc2lnaHRzLlxuICogQGFjY2VzcyBQdWJsaWNcbiAqL1xucm91dGVyLmdldCgnL2dlbmVyYXRpdmUtYW5hbHlzaXMnLCBhc3luYyAocmVxLCByZXMpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCB7IGZvY3VzQXJlYXMgPSBbJ2NsaW1hdGUnLCAnZWNvbm9taWMnLCAnc29jaWFsJ10sIHRpbWVIb3Jpem9uID0gJzZtb250aHMnLCBkZXRhaWxMZXZlbCA9ICdjb21wcmVoZW5zaXZlJywgbGFuZ3VhZ2UgPSAnZXMnIH0gPSByZXEucXVlcnk7XG5cbiAgICBjb25zdCBwcmVkaWN0aW9uU2VydmljZSA9IGdldFNlcnZpY2VJbnN0YW5jZShwcmVkaWN0aW9uRW5naW5lTW9kdWxlKSB8fCBwcmVkaWN0aW9uRW5naW5lTW9kdWxlO1xuICAgIGNvbnN0IHJpc2tEYXRhID0gdHlwZW9mIHByZWRpY3Rpb25TZXJ2aWNlLmdldFJpc2tJbmRpY2VzID09PSAnZnVuY3Rpb24nXG4gICAgICA/IGF3YWl0IHByZWRpY3Rpb25TZXJ2aWNlLmdldFJpc2tJbmRpY2VzKClcbiAgICAgIDogYXdhaXQgKHByZWRpY3Rpb25TZXJ2aWNlLmdldFJpc2tJbmRpY2VzIHx8IHByZWRpY3Rpb25TZXJ2aWNlKTtcblxuICAgIGNvbnN0IGdlblNlcnZpY2UgPSBnZXRTZXJ2aWNlSW5zdGFuY2UoZ2VuZXJhdGl2ZUFJU2VydmljZU1vZHVsZSkgfHwgZ2VuZXJhdGl2ZUFJU2VydmljZU1vZHVsZTtcblxuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBmb2N1c0FyZWFzOiBBcnJheS5pc0FycmF5KGZvY3VzQXJlYXMpID8gZm9jdXNBcmVhcyA6IGZvY3VzQXJlYXMuc3BsaXQoJywnKS5tYXAoYSA9PiBhLnRyaW0oKSksXG4gICAgICB0aW1lSG9yaXpvbixcbiAgICAgIGRldGFpbExldmVsLFxuICAgICAgbGFuZ3VhZ2VcbiAgICB9O1xuXG4gICAgY29uc3QgbmFycmF0aXZlID0gdHlwZW9mIGdlblNlcnZpY2UuZ2VuZXJhdGVQcmVkaWN0aXZlTmFycmF0aXZlID09PSAnZnVuY3Rpb24nXG4gICAgICA/IGF3YWl0IGdlblNlcnZpY2UuZ2VuZXJhdGVQcmVkaWN0aXZlTmFycmF0aXZlKHJpc2tEYXRhLCBvcHRpb25zKVxuICAgICAgOiBhd2FpdCAoZ2VuU2VydmljZS5nZW5lcmF0ZVByZWRpY3RpdmVOYXJyYXRpdmUgfHwgZ2VuU2VydmljZSkocmlza0RhdGEsIG9wdGlvbnMpO1xuXG4gICAgcmVzLnN0YXR1cygyMDApLmpzb24oe1xuICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgIHN0YXR1czogJ09LJyxcbiAgICAgIHNvdXJjZTogJ1ByYWV2aXNpby1BaW9uLUdlbmVyYXRpdmVBSScsXG4gICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIGRhdGE6IG5hcnJhdGl2ZVxuICAgIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdlbmVyYXRpbmcgQUkgYW5hbHlzaXM6JywgZXJyb3IpO1xuICAgIHJlcy5zdGF0dXMoNTAwKS5qc29uKHtcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgbWVzc2FnZTogJ0ludGVybmFsIFNlcnZlciBFcnJvcjogQ291bGQgbm90IGdlbmVyYXRlIEFJIGFuYWx5c2lzLidcbiAgICB9KTtcbiAgfVxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHJvdXRlcjtcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsSUFBQUEsUUFBQSxHQUFBQyxzQkFBQSxDQUFBQyxPQUFBO0FBQ0EsSUFBQUMsS0FBQSxHQUFBRixzQkFBQSxDQUFBQyxPQUFBO0FBSUEsSUFBQUUsZ0JBQUEsR0FBQUMsdUJBQUEsQ0FBQUgsT0FBQTtBQUNBLElBQUFJLG9C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