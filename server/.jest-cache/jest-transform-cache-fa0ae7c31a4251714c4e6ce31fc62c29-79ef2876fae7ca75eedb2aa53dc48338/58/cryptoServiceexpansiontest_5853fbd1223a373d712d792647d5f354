c03f1c3cc229f8f77779145645df6a75
"use strict";

// Mock the CryptoIntegration
_getJestObj().mock('../../src/integrations/CryptoIntegration.js');
var _cryptoService = _interopRequireDefault(require("../../src/services/cryptoService.js"));
var _CryptoIntegration = _interopRequireDefault(require("../../src/integrations/CryptoIntegration.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _getJestObj() {
  const {
    jest
  } = require("@jest/globals");
  _getJestObj = () => jest;
  return jest;
}
describe('CryptoService - Expansion Tests', () => {
  let cryptoService;
  let mockCryptoIntegration;
  beforeEach(() => {
    // Clear all mocks
    jest.clearAllMocks();

    // Create mock instance
    mockCryptoIntegration = {
      getCryptoData: jest.fn(),
      getHistoricalData: jest.fn()
    };

    // Make the constructor return our mock
    _CryptoIntegration.default.mockImplementation(() => mockCryptoIntegration);

    // Create service instance
    cryptoService = new _cryptoService.default();
  });
  describe('getCryptoVolatilityIndex - Expansion Scenarios', () => {
    test('should handle extreme volatility scenarios (>20% change)', async () => {
      const mockCryptoData = [{
        id: 'bitcoin',
        price_change_percentage_24h: -25.0
      }, {
        id: 'ethereum',
        price_change_percentage_24h: 18.5
      }];
      mockCryptoIntegration.getCryptoData.mockResolvedValue(mockCryptoData);
      const result = await cryptoService.getCryptoVolatilityIndex(['bitcoin', 'ethereum']);
      expect(result).toBeGreaterThan(80); // Extreme volatility should result in very high risk
      expect(result).toBeLessThanOrEqual(100);
    });
    test('should calculate volatility for diverse crypto portfolio', async () => {
      const mockCryptoData = [{
        id: 'bitcoin',
        price_change_percentage_24h: -2.5
      }, {
        id: 'ethereum',
        price_change_percentage_24h: 1.2
      }, {
        id: 'solana',
        price_change_percentage_24h: 5.8
      }, {
        id: 'cardano',
        price_change_percentage_24h: -1.1
      }, {
        id: 'polygon',
        price_change_percentage_24h: 3.2
      }];
      mockCryptoIntegration.getCryptoData.mockResolvedValue(mockCryptoData);
      const result = await cryptoService.getCryptoVolatilityIndex(['bitcoin', 'ethereum', 'solana', 'cardano', 'polygon']);
      expect(result).toBeGreaterThanOrEqual(0);
      expect(result).toBeLessThanOrEqual(100);
      expect(mockCryptoIntegration.getCryptoData).toHaveBeenCalledWith(['bitcoin', 'ethereum', 'solana', 'cardano', 'polygon']);
    });
    test('should handle mixed positive and negative changes', async () => {
      const mockCryptoData = [{
        id: 'bitcoin',
        price_change_percentage_24h: 15.0
      }, {
        id: 'ethereum',
        price_change_percentage_24h: -12.0
      }, {
        id: 'solana',
        price_change_percentage_24h: 8.5
      }];
      mockCryptoIntegration.getCryptoData.mockResolvedValue(mockCryptoData);
      const result = await cryptoService.getCryptoVolatilityIndex(['bitcoin', 'ethereum', 'solana']);
      expect(result).toBeGreaterThan(50); // Mixed volatility should be moderate-high
      expect(result).toBeLessThanOrEqual(100);
    });
    test('should handle single cryptocurrency analysis', async () => {
      const mockCryptoData = [{
        id: 'bitcoin',
        price_change_percentage_24h: 7.5
      }];
      mockCryptoIntegration.getCryptoData.mockResolvedValue(mockCryptoData);
      const result = await cryptoService.getCryptoVolatilityIndex(['bitcoin']);
      expect(result).toBeGreaterThan(30); // Moderate volatility
      expect(result).toBeLessThan(50);
    });
  });
  describe('getCryptoMarketAnalysis - Expansion Features', () => {
    test('should include market cap and trading volume in analysis', async () => {
      const mockCryptoData = [{
        id: 'bitcoin',
        symbol: 'btc',
        name: 'Bitcoin',
        current_price: 45000,
        market_cap: 850000000000,
        total_volume: 25000000000,
        price_change_percentage_24h: -2.5
      }, {
        id: 'ethereum',
        symbol: 'eth',
        name: 'Ethereum',
        current_price: 2800,
        market_cap: 335000000000,
        total_volume: 15000000000,
        price_change_percentage_24h: 1.2
      }];
      mockCryptoIntegration.getCryptoData.mockResolvedValue(mockCryptoData);
      const result = await cryptoService.getCryptoMarketAnalysis(['bitcoin', 'ethereum']);
      expect(result).toHaveProperty('marketData');
      expect(result.marketData.length).toBe(2);
      expect(result.marketData[0]).toHaveProperty('market_cap');
      expect(result.marketData[0]).toHaveProperty('total_volume');
    });
    test('should handle large market cap cryptocurrencies', async () => {
      const mockCryptoData = [{
        id: 'bitcoin',
        symbol: 'btc',
        name: 'Bitcoin',
        current_price: 60000,
        market_cap: 1200000000000,
        // 1.2 trillion
        price_change_percentage_24h: 0.5
      }];
      mockCryptoIntegration.getCryptoData.mockResolvedValue(mockCryptoData);
      const result = await cryptoService.getCryptoMarketAnalysis(['bitcoin']);
      expect(result.volatilityIndex).toBeLessThan(20); // Low volatility for stable large cap
      expect(result.analysis.riskAssessment).toBe('Low');
    });
    test('should analyze altcoin volatility patterns', async () => {
      const mockCryptoData = [{
        id: 'solana',
        price_change_percentage_24h: 12.5
      }, {
        id: 'avalanche-2',
        price_change_percentage_24h: -8.3
      }, {
        id: 'polygon',
        price_change_percentage_24h: 6.7
      }];
      mockCryptoIntegration.getCryptoData.mockResolvedValue(mockCryptoData);
      const result = await cryptoService.getCryptoMarketAnalysis(['solana', 'avalanche-2', 'polygon']);
      expect(result.volatilityIndex).toBeGreaterThan(40); // Higher volatility for altcoins
      expect(result.analysis.totalCryptos).toBe(3);
    });
  });
  describe('Error Handling - Expansion', () => {
    test('should handle partial data failures gracefully', async () => {
      const mockCryptoData = [{
        id: 'bitcoin',
        price_change_percentage_24h: -2.5
      }, {
        id: 'ethereum'
      },
      // Missing price_change_percentage_24h
      {
        id: 'solana',
        price_change_percentage_24h: 5.8
      }];
      mockCryptoIntegration.getCryptoData.mockResolvedValue(mockCryptoData);
      const result = await cryptoService.getCryptoVolatilityIndex(['bitcoin', 'ethereum', 'solana']);
      expect(result).toBeGreaterThanOrEqual(0);
      expect(result).toBeLessThanOrEqual(100);
      // Should still calculate based on available data
    });
    test('should handle network timeouts during market analysis', async () => {
      mockCryptoIntegration.getCryptoData.mockRejectedValue(new Error('Network timeout'));
      const result = await cryptoService.getCryptoMarketAnalysis(['bitcoin']);
      expect(result).toHaveProperty('volatilityIndex', 25);
      expect(result).toHaveProperty('error');
      expect(result.source).toBe('CryptoService - Error Fallback');
    });
    test('should maintain service availability during API outages', async () => {
      mockCryptoIntegration.getCryptoData.mockRejectedValue(new Error('API unavailable'));
      const volatilityResult = await cryptoService.getCryptoVolatilityIndex(['bitcoin']);
      const analysisResult = await cryptoService.getCryptoMarketAnalysis(['bitcoin']);
      expect(volatilityResult).toBe(25); // Default fallback
      expect(analysisResult.volatilityIndex).toBe(25);
      expect(analysisResult.source).toBe('CryptoService - Error Fallback');
    });
  });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfZ2V0SmVzdE9iaiIsIm1vY2siLCJfY3J5cHRvU2VydmljZSIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJyZXF1aXJlIiwiX0NyeXB0b0ludGVncmF0aW9uIiwiZSIsIl9fZXNNb2R1bGUiLCJkZWZhdWx0IiwiamVzdCIsImRlc2NyaWJlIiwiY3J5cHRvU2VydmljZSIsIm1vY2tDcnlwdG9JbnRlZ3JhdGlvbiIsImJlZm9yZUVhY2giLCJjbGVhckFsbE1vY2tzIiwiZ2V0Q3J5cHRvRGF0YSIsImZuIiwiZ2V0SGlzdG9yaWNhbERhdGEiLCJDcnlwdG9JbnRlZ3JhdGlvbiIsIm1vY2tJbXBsZW1lbnRhdGlvbiIsIkNyeXB0b1NlcnZpY2UiLCJ0ZXN0IiwibW9ja0NyeXB0b0RhdGEiLCJpZCIsInByaWNlX2NoYW5nZV9wZXJjZW50YWdlXzI0aCIsIm1vY2tSZXNvbHZlZFZhbHVlIiwicmVzdWx0IiwiZ2V0Q3J5cHRvVm9sYXRpbGl0eUluZGV4IiwiZXhwZWN0IiwidG9CZUdyZWF0ZXJUaGFuIiwidG9CZUxlc3NUaGFuT3JFcXVhbCIsInRvQmVHcmVhdGVyVGhhbk9yRXF1YWwiLCJ0b0hhdmVCZWVuQ2FsbGVkV2l0aCIsInRvQmVMZXNzVGhhbiIsInN5bWJvbCIsIm5hbWUiLCJjdXJyZW50X3ByaWNlIiwibWFya2V0X2NhcCIsInRvdGFsX3ZvbHVtZSIsImdldENyeXB0b01hcmtldEFuYWx5c2lzIiwidG9IYXZlUHJvcGVydHkiLCJtYXJrZXREYXRhIiwibGVuZ3RoIiwidG9CZSIsInZvbGF0aWxpdHlJbmRleCIsImFuYWx5c2lzIiwicmlza0Fzc2Vzc21lbnQiLCJ0b3RhbENyeXB0b3MiLCJtb2NrUmVqZWN0ZWRWYWx1ZSIsIkVycm9yIiwic291cmNlIiwidm9sYXRpbGl0eVJlc3VsdCIsImFuYWx5c2lzUmVzdWx0Il0sInNvdXJjZXMiOlsiY3J5cHRvU2VydmljZS5leHBhbnNpb24udGVzdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQ3J5cHRvU2VydmljZSBmcm9tICcuLi8uLi9zcmMvc2VydmljZXMvY3J5cHRvU2VydmljZS5qcyc7XG5pbXBvcnQgQ3J5cHRvSW50ZWdyYXRpb24gZnJvbSAnLi4vLi4vc3JjL2ludGVncmF0aW9ucy9DcnlwdG9JbnRlZ3JhdGlvbi5qcyc7XG5cbi8vIE1vY2sgdGhlIENyeXB0b0ludGVncmF0aW9uXG5qZXN0Lm1vY2soJy4uLy4uL3NyYy9pbnRlZ3JhdGlvbnMvQ3J5cHRvSW50ZWdyYXRpb24uanMnKTtcblxuZGVzY3JpYmUoJ0NyeXB0b1NlcnZpY2UgLSBFeHBhbnNpb24gVGVzdHMnLCAoKSA9PiB7XG4gIGxldCBjcnlwdG9TZXJ2aWNlO1xuICBsZXQgbW9ja0NyeXB0b0ludGVncmF0aW9uO1xuXG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIC8vIENsZWFyIGFsbCBtb2Nrc1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuXG4gICAgLy8gQ3JlYXRlIG1vY2sgaW5zdGFuY2VcbiAgICBtb2NrQ3J5cHRvSW50ZWdyYXRpb24gPSB7XG4gICAgICBnZXRDcnlwdG9EYXRhOiBqZXN0LmZuKCksXG4gICAgICBnZXRIaXN0b3JpY2FsRGF0YTogamVzdC5mbigpLFxuICAgIH07XG5cbiAgICAvLyBNYWtlIHRoZSBjb25zdHJ1Y3RvciByZXR1cm4gb3VyIG1vY2tcbiAgICBDcnlwdG9JbnRlZ3JhdGlvbi5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4gbW9ja0NyeXB0b0ludGVncmF0aW9uKTtcblxuICAgIC8vIENyZWF0ZSBzZXJ2aWNlIGluc3RhbmNlXG4gICAgY3J5cHRvU2VydmljZSA9IG5ldyBDcnlwdG9TZXJ2aWNlKCk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdnZXRDcnlwdG9Wb2xhdGlsaXR5SW5kZXggLSBFeHBhbnNpb24gU2NlbmFyaW9zJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCBoYW5kbGUgZXh0cmVtZSB2b2xhdGlsaXR5IHNjZW5hcmlvcyAoPjIwJSBjaGFuZ2UpJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja0NyeXB0b0RhdGEgPSBbXG4gICAgICAgIHsgaWQ6ICdiaXRjb2luJywgcHJpY2VfY2hhbmdlX3BlcmNlbnRhZ2VfMjRoOiAtMjUuMCB9LFxuICAgICAgICB7IGlkOiAnZXRoZXJldW0nLCBwcmljZV9jaGFuZ2VfcGVyY2VudGFnZV8yNGg6IDE4LjUgfVxuICAgICAgXTtcblxuICAgICAgbW9ja0NyeXB0b0ludGVncmF0aW9uLmdldENyeXB0b0RhdGEubW9ja1Jlc29sdmVkVmFsdWUobW9ja0NyeXB0b0RhdGEpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjcnlwdG9TZXJ2aWNlLmdldENyeXB0b1ZvbGF0aWxpdHlJbmRleChbJ2JpdGNvaW4nLCAnZXRoZXJldW0nXSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmVHcmVhdGVyVGhhbig4MCk7IC8vIEV4dHJlbWUgdm9sYXRpbGl0eSBzaG91bGQgcmVzdWx0IGluIHZlcnkgaGlnaCByaXNrXG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlTGVzc1RoYW5PckVxdWFsKDEwMCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgY2FsY3VsYXRlIHZvbGF0aWxpdHkgZm9yIGRpdmVyc2UgY3J5cHRvIHBvcnRmb2xpbycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tDcnlwdG9EYXRhID0gW1xuICAgICAgICB7IGlkOiAnYml0Y29pbicsIHByaWNlX2NoYW5nZV9wZXJjZW50YWdlXzI0aDogLTIuNSB9LFxuICAgICAgICB7IGlkOiAnZXRoZXJldW0nLCBwcmljZV9jaGFuZ2VfcGVyY2VudGFnZV8yNGg6IDEuMiB9LFxuICAgICAgICB7IGlkOiAnc29sYW5hJywgcHJpY2VfY2hhbmdlX3BlcmNlbnRhZ2VfMjRoOiA1LjggfSxcbiAgICAgICAgeyBpZDogJ2NhcmRhbm8nLCBwcmljZV9jaGFuZ2VfcGVyY2VudGFnZV8yNGg6IC0xLjEgfSxcbiAgICAgICAgeyBpZDogJ3BvbHlnb24nLCBwcmljZV9jaGFuZ2VfcGVyY2VudGFnZV8yNGg6IDMuMiB9XG4gICAgICBdO1xuXG4gICAgICBtb2NrQ3J5cHRvSW50ZWdyYXRpb24uZ2V0Q3J5cHRvRGF0YS5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrQ3J5cHRvRGF0YSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNyeXB0b1NlcnZpY2UuZ2V0Q3J5cHRvVm9sYXRpbGl0eUluZGV4KFsnYml0Y29pbicsICdldGhlcmV1bScsICdzb2xhbmEnLCAnY2FyZGFubycsICdwb2x5Z29uJ10pO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlR3JlYXRlclRoYW5PckVxdWFsKDApO1xuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZUxlc3NUaGFuT3JFcXVhbCgxMDApO1xuICAgICAgZXhwZWN0KG1vY2tDcnlwdG9JbnRlZ3JhdGlvbi5nZXRDcnlwdG9EYXRhKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChbJ2JpdGNvaW4nLCAnZXRoZXJldW0nLCAnc29sYW5hJywgJ2NhcmRhbm8nLCAncG9seWdvbiddKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBoYW5kbGUgbWl4ZWQgcG9zaXRpdmUgYW5kIG5lZ2F0aXZlIGNoYW5nZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrQ3J5cHRvRGF0YSA9IFtcbiAgICAgICAgeyBpZDogJ2JpdGNvaW4nLCBwcmljZV9jaGFuZ2VfcGVyY2VudGFnZV8yNGg6IDE1LjAgfSxcbiAgICAgICAgeyBpZDogJ2V0aGVyZXVtJywgcHJpY2VfY2hhbmdlX3BlcmNlbnRhZ2VfMjRoOiAtMTIuMCB9LFxuICAgICAgICB7IGlkOiAnc29sYW5hJywgcHJpY2VfY2hhbmdlX3BlcmNlbnRhZ2VfMjRoOiA4LjUgfVxuICAgICAgXTtcblxuICAgICAgbW9ja0NyeXB0b0ludGVncmF0aW9uLmdldENyeXB0b0RhdGEubW9ja1Jlc29sdmVkVmFsdWUobW9ja0NyeXB0b0RhdGEpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjcnlwdG9TZXJ2aWNlLmdldENyeXB0b1ZvbGF0aWxpdHlJbmRleChbJ2JpdGNvaW4nLCAnZXRoZXJldW0nLCAnc29sYW5hJ10pO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlR3JlYXRlclRoYW4oNTApOyAvLyBNaXhlZCB2b2xhdGlsaXR5IHNob3VsZCBiZSBtb2RlcmF0ZS1oaWdoXG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlTGVzc1RoYW5PckVxdWFsKDEwMCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgaGFuZGxlIHNpbmdsZSBjcnlwdG9jdXJyZW5jeSBhbmFseXNpcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tDcnlwdG9EYXRhID0gW1xuICAgICAgICB7IGlkOiAnYml0Y29pbicsIHByaWNlX2NoYW5nZV9wZXJjZW50YWdlXzI0aDogNy41IH1cbiAgICAgIF07XG5cbiAgICAgIG1vY2tDcnlwdG9JbnRlZ3JhdGlvbi5nZXRDcnlwdG9EYXRhLm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tDcnlwdG9EYXRhKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY3J5cHRvU2VydmljZS5nZXRDcnlwdG9Wb2xhdGlsaXR5SW5kZXgoWydiaXRjb2luJ10pO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlR3JlYXRlclRoYW4oMzApOyAvLyBNb2RlcmF0ZSB2b2xhdGlsaXR5XG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlTGVzc1RoYW4oNTApO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnZ2V0Q3J5cHRvTWFya2V0QW5hbHlzaXMgLSBFeHBhbnNpb24gRmVhdHVyZXMnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIGluY2x1ZGUgbWFya2V0IGNhcCBhbmQgdHJhZGluZyB2b2x1bWUgaW4gYW5hbHlzaXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrQ3J5cHRvRGF0YSA9IFtcbiAgICAgICAge1xuICAgICAgICAgIGlkOiAnYml0Y29pbicsXG4gICAgICAgICAgc3ltYm9sOiAnYnRjJyxcbiAgICAgICAgICBuYW1lOiAnQml0Y29pbicsXG4gICAgICAgICAgY3VycmVudF9wcmljZTogNDUwMDAsXG4gICAgICAgICAgbWFya2V0X2NhcDogODUwMDAwMDAwMDAwLFxuICAgICAgICAgIHRvdGFsX3ZvbHVtZTogMjUwMDAwMDAwMDAsXG4gICAgICAgICAgcHJpY2VfY2hhbmdlX3BlcmNlbnRhZ2VfMjRoOiAtMi41XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBpZDogJ2V0aGVyZXVtJyxcbiAgICAgICAgICBzeW1ib2w6ICdldGgnLFxuICAgICAgICAgIG5hbWU6ICdFdGhlcmV1bScsXG4gICAgICAgICAgY3VycmVudF9wcmljZTogMjgwMCxcbiAgICAgICAgICBtYXJrZXRfY2FwOiAzMzUwMDAwMDAwMDAsXG4gICAgICAgICAgdG90YWxfdm9sdW1lOiAxNTAwMDAwMDAwMCxcbiAgICAgICAgICBwcmljZV9jaGFuZ2VfcGVyY2VudGFnZV8yNGg6IDEuMlxuICAgICAgICB9XG4gICAgICBdO1xuXG4gICAgICBtb2NrQ3J5cHRvSW50ZWdyYXRpb24uZ2V0Q3J5cHRvRGF0YS5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrQ3J5cHRvRGF0YSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNyeXB0b1NlcnZpY2UuZ2V0Q3J5cHRvTWFya2V0QW5hbHlzaXMoWydiaXRjb2luJywgJ2V0aGVyZXVtJ10pO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0hhdmVQcm9wZXJ0eSgnbWFya2V0RGF0YScpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5tYXJrZXREYXRhLmxlbmd0aCkudG9CZSgyKTtcbiAgICAgIGV4cGVjdChyZXN1bHQubWFya2V0RGF0YVswXSkudG9IYXZlUHJvcGVydHkoJ21hcmtldF9jYXAnKTtcbiAgICAgIGV4cGVjdChyZXN1bHQubWFya2V0RGF0YVswXSkudG9IYXZlUHJvcGVydHkoJ3RvdGFsX3ZvbHVtZScpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGhhbmRsZSBsYXJnZSBtYXJrZXQgY2FwIGNyeXB0b2N1cnJlbmNpZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrQ3J5cHRvRGF0YSA9IFtcbiAgICAgICAge1xuICAgICAgICAgIGlkOiAnYml0Y29pbicsXG4gICAgICAgICAgc3ltYm9sOiAnYnRjJyxcbiAgICAgICAgICBuYW1lOiAnQml0Y29pbicsXG4gICAgICAgICAgY3VycmVudF9wcmljZTogNjAwMDAsXG4gICAgICAgICAgbWFya2V0X2NhcDogMTIwMDAwMDAwMDAwMCwgLy8gMS4yIHRyaWxsaW9uXG4gICAgICAgICAgcHJpY2VfY2hhbmdlX3BlcmNlbnRhZ2VfMjRoOiAwLjVcbiAgICAgICAgfVxuICAgICAgXTtcblxuICAgICAgbW9ja0NyeXB0b0ludGVncmF0aW9uLmdldENyeXB0b0RhdGEubW9ja1Jlc29sdmVkVmFsdWUobW9ja0NyeXB0b0RhdGEpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjcnlwdG9TZXJ2aWNlLmdldENyeXB0b01hcmtldEFuYWx5c2lzKFsnYml0Y29pbiddKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC52b2xhdGlsaXR5SW5kZXgpLnRvQmVMZXNzVGhhbigyMCk7IC8vIExvdyB2b2xhdGlsaXR5IGZvciBzdGFibGUgbGFyZ2UgY2FwXG4gICAgICBleHBlY3QocmVzdWx0LmFuYWx5c2lzLnJpc2tBc3Nlc3NtZW50KS50b0JlKCdMb3cnKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBhbmFseXplIGFsdGNvaW4gdm9sYXRpbGl0eSBwYXR0ZXJucycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tDcnlwdG9EYXRhID0gW1xuICAgICAgICB7IGlkOiAnc29sYW5hJywgcHJpY2VfY2hhbmdlX3BlcmNlbnRhZ2VfMjRoOiAxMi41IH0sXG4gICAgICAgIHsgaWQ6ICdhdmFsYW5jaGUtMicsIHByaWNlX2NoYW5nZV9wZXJjZW50YWdlXzI0aDogLTguMyB9LFxuICAgICAgICB7IGlkOiAncG9seWdvbicsIHByaWNlX2NoYW5nZV9wZXJjZW50YWdlXzI0aDogNi43IH1cbiAgICAgIF07XG5cbiAgICAgIG1vY2tDcnlwdG9JbnRlZ3JhdGlvbi5nZXRDcnlwdG9EYXRhLm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tDcnlwdG9EYXRhKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY3J5cHRvU2VydmljZS5nZXRDcnlwdG9NYXJrZXRBbmFseXNpcyhbJ3NvbGFuYScsICdhdmFsYW5jaGUtMicsICdwb2x5Z29uJ10pO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnZvbGF0aWxpdHlJbmRleCkudG9CZUdyZWF0ZXJUaGFuKDQwKTsgLy8gSGlnaGVyIHZvbGF0aWxpdHkgZm9yIGFsdGNvaW5zXG4gICAgICBleHBlY3QocmVzdWx0LmFuYWx5c2lzLnRvdGFsQ3J5cHRvcykudG9CZSgzKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0Vycm9yIEhhbmRsaW5nIC0gRXhwYW5zaW9uJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCBoYW5kbGUgcGFydGlhbCBkYXRhIGZhaWx1cmVzIGdyYWNlZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrQ3J5cHRvRGF0YSA9IFtcbiAgICAgICAgeyBpZDogJ2JpdGNvaW4nLCBwcmljZV9jaGFuZ2VfcGVyY2VudGFnZV8yNGg6IC0yLjUgfSxcbiAgICAgICAgeyBpZDogJ2V0aGVyZXVtJyB9LCAvLyBNaXNzaW5nIHByaWNlX2NoYW5nZV9wZXJjZW50YWdlXzI0aFxuICAgICAgICB7IGlkOiAnc29sYW5hJywgcHJpY2VfY2hhbmdlX3BlcmNlbnRhZ2VfMjRoOiA1LjggfVxuICAgICAgXTtcblxuICAgICAgbW9ja0NyeXB0b0ludGVncmF0aW9uLmdldENyeXB0b0RhdGEubW9ja1Jlc29sdmVkVmFsdWUobW9ja0NyeXB0b0RhdGEpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjcnlwdG9TZXJ2aWNlLmdldENyeXB0b1ZvbGF0aWxpdHlJbmRleChbJ2JpdGNvaW4nLCAnZXRoZXJldW0nLCAnc29sYW5hJ10pO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlR3JlYXRlclRoYW5PckVxdWFsKDApO1xuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZUxlc3NUaGFuT3JFcXVhbCgxMDApO1xuICAgICAgLy8gU2hvdWxkIHN0aWxsIGNhbGN1bGF0ZSBiYXNlZCBvbiBhdmFpbGFibGUgZGF0YVxuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGhhbmRsZSBuZXR3b3JrIHRpbWVvdXRzIGR1cmluZyBtYXJrZXQgYW5hbHlzaXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrQ3J5cHRvSW50ZWdyYXRpb24uZ2V0Q3J5cHRvRGF0YS5tb2NrUmVqZWN0ZWRWYWx1ZShuZXcgRXJyb3IoJ05ldHdvcmsgdGltZW91dCcpKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY3J5cHRvU2VydmljZS5nZXRDcnlwdG9NYXJrZXRBbmFseXNpcyhbJ2JpdGNvaW4nXSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvSGF2ZVByb3BlcnR5KCd2b2xhdGlsaXR5SW5kZXgnLCAyNSk7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0hhdmVQcm9wZXJ0eSgnZXJyb3InKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuc291cmNlKS50b0JlKCdDcnlwdG9TZXJ2aWNlIC0gRXJyb3IgRmFsbGJhY2snKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBtYWludGFpbiBzZXJ2aWNlIGF2YWlsYWJpbGl0eSBkdXJpbmcgQVBJIG91dGFnZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrQ3J5cHRvSW50ZWdyYXRpb24uZ2V0Q3J5cHRvRGF0YS5tb2NrUmVqZWN0ZWRWYWx1ZShuZXcgRXJyb3IoJ0FQSSB1bmF2YWlsYWJsZScpKTtcblxuICAgICAgY29uc3Qgdm9sYXRpbGl0eVJlc3VsdCA9IGF3YWl0IGNyeXB0b1NlcnZpY2UuZ2V0Q3J5cHRvVm9sYXRpbGl0eUluZGV4KFsnYml0Y29pbiddKTtcbiAgICAgIGNvbnN0IGFuYWx5c2lzUmVzdWx0ID0gYXdhaXQgY3J5cHRvU2VydmljZS5nZXRDcnlwdG9NYXJrZXRBbmFseXNpcyhbJ2JpdGNvaW4nXSk7XG5cbiAgICAgIGV4cGVjdCh2b2xhdGlsaXR5UmVzdWx0KS50b0JlKDI1KTsgLy8gRGVmYXVsdCBmYWxsYmFja1xuICAgICAgZXhwZWN0KGFuYWx5c2lzUmVzdWx0LnZvbGF0aWxpdHlJbmRleCkudG9CZSgyNSk7XG4gICAgICBleHBlY3QoYW5hbHlzaXNSZXN1bHQuc291cmNlKS50b0JlKCdDcnlwdG9TZXJ2aWNlIC0gRXJyb3IgRmFsbGJhY2snKTtcbiAgICB9KTtcbiAgfSk7XG59KTsiXSwibWFwcGluZ3MiOiI7O0FBR0E7QUFDQUEsV0FBQSxHQUFLQyxJQUFJLENBQUMsNkNBQTZDLENBQUM7QUFKeEQsSUFBQUMsY0FBQSxHQUFBQyxzQkFBQSxDQUFBQyxPQUFBO0FBQ0EsSUFBQUMsa0JBQUEsR0FBQUYsc0JBQUEsQ0FBQUMsT0FBQTtBQUE0RSxTQUFBRCx1QkFBQUcsQ0FBQSxXQUFBQSxDQUFBLElBQUFBLENBQUEsQ0FBQUMsVUFBQSxHQUFBRCxDQUFBLEtBQUFFLE9BQUEsRUFBQUYsQ0FBQTtBQUFBLFNBQUFOLFlBQUE7RUFBQTtJQUFBUztFQUFBLElBQUFMLE9BQUE7RUFBQUosV0FBQSxHQUFBQSxDQUFBLEtBQUFTLElBQUE7RUFBQSxPQUFBQSxJQUFBO0FBQUE7QUFLNUVDLFFBQVEsQ0FBQyxpQ0FBaUMsRUFBRSxNQUFNO0VBQ2hELElBQUlDLGFBQWE7RUFDakIsSUFBSUMscUJBQXFCO0VBRXpCQyxVQUFVLENBQUMsTUFBTTtJQUNmO0lBQ0FKLElBQUksQ0FBQ0ssYUFBYSxDQUFDLENBQUM7O0lBRXBCO0lBQ0FGLHFCQUFxQixHQUFHO01BQ3RCRyxhQUFhLEVBQUVOLElBQUksQ0FBQ08sRUFBRSxDQUFD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