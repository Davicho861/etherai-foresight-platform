{"version":3,"names":["parseMultipartData_exports","__export","parseMultipartData","module","exports","__toCommonJS","import_headers_polyfill","require","parseContentHeaders","headersString","headers","stringToHeaders","contentType","get","disposition","Error","directives","split","reduce","acc","chunk","name2","rest","trim","join","name","slice","filename","data","boundary","filter","d","startsWith","map","s","replace","boundaryRegExp","RegExp","fields","endsWith","trimStart","length","parsedBody","field","contentHeaders","contentBody","contentType2","value","File","type","parsedValue","Array","isArray"],"sources":["../../../../src/core/utils/internal/parseMultipartData.ts"],"sourcesContent":["import { stringToHeaders } from 'headers-polyfill'\nimport { DefaultRequestMultipartBody } from '../../handlers/RequestHandler'\n\ninterface ParsedContentHeaders {\n  name: string\n  filename?: string\n  contentType: string\n}\n\ninterface ContentDispositionDirective {\n  [key: string]: string | undefined\n  name: string\n  filename?: string\n  'form-data': string\n}\n\nfunction parseContentHeaders(headersString: string): ParsedContentHeaders {\n  const headers = stringToHeaders(headersString)\n  const contentType = headers.get('content-type') || 'text/plain'\n  const disposition = headers.get('content-disposition')\n\n  if (!disposition) {\n    throw new Error('\"Content-Disposition\" header is required.')\n  }\n\n  const directives = disposition.split(';').reduce((acc, chunk) => {\n    const [name, ...rest] = chunk.trim().split('=')\n    acc[name] = rest.join('=')\n    return acc\n  }, {} as ContentDispositionDirective)\n\n  const name = directives.name?.slice(1, -1)\n  const filename = directives.filename?.slice(1, -1)\n\n  return {\n    name,\n    filename,\n    contentType,\n  }\n}\n\n/**\n * Parses a given string as a multipart/form-data.\n * Does not throw an exception on an invalid multipart string.\n */\nexport function parseMultipartData<T extends DefaultRequestMultipartBody>(\n  data: string,\n  headers?: Headers,\n): T | undefined {\n  const contentType = headers?.get('content-type')\n\n  if (!contentType) {\n    return undefined\n  }\n\n  const [, ...directives] = contentType.split(/; */)\n  const boundary = directives\n    .filter((d) => d.startsWith('boundary='))\n    .map((s) => s.replace(/^boundary=/, ''))[0]\n\n  if (!boundary) {\n    return undefined\n  }\n\n  const boundaryRegExp = new RegExp(`--+${boundary}`)\n  const fields = data\n    .split(boundaryRegExp)\n    .filter((chunk) => chunk.startsWith('\\r\\n') && chunk.endsWith('\\r\\n'))\n    .map((chunk) => chunk.trimStart().replace(/\\r\\n$/, ''))\n\n  if (!fields.length) {\n    return undefined\n  }\n\n  const parsedBody: DefaultRequestMultipartBody = {}\n\n  try {\n    for (const field of fields) {\n      const [contentHeaders, ...rest] = field.split('\\r\\n\\r\\n')\n      const contentBody = rest.join('\\r\\n\\r\\n')\n      const { contentType, filename, name } =\n        parseContentHeaders(contentHeaders)\n\n      const value =\n        filename === undefined\n          ? contentBody\n          : new File([contentBody], filename, { type: contentType })\n\n      const parsedValue = parsedBody[name]\n\n      if (parsedValue === undefined) {\n        parsedBody[name] = value\n      } else if (Array.isArray(parsedValue)) {\n        parsedBody[name] = [...parsedValue, value]\n      } else {\n        parsedBody[name] = [parsedValue, value]\n      }\n    }\n\n    return parsedBody as T\n  } catch {\n    return undefined\n  }\n}\n"],"mappings":"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","ignoreList":[]}