71ab5704febc1624493af74df61fbc82
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _express = _interopRequireDefault(require("express"));
var _path = _interopRequireDefault(require("path"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
// Static imports so Jest can mock these modules reliably in tests
// Services are loaded dynamically via safeLoad to ensure tests can mock them
// at runtime (tests may call jest.mock after importing this module).

// Resolve a stable __dirname for this module in both ESM and CommonJS
// test environments. Some test runners (Jest + babel-jest) may not
// support `import.meta.url` during transformation, which causes
// "Cannot use 'import.meta' outside a module" errors. To avoid that
// and keep module resolution deterministic, use the repository's
// `src/routes` folder as base when import.meta is unavailable.
const _dirname = _path.default.resolve(process.cwd(), 'src', 'routes');
const router = _express.default.Router();

// Helper to dynamically load a module.
// Prefer CommonJS `require` when available so Jest's module mocks (which
// commonly patch `require`) are applied. Fallback to dynamic import for
// true ESM modules or when require isn't available.
async function safeLoad(modulePath) {
  const fullPath = _path.default.resolve(_dirname, modulePath);
  // Try require first for better compatibility with Jest mocks
  try {
    // eslint-disable-next-line global-require, import/no-dynamic-require
    if (typeof require === 'function') {
      // Try to find a cached module that matches the service filename.
      // Jest may register mocks under absolute paths; searching the
      // require.cache for a filename suffix like '/src/services/cryptoService.js'
      // often finds the mocked module so tests' mocks are honored.
      try {
        const targetBasename = _path.default.basename(modulePath);
        const cacheKeys = Object.keys(require.cache || {});
        const matchKey = cacheKeys.find(k => k.endsWith(_path.default.join('src', 'services', targetBasename)));
        if (matchKey) {
          const cached = require(matchKey);
          return cached && cached.__esModule ? cached.default || cached : cached;
        }
      } catch (cacheErr) {
        // ignore and continue to normal require flow
      }
      // Try requiring by the original module path first so Jest's module
      // mocking (which uses the module id as declared in tests) is applied.
      try {
        const modById = require(modulePath);
        return modById && modById.__esModule ? modById.default || modById : modById;
      } catch (e) {
        // If that fails, fall back to absolute resolution
      }
      const resolved = require.resolve(fullPath);
      const mod = require(resolved);
      return mod && mod.__esModule ? mod.default || mod : mod;
    }
  } catch (reqErr) {
    // Not fatal: fall through to dynamic import
    // console.debug(`safeLoad require failed for ${modulePath}:`, reqErr.message);
  }

  // Dynamic import fallback (for ESM-only modules)
  try {
    const mod = await (specifier => new Promise(r => r(`${specifier}`)).then(s => _interopRequireWildcard(require(s))))(fullPath);
    return mod && mod.default ? mod.default : mod;
  } catch (importErr) {
    console.error(`Error loading module ${modulePath} via import():`, importErr);
    throw new Error(`Failed to load module: ${modulePath}`);
  }
}

// Helper: given a loaded module, return a usable service object.
function getServiceInstance(mod) {
  if (!mod) return null;
  // If module is a constructor (class or function), instantiate it.
  if (typeof mod === 'function') {
    try {
      return new mod();
    } catch (e) {
      // If it's a factory function that returns an object when called
      try {
        return mod();
      } catch (err) {
        return mod;
      }
    }
  }
  // If module is an object with a default class, instantiate default
  if (mod && typeof mod === 'object' && mod.default && typeof mod.default === 'function') {
    try {
      return new mod.default();
    } catch (e) {
      try {
        return mod.default();
      } catch (err) {
        return mod.default || mod;
      }
    }
  }
  // Otherwise return the module as-is (it may be an object of functions)
  return mod;
}

// GET /api/global-risk/food-security 
router.get('/food-security', async (req, res) => {
  try {
    // Use the statically imported module (tests mock this module)
    const foodMod = await safeLoad('../services/worldBankService.js');
    const foodService = getServiceInstance(foodMod) || foodMod;
    const data = typeof foodService.getFoodSecurityIndex === 'function' ? await foodService.getFoodSecurityIndex() : await (foodService.getFoodSecurityIndex || foodService);
    res.status(200).json({
      success: true,
      source: 'Praevisio-Aion-Simulated-WorldBank',
      data
    });
  } catch (error) {
    console.error('Error retrieving food security data:', error);
    res.status(500).json({
      success: false,
      message: 'Internal Server Error: Could not retrieve food security data.'
    });
  }
});

// GET /api/global-risk/crypto-volatility
router.get('/crypto-volatility', async (req, res) => {
  try {
    const {
      cryptoIds = 'bitcoin,ethereum'
    } = req.query;
    const cryptoList = cryptoIds.split(',').map(id => id.trim());
    // Use statically imported crypto module so Jest's mockImplementation is used
    const cryptoMod = await safeLoad('../services/cryptoService.js');
    const cryptoService = getServiceInstance(cryptoMod) || cryptoMod;
    const serviceData = typeof cryptoService.getCryptoMarketAnalysis === 'function' ? await cryptoService.getCryptoMarketAnalysis(cryptoList) : await (cryptoService.getCryptoMarketAnalysis || cryptoService)(cryptoList);

    // Normalize/augment returned service data for backward compatibility
    if (serviceData && typeof serviceData === 'object') {
      // If the service provides a volatilityIndex, expose it as `value` to match tests
      if (serviceData.volatilityIndex !== undefined) {
        serviceData.value = serviceData.volatilityIndex;
      }
      // Add unit and topic defaults if not present
      serviceData.unit = serviceData.unit || '%';
      serviceData.topic = serviceData.topic || 'crypto-volatility';
      // Ensure timestamp exists
      serviceData.timestamp = serviceData.timestamp || new Date().toISOString();
    }
    res.status(200).json({
      success: true,
      status: 'OK',
      source: 'Praevisio-Aion-CryptoService',
      timestamp: new Date().toISOString(),
      data: serviceData
    });
  } catch (error) {
    console.error('Error retrieving crypto volatility data:', error);
    res.status(500).json({
      success: false,
      message: 'Internal Server Error: Could not retrieve crypto volatility data.'
    });
  }
});

// GET /api/global-risk/climate-extremes
router.get('/climate-extremes', async (req, res) => {
  try {
    const climateMod = await safeLoad('../services/climateService.js');
    const climateService = getServiceInstance(climateMod) || climateMod;
    const serviceData = typeof climateService.getClimateExtremesIndex === 'function' ? await climateService.getClimateExtremesIndex() : await (climateService.getClimateExtremesIndex || climateService);
    res.status(200).json({
      success: true,
      source: 'Praevisio-Aion-NASA-POWER-Integration',
      timestamp: new Date().toISOString(),
      data: serviceData
    });
  } catch (error) {
    console.error('Error retrieving climate extremes data:', error);
    res.status(500).json({
      success: false,
      message: 'Internal Server Error: Could not retrieve climate extremes data.'
    });
  }
});

// GET /api/global-risk/community-resilience
router.get('/community-resilience', async (req, res) => {
  try {
    const {
      countries = 'COL,PER,ARG',
      days = 30
    } = req.query;
    const countryList = Array.isArray(countries) ? countries : countries.split(',').map(c => c.trim()).filter(Boolean);
    const communityMod = await safeLoad('../services/communityResilienceService.js');
    const communityService = getServiceInstance(communityMod) || communityMod;
    const serviceData = typeof communityService.getCommunityResilienceIndex === 'function' ? await communityService.getCommunityResilienceIndex(countryList, Number(days)) : await (communityService.getCommunityResilienceIndex || communityService)(countryList, Number(days));

    // Build a normalized metric value: 100 - averageResilience
    const avg = serviceData?.globalResilienceAssessment?.averageResilience;
    const value = typeof avg === 'number' ? Math.round(100 - avg) : undefined;
    const data = {
      timestamp: serviceData?.timestamp || new Date().toISOString(),
      topic: 'community-resilience',
      unit: '%',
      value,
      resilienceAnalysis: serviceData?.resilienceAnalysis || {},
      globalResilienceAssessment: serviceData?.globalResilienceAssessment || {}
    };
    res.status(200).json({
      success: true,
      status: 'OK',
      source: 'Praevisio-Aion-CommunityResilienceAgent',
      timestamp: new Date().toISOString(),
      data
    });
  } catch (error) {
    console.error('Error retrieving community resilience data:', error);
    res.status(500).json({
      success: false,
      message: 'Internal Server Error: Could not retrieve community resilience data.'
    });
  }
});

/**
 * @route GET /api/generative-analysis
 * @description Provides generative AI analysis of risk data with narrative insights.
 * @access Public
 */
router.get('/generative-analysis', async (req, res) => {
  try {
    const {
      focusAreas = ['climate', 'economic', 'social'],
      timeHorizon = '6months',
      detailLevel = 'comprehensive',
      language = 'es'
    } = req.query;
    const predictionMod = await safeLoad('../services/predictionEngine.js');
    const predictionService = getServiceInstance(predictionMod) || predictionMod;
    const riskData = typeof predictionService.getRiskIndices === 'function' ? await predictionService.getRiskIndices() : await (predictionService.getRiskIndices || predictionService);
    const genMod = await safeLoad('../services/generativeAIService.js');
    const genService = getServiceInstance(genMod) || genMod;
    const options = {
      focusAreas: Array.isArray(focusAreas) ? focusAreas : focusAreas.split(',').map(a => a.trim()),
      timeHorizon,
      detailLevel,
      language
    };
    const narrative = typeof genService.generatePredictiveNarrative === 'function' ? await genService.generatePredictiveNarrative(riskData, options) : await (genService.generatePredictiveNarrative || genService)(riskData, options);
    res.status(200).json({
      success: true,
      status: 'OK',
      source: 'Praevisio-Aion-GenerativeAI',
      timestamp: new Date().toISOString(),
      data: narrative
    });
  } catch (error) {
    console.error('Error generating AI analysis:', error);
    res.status(500).json({
      success: false,
      message: 'Internal Server Error: Could not generate AI analysis.'
    });
  }
});
var _default = exports.default = router;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfZXhwcmVzcyIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJyZXF1aXJlIiwiX3BhdGgiLCJlIiwiX19lc01vZHVsZSIsImRlZmF1bHQiLCJfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCIsInQiLCJXZWFrTWFwIiwiciIsIm4iLCJvIiwiaSIsImYiLCJfX3Byb3RvX18iLCJoYXMiLCJnZXQiLCJzZXQiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIl9fZGlybmFtZSIsInBhdGgiLCJyZXNvbHZlIiwicHJvY2VzcyIsImN3ZCIsInJvdXRlciIsImV4cHJlc3MiLCJSb3V0ZXIiLCJzYWZlTG9hZCIsIm1vZHVsZVBhdGgiLCJmdWxsUGF0aCIsInRhcmdldEJhc2VuYW1lIiwiYmFzZW5hbWUiLCJjYWNoZUtleXMiLCJrZXlzIiwiY2FjaGUiLCJtYXRjaEtleSIsImZpbmQiLCJrIiwiZW5kc1dpdGgiLCJqb2luIiwiY2FjaGVkIiwiY2FjaGVFcnIiLCJtb2RCeUlkIiwicmVzb2x2ZWQiLCJtb2QiLCJyZXFFcnIiLCJzcGVjaWZpZXIiLCJQcm9taXNlIiwidGhlbiIsInMiLCJpbXBvcnRFcnIiLCJjb25zb2xlIiwiZXJyb3IiLCJFcnJvciIsImdldFNlcnZpY2VJbnN0YW5jZSIsImVyciIsInJlcSIsInJlcyIsImZvb2RNb2QiLCJmb29kU2VydmljZSIsImRhdGEiLCJnZXRGb29kU2VjdXJpdHlJbmRleCIsInN0YXR1cyIsImpzb24iLCJzdWNjZXNzIiwic291cmNlIiwibWVzc2FnZSIsImNyeXB0b0lkcyIsInF1ZXJ5IiwiY3J5cHRvTGlzdCIsInNwbGl0IiwibWFwIiwiaWQiLCJ0cmltIiwiY3J5cHRvTW9kIiwiY3J5cHRvU2VydmljZSIsInNlcnZpY2VEYXRhIiwiZ2V0Q3J5cHRvTWFya2V0QW5hbHlzaXMiLCJ2b2xhdGlsaXR5SW5kZXgiLCJ1bmRlZmluZWQiLCJ2YWx1ZSIsInVuaXQiLCJ0b3BpYyIsInRpbWVzdGFtcCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsImNsaW1hdGVNb2QiLCJjbGltYXRlU2VydmljZSIsImdldENsaW1hdGVFeHRyZW1lc0luZGV4IiwiY291bnRyaWVzIiwiZGF5cyIsImNvdW50cnlMaXN0IiwiQXJyYXkiLCJpc0FycmF5IiwiYyIsImZpbHRlciIsIkJvb2xlYW4iLCJjb21tdW5pdHlNb2QiLCJjb21tdW5pdHlTZXJ2aWNlIiwiZ2V0Q29tbXVuaXR5UmVzaWxpZW5jZUluZGV4IiwiTnVtYmVyIiwiYXZnIiwiZ2xvYmFsUmVzaWxpZW5jZUFzc2Vzc21lbnQiLCJhdmVyYWdlUmVzaWxpZW5jZSIsIk1hdGgiLCJyb3VuZCIsInJlc2lsaWVuY2VBbmFseXNpcyIsImZvY3VzQXJlYXMiLCJ0aW1lSG9yaXpvbiIsImRldGFpbExldmVsIiwibGFuZ3VhZ2UiLCJwcmVkaWN0aW9uTW9kIiwicHJlZGljdGlvblNlcnZpY2UiLCJyaXNrRGF0YSIsImdldFJpc2tJbmRpY2VzIiwiZ2VuTW9kIiwiZ2VuU2VydmljZSIsIm9wdGlvbnMiLCJhIiwibmFycmF0aXZlIiwiZ2VuZXJhdGVQcmVkaWN0aXZlTmFycmF0aXZlIiwiX2RlZmF1bHQiLCJleHBvcnRzIl0sInNvdXJjZXMiOlsiZ2xvYmFsUmlza1JvdXRlcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZXhwcmVzcyBmcm9tICdleHByZXNzJztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuLy8gU3RhdGljIGltcG9ydHMgc28gSmVzdCBjYW4gbW9jayB0aGVzZSBtb2R1bGVzIHJlbGlhYmx5IGluIHRlc3RzXG4vLyBTZXJ2aWNlcyBhcmUgbG9hZGVkIGR5bmFtaWNhbGx5IHZpYSBzYWZlTG9hZCB0byBlbnN1cmUgdGVzdHMgY2FuIG1vY2sgdGhlbVxuLy8gYXQgcnVudGltZSAodGVzdHMgbWF5IGNhbGwgamVzdC5tb2NrIGFmdGVyIGltcG9ydGluZyB0aGlzIG1vZHVsZSkuXG5cbi8vIFJlc29sdmUgYSBzdGFibGUgX19kaXJuYW1lIGZvciB0aGlzIG1vZHVsZSBpbiBib3RoIEVTTSBhbmQgQ29tbW9uSlNcbi8vIHRlc3QgZW52aXJvbm1lbnRzLiBTb21lIHRlc3QgcnVubmVycyAoSmVzdCArIGJhYmVsLWplc3QpIG1heSBub3Rcbi8vIHN1cHBvcnQgYGltcG9ydC5tZXRhLnVybGAgZHVyaW5nIHRyYW5zZm9ybWF0aW9uLCB3aGljaCBjYXVzZXNcbi8vIFwiQ2Fubm90IHVzZSAnaW1wb3J0Lm1ldGEnIG91dHNpZGUgYSBtb2R1bGVcIiBlcnJvcnMuIFRvIGF2b2lkIHRoYXRcbi8vIGFuZCBrZWVwIG1vZHVsZSByZXNvbHV0aW9uIGRldGVybWluaXN0aWMsIHVzZSB0aGUgcmVwb3NpdG9yeSdzXG4vLyBgc3JjL3JvdXRlc2AgZm9sZGVyIGFzIGJhc2Ugd2hlbiBpbXBvcnQubWV0YSBpcyB1bmF2YWlsYWJsZS5cbmNvbnN0IF9fZGlybmFtZSA9IHBhdGgucmVzb2x2ZShwcm9jZXNzLmN3ZCgpLCAnc3JjJywgJ3JvdXRlcycpO1xuY29uc3Qgcm91dGVyID0gZXhwcmVzcy5Sb3V0ZXIoKTtcblxuLy8gSGVscGVyIHRvIGR5bmFtaWNhbGx5IGxvYWQgYSBtb2R1bGUuXG4vLyBQcmVmZXIgQ29tbW9uSlMgYHJlcXVpcmVgIHdoZW4gYXZhaWxhYmxlIHNvIEplc3QncyBtb2R1bGUgbW9ja3MgKHdoaWNoXG4vLyBjb21tb25seSBwYXRjaCBgcmVxdWlyZWApIGFyZSBhcHBsaWVkLiBGYWxsYmFjayB0byBkeW5hbWljIGltcG9ydCBmb3Jcbi8vIHRydWUgRVNNIG1vZHVsZXMgb3Igd2hlbiByZXF1aXJlIGlzbid0IGF2YWlsYWJsZS5cbmFzeW5jIGZ1bmN0aW9uIHNhZmVMb2FkKG1vZHVsZVBhdGgpIHtcbiAgY29uc3QgZnVsbFBhdGggPSBwYXRoLnJlc29sdmUoX19kaXJuYW1lLCBtb2R1bGVQYXRoKTtcbiAgLy8gVHJ5IHJlcXVpcmUgZmlyc3QgZm9yIGJldHRlciBjb21wYXRpYmlsaXR5IHdpdGggSmVzdCBtb2Nrc1xuICB0cnkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBnbG9iYWwtcmVxdWlyZSwgaW1wb3J0L25vLWR5bmFtaWMtcmVxdWlyZVxuICAgIGlmICh0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gVHJ5IHRvIGZpbmQgYSBjYWNoZWQgbW9kdWxlIHRoYXQgbWF0Y2hlcyB0aGUgc2VydmljZSBmaWxlbmFtZS5cbiAgICAgIC8vIEplc3QgbWF5IHJlZ2lzdGVyIG1vY2tzIHVuZGVyIGFic29sdXRlIHBhdGhzOyBzZWFyY2hpbmcgdGhlXG4gICAgICAvLyByZXF1aXJlLmNhY2hlIGZvciBhIGZpbGVuYW1lIHN1ZmZpeCBsaWtlICcvc3JjL3NlcnZpY2VzL2NyeXB0b1NlcnZpY2UuanMnXG4gICAgICAvLyBvZnRlbiBmaW5kcyB0aGUgbW9ja2VkIG1vZHVsZSBzbyB0ZXN0cycgbW9ja3MgYXJlIGhvbm9yZWQuXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB0YXJnZXRCYXNlbmFtZSA9IHBhdGguYmFzZW5hbWUobW9kdWxlUGF0aCk7XG4gICAgICAgIGNvbnN0IGNhY2hlS2V5cyA9IE9iamVjdC5rZXlzKHJlcXVpcmUuY2FjaGUgfHwge30pO1xuICAgICAgICBjb25zdCBtYXRjaEtleSA9IGNhY2hlS2V5cy5maW5kKGsgPT4gay5lbmRzV2l0aChwYXRoLmpvaW4oJ3NyYycsICdzZXJ2aWNlcycsIHRhcmdldEJhc2VuYW1lKSkpO1xuICAgICAgICBpZiAobWF0Y2hLZXkpIHtcbiAgICAgICAgICBjb25zdCBjYWNoZWQgPSByZXF1aXJlKG1hdGNoS2V5KTtcbiAgICAgICAgICByZXR1cm4gY2FjaGVkICYmIGNhY2hlZC5fX2VzTW9kdWxlID8gY2FjaGVkLmRlZmF1bHQgfHwgY2FjaGVkIDogY2FjaGVkO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChjYWNoZUVycikge1xuICAgICAgICAvLyBpZ25vcmUgYW5kIGNvbnRpbnVlIHRvIG5vcm1hbCByZXF1aXJlIGZsb3dcbiAgICAgIH1cbiAgICAgIC8vIFRyeSByZXF1aXJpbmcgYnkgdGhlIG9yaWdpbmFsIG1vZHVsZSBwYXRoIGZpcnN0IHNvIEplc3QncyBtb2R1bGVcbiAgICAgIC8vIG1vY2tpbmcgKHdoaWNoIHVzZXMgdGhlIG1vZHVsZSBpZCBhcyBkZWNsYXJlZCBpbiB0ZXN0cykgaXMgYXBwbGllZC5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG1vZEJ5SWQgPSByZXF1aXJlKG1vZHVsZVBhdGgpO1xuICAgICAgICByZXR1cm4gbW9kQnlJZCAmJiBtb2RCeUlkLl9fZXNNb2R1bGUgPyBtb2RCeUlkLmRlZmF1bHQgfHwgbW9kQnlJZCA6IG1vZEJ5SWQ7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIElmIHRoYXQgZmFpbHMsIGZhbGwgYmFjayB0byBhYnNvbHV0ZSByZXNvbHV0aW9uXG4gICAgICB9XG4gICAgICBjb25zdCByZXNvbHZlZCA9IHJlcXVpcmUucmVzb2x2ZShmdWxsUGF0aCk7XG4gICAgICBjb25zdCBtb2QgPSByZXF1aXJlKHJlc29sdmVkKTtcbiAgICAgIHJldHVybiBtb2QgJiYgbW9kLl9fZXNNb2R1bGUgPyBtb2QuZGVmYXVsdCB8fCBtb2QgOiBtb2Q7XG4gICAgfVxuICB9IGNhdGNoIChyZXFFcnIpIHtcbiAgICAvLyBOb3QgZmF0YWw6IGZhbGwgdGhyb3VnaCB0byBkeW5hbWljIGltcG9ydFxuICAgIC8vIGNvbnNvbGUuZGVidWcoYHNhZmVMb2FkIHJlcXVpcmUgZmFpbGVkIGZvciAke21vZHVsZVBhdGh9OmAsIHJlcUVyci5tZXNzYWdlKTtcbiAgfVxuXG4gIC8vIER5bmFtaWMgaW1wb3J0IGZhbGxiYWNrIChmb3IgRVNNLW9ubHkgbW9kdWxlcylcbiAgdHJ5IHtcbiAgICBjb25zdCBtb2QgPSBhd2FpdCBpbXBvcnQoZnVsbFBhdGgpO1xuICAgIHJldHVybiBtb2QgJiYgbW9kLmRlZmF1bHQgPyBtb2QuZGVmYXVsdCA6IG1vZDtcbiAgfSBjYXRjaCAoaW1wb3J0RXJyKSB7XG4gICAgY29uc29sZS5lcnJvcihgRXJyb3IgbG9hZGluZyBtb2R1bGUgJHttb2R1bGVQYXRofSB2aWEgaW1wb3J0KCk6YCwgaW1wb3J0RXJyKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBsb2FkIG1vZHVsZTogJHttb2R1bGVQYXRofWApO1xuICB9XG59XG5cbi8vIEhlbHBlcjogZ2l2ZW4gYSBsb2FkZWQgbW9kdWxlLCByZXR1cm4gYSB1c2FibGUgc2VydmljZSBvYmplY3QuXG5mdW5jdGlvbiBnZXRTZXJ2aWNlSW5zdGFuY2UobW9kKSB7XG4gIGlmICghbW9kKSByZXR1cm4gbnVsbDtcbiAgLy8gSWYgbW9kdWxlIGlzIGEgY29uc3RydWN0b3IgKGNsYXNzIG9yIGZ1bmN0aW9uKSwgaW5zdGFudGlhdGUgaXQuXG4gIGlmICh0eXBlb2YgbW9kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBuZXcgbW9kKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gSWYgaXQncyBhIGZhY3RvcnkgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIG9iamVjdCB3aGVuIGNhbGxlZFxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG1vZCgpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiBtb2Q7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIElmIG1vZHVsZSBpcyBhbiBvYmplY3Qgd2l0aCBhIGRlZmF1bHQgY2xhc3MsIGluc3RhbnRpYXRlIGRlZmF1bHRcbiAgaWYgKG1vZCAmJiB0eXBlb2YgbW9kID09PSAnb2JqZWN0JyAmJiBtb2QuZGVmYXVsdCAmJiB0eXBlb2YgbW9kLmRlZmF1bHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG5ldyBtb2QuZGVmYXVsdCgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBtb2QuZGVmYXVsdCgpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiBtb2QuZGVmYXVsdCB8fCBtb2Q7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIE90aGVyd2lzZSByZXR1cm4gdGhlIG1vZHVsZSBhcy1pcyAoaXQgbWF5IGJlIGFuIG9iamVjdCBvZiBmdW5jdGlvbnMpXG4gIHJldHVybiBtb2Q7XG59XG5cbi8vIEdFVCAvYXBpL2dsb2JhbC1yaXNrL2Zvb2Qtc2VjdXJpdHkgXG5yb3V0ZXIuZ2V0KCcvZm9vZC1zZWN1cml0eScsIGFzeW5jIChyZXEsIHJlcykgPT4ge1xuICB0cnkge1xuICAgIC8vIFVzZSB0aGUgc3RhdGljYWxseSBpbXBvcnRlZCBtb2R1bGUgKHRlc3RzIG1vY2sgdGhpcyBtb2R1bGUpXG4gICAgY29uc3QgZm9vZE1vZCA9IGF3YWl0IHNhZmVMb2FkKCcuLi9zZXJ2aWNlcy93b3JsZEJhbmtTZXJ2aWNlLmpzJyk7XG4gICAgY29uc3QgZm9vZFNlcnZpY2UgPSBnZXRTZXJ2aWNlSW5zdGFuY2UoZm9vZE1vZCkgfHwgZm9vZE1vZDtcbiAgICBjb25zdCBkYXRhID0gdHlwZW9mIGZvb2RTZXJ2aWNlLmdldEZvb2RTZWN1cml0eUluZGV4ID09PSAnZnVuY3Rpb24nXG4gICAgICA/IGF3YWl0IGZvb2RTZXJ2aWNlLmdldEZvb2RTZWN1cml0eUluZGV4KClcbiAgICAgIDogYXdhaXQgKGZvb2RTZXJ2aWNlLmdldEZvb2RTZWN1cml0eUluZGV4IHx8IGZvb2RTZXJ2aWNlKTtcbiAgICBcbiAgICByZXMuc3RhdHVzKDIwMCkuanNvbih7XG4gICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgc291cmNlOiAnUHJhZXZpc2lvLUFpb24tU2ltdWxhdGVkLVdvcmxkQmFuaycsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgcmV0cmlldmluZyBmb29kIHNlY3VyaXR5IGRhdGE6JywgZXJyb3IpO1xuICAgIHJlcy5zdGF0dXMoNTAwKS5qc29uKHtcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgbWVzc2FnZTogJ0ludGVybmFsIFNlcnZlciBFcnJvcjogQ291bGQgbm90IHJldHJpZXZlIGZvb2Qgc2VjdXJpdHkgZGF0YS4nXG4gICAgfSk7XG4gIH1cbn0pO1xuXG4vLyBHRVQgL2FwaS9nbG9iYWwtcmlzay9jcnlwdG8tdm9sYXRpbGl0eVxucm91dGVyLmdldCgnL2NyeXB0by12b2xhdGlsaXR5JywgYXN5bmMgKHJlcSwgcmVzKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgeyBjcnlwdG9JZHMgPSAnYml0Y29pbixldGhlcmV1bScgfSA9IHJlcS5xdWVyeTtcbiAgICBjb25zdCBjcnlwdG9MaXN0ID0gY3J5cHRvSWRzLnNwbGl0KCcsJykubWFwKGlkID0+IGlkLnRyaW0oKSk7XG4gICAgLy8gVXNlIHN0YXRpY2FsbHkgaW1wb3J0ZWQgY3J5cHRvIG1vZHVsZSBzbyBKZXN0J3MgbW9ja0ltcGxlbWVudGF0aW9uIGlzIHVzZWRcbiAgICBjb25zdCBjcnlwdG9Nb2QgPSBhd2FpdCBzYWZlTG9hZCgnLi4vc2VydmljZXMvY3J5cHRvU2VydmljZS5qcycpO1xuICAgIGNvbnN0IGNyeXB0b1NlcnZpY2UgPSBnZXRTZXJ2aWNlSW5zdGFuY2UoY3J5cHRvTW9kKSB8fCBjcnlwdG9Nb2Q7XG4gICAgY29uc3Qgc2VydmljZURhdGEgPSB0eXBlb2YgY3J5cHRvU2VydmljZS5nZXRDcnlwdG9NYXJrZXRBbmFseXNpcyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgPyBhd2FpdCBjcnlwdG9TZXJ2aWNlLmdldENyeXB0b01hcmtldEFuYWx5c2lzKGNyeXB0b0xpc3QpXG4gICAgICA6IGF3YWl0IChjcnlwdG9TZXJ2aWNlLmdldENyeXB0b01hcmtldEFuYWx5c2lzIHx8IGNyeXB0b1NlcnZpY2UpKGNyeXB0b0xpc3QpO1xuXG4gICAgLy8gTm9ybWFsaXplL2F1Z21lbnQgcmV0dXJuZWQgc2VydmljZSBkYXRhIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gICAgaWYgKHNlcnZpY2VEYXRhICYmIHR5cGVvZiBzZXJ2aWNlRGF0YSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIC8vIElmIHRoZSBzZXJ2aWNlIHByb3ZpZGVzIGEgdm9sYXRpbGl0eUluZGV4LCBleHBvc2UgaXQgYXMgYHZhbHVlYCB0byBtYXRjaCB0ZXN0c1xuICAgICAgaWYgKHNlcnZpY2VEYXRhLnZvbGF0aWxpdHlJbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHNlcnZpY2VEYXRhLnZhbHVlID0gc2VydmljZURhdGEudm9sYXRpbGl0eUluZGV4O1xuICAgICAgfVxuICAgICAgLy8gQWRkIHVuaXQgYW5kIHRvcGljIGRlZmF1bHRzIGlmIG5vdCBwcmVzZW50XG4gICAgICBzZXJ2aWNlRGF0YS51bml0ID0gc2VydmljZURhdGEudW5pdCB8fCAnJSc7XG4gICAgICBzZXJ2aWNlRGF0YS50b3BpYyA9IHNlcnZpY2VEYXRhLnRvcGljIHx8ICdjcnlwdG8tdm9sYXRpbGl0eSc7XG4gICAgICAvLyBFbnN1cmUgdGltZXN0YW1wIGV4aXN0c1xuICAgICAgc2VydmljZURhdGEudGltZXN0YW1wID0gc2VydmljZURhdGEudGltZXN0YW1wIHx8IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICB9XG5cbiAgICByZXMuc3RhdHVzKDIwMCkuanNvbih7XG4gICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgc3RhdHVzOiAnT0snLFxuICAgICAgc291cmNlOiAnUHJhZXZpc2lvLUFpb24tQ3J5cHRvU2VydmljZScsXG4gICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIGRhdGE6IHNlcnZpY2VEYXRhXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgcmV0cmlldmluZyBjcnlwdG8gdm9sYXRpbGl0eSBkYXRhOicsIGVycm9yKTtcbiAgICByZXMuc3RhdHVzKDUwMCkuanNvbih7XG4gICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgIG1lc3NhZ2U6ICdJbnRlcm5hbCBTZXJ2ZXIgRXJyb3I6IENvdWxkIG5vdCByZXRyaWV2ZSBjcnlwdG8gdm9sYXRpbGl0eSBkYXRhLidcbiAgICB9KTtcbiAgfVxufSk7XG5cbi8vIEdFVCAvYXBpL2dsb2JhbC1yaXNrL2NsaW1hdGUtZXh0cmVtZXNcbnJvdXRlci5nZXQoJy9jbGltYXRlLWV4dHJlbWVzJywgYXN5bmMgKHJlcSwgcmVzKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgY2xpbWF0ZU1vZCA9IGF3YWl0IHNhZmVMb2FkKCcuLi9zZXJ2aWNlcy9jbGltYXRlU2VydmljZS5qcycpO1xuICAgIGNvbnN0IGNsaW1hdGVTZXJ2aWNlID0gZ2V0U2VydmljZUluc3RhbmNlKGNsaW1hdGVNb2QpIHx8IGNsaW1hdGVNb2Q7XG4gICAgY29uc3Qgc2VydmljZURhdGEgPSB0eXBlb2YgY2xpbWF0ZVNlcnZpY2UuZ2V0Q2xpbWF0ZUV4dHJlbWVzSW5kZXggPT09ICdmdW5jdGlvbidcbiAgICAgID8gYXdhaXQgY2xpbWF0ZVNlcnZpY2UuZ2V0Q2xpbWF0ZUV4dHJlbWVzSW5kZXgoKVxuICAgICAgOiBhd2FpdCAoY2xpbWF0ZVNlcnZpY2UuZ2V0Q2xpbWF0ZUV4dHJlbWVzSW5kZXggfHwgY2xpbWF0ZVNlcnZpY2UpO1xuXG4gICAgcmVzLnN0YXR1cygyMDApLmpzb24oe1xuICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgIHNvdXJjZTogJ1ByYWV2aXNpby1BaW9uLU5BU0EtUE9XRVItSW50ZWdyYXRpb24nLFxuICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICBkYXRhOiBzZXJ2aWNlRGF0YVxuICAgIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJldHJpZXZpbmcgY2xpbWF0ZSBleHRyZW1lcyBkYXRhOicsIGVycm9yKTtcbiAgICByZXMuc3RhdHVzKDUwMCkuanNvbih7XG4gICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgIG1lc3NhZ2U6ICdJbnRlcm5hbCBTZXJ2ZXIgRXJyb3I6IENvdWxkIG5vdCByZXRyaWV2ZSBjbGltYXRlIGV4dHJlbWVzIGRhdGEuJ1xuICAgIH0pO1xuICB9XG59KTtcblxuLy8gR0VUIC9hcGkvZ2xvYmFsLXJpc2svY29tbXVuaXR5LXJlc2lsaWVuY2VcbnJvdXRlci5nZXQoJy9jb21tdW5pdHktcmVzaWxpZW5jZScsIGFzeW5jIChyZXEsIHJlcykgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHsgY291bnRyaWVzID0gJ0NPTCxQRVIsQVJHJywgZGF5cyA9IDMwIH0gPSByZXEucXVlcnk7XG4gICAgY29uc3QgY291bnRyeUxpc3QgPSBBcnJheS5pc0FycmF5KGNvdW50cmllcykgPyBjb3VudHJpZXMgOiBjb3VudHJpZXMuc3BsaXQoJywnKS5tYXAoYyA9PiBjLnRyaW0oKSkuZmlsdGVyKEJvb2xlYW4pO1xuXG4gICAgY29uc3QgY29tbXVuaXR5TW9kID0gYXdhaXQgc2FmZUxvYWQoJy4uL3NlcnZpY2VzL2NvbW11bml0eVJlc2lsaWVuY2VTZXJ2aWNlLmpzJyk7XG4gICAgY29uc3QgY29tbXVuaXR5U2VydmljZSA9IGdldFNlcnZpY2VJbnN0YW5jZShjb21tdW5pdHlNb2QpIHx8IGNvbW11bml0eU1vZDtcbiAgICBjb25zdCBzZXJ2aWNlRGF0YSA9IHR5cGVvZiBjb21tdW5pdHlTZXJ2aWNlLmdldENvbW11bml0eVJlc2lsaWVuY2VJbmRleCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgPyBhd2FpdCBjb21tdW5pdHlTZXJ2aWNlLmdldENvbW11bml0eVJlc2lsaWVuY2VJbmRleChjb3VudHJ5TGlzdCwgTnVtYmVyKGRheXMpKVxuICAgICAgOiBhd2FpdCAoY29tbXVuaXR5U2VydmljZS5nZXRDb21tdW5pdHlSZXNpbGllbmNlSW5kZXggfHwgY29tbXVuaXR5U2VydmljZSkoY291bnRyeUxpc3QsIE51bWJlcihkYXlzKSk7XG5cbiAgICAvLyBCdWlsZCBhIG5vcm1hbGl6ZWQgbWV0cmljIHZhbHVlOiAxMDAgLSBhdmVyYWdlUmVzaWxpZW5jZVxuICAgIGNvbnN0IGF2ZyA9IHNlcnZpY2VEYXRhPy5nbG9iYWxSZXNpbGllbmNlQXNzZXNzbWVudD8uYXZlcmFnZVJlc2lsaWVuY2U7XG4gICAgY29uc3QgdmFsdWUgPSB0eXBlb2YgYXZnID09PSAnbnVtYmVyJyA/IE1hdGgucm91bmQoMTAwIC0gYXZnKSA6IHVuZGVmaW5lZDtcblxuICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICB0aW1lc3RhbXA6IHNlcnZpY2VEYXRhPy50aW1lc3RhbXAgfHwgbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgdG9waWM6ICdjb21tdW5pdHktcmVzaWxpZW5jZScsXG4gICAgICB1bml0OiAnJScsXG4gICAgICB2YWx1ZSxcbiAgICAgIHJlc2lsaWVuY2VBbmFseXNpczogc2VydmljZURhdGE/LnJlc2lsaWVuY2VBbmFseXNpcyB8fCB7fSxcbiAgICAgIGdsb2JhbFJlc2lsaWVuY2VBc3Nlc3NtZW50OiBzZXJ2aWNlRGF0YT8uZ2xvYmFsUmVzaWxpZW5jZUFzc2Vzc21lbnQgfHwge31cbiAgICB9O1xuXG4gICAgcmVzLnN0YXR1cygyMDApLmpzb24oe1xuICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgIHN0YXR1czogJ09LJyxcbiAgICAgIHNvdXJjZTogJ1ByYWV2aXNpby1BaW9uLUNvbW11bml0eVJlc2lsaWVuY2VBZ2VudCcsXG4gICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZXRyaWV2aW5nIGNvbW11bml0eSByZXNpbGllbmNlIGRhdGE6JywgZXJyb3IpO1xuICAgIHJlcy5zdGF0dXMoNTAwKS5qc29uKHtcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgbWVzc2FnZTogJ0ludGVybmFsIFNlcnZlciBFcnJvcjogQ291bGQgbm90IHJldHJpZXZlIGNvbW11bml0eSByZXNpbGllbmNlIGRhdGEuJ1xuICAgIH0pO1xuICB9XG59KTtcblxuLyoqXG4gKiBAcm91dGUgR0VUIC9hcGkvZ2VuZXJhdGl2ZS1hbmFseXNpc1xuICogQGRlc2NyaXB0aW9uIFByb3ZpZGVzIGdlbmVyYXRpdmUgQUkgYW5hbHlzaXMgb2YgcmlzayBkYXRhIHdpdGggbmFycmF0aXZlIGluc2lnaHRzLlxuICogQGFjY2VzcyBQdWJsaWNcbiAqL1xucm91dGVyLmdldCgnL2dlbmVyYXRpdmUtYW5hbHlzaXMnLCBhc3luYyAocmVxLCByZXMpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCB7IGZvY3VzQXJlYXMgPSBbJ2NsaW1hdGUnLCAnZWNvbm9taWMnLCAnc29jaWFsJ10sIHRpbWVIb3Jpem9uID0gJzZtb250aHMnLCBkZXRhaWxMZXZlbCA9ICdjb21wcmVoZW5zaXZlJywgbGFuZ3VhZ2UgPSAnZXMnIH0gPSByZXEucXVlcnk7XG5cbiAgICBjb25zdCBwcmVkaWN0aW9uTW9kID0gYXdhaXQgc2FmZUxvYWQoJy4uL3NlcnZpY2VzL3ByZWRpY3Rpb25FbmdpbmUuanMnKTtcbiAgICBjb25zdCBwcmVkaWN0aW9uU2VydmljZSA9IGdldFNlcnZpY2VJbnN0YW5jZShwcmVkaWN0aW9uTW9kKSB8fCBwcmVkaWN0aW9uTW9kO1xuICAgIGNvbnN0IHJpc2tEYXRhID0gdHlwZW9mIHByZWRpY3Rpb25TZXJ2aWNlLmdldFJpc2tJbmRpY2VzID09PSAnZnVuY3Rpb24nXG4gICAgICA/IGF3YWl0IHByZWRpY3Rpb25TZXJ2aWNlLmdldFJpc2tJbmRpY2VzKClcbiAgICAgIDogYXdhaXQgKHByZWRpY3Rpb25TZXJ2aWNlLmdldFJpc2tJbmRpY2VzIHx8IHByZWRpY3Rpb25TZXJ2aWNlKTtcblxuICAgIGNvbnN0IGdlbk1vZCA9IGF3YWl0IHNhZmVMb2FkKCcuLi9zZXJ2aWNlcy9nZW5lcmF0aXZlQUlTZXJ2aWNlLmpzJyk7XG4gICAgY29uc3QgZ2VuU2VydmljZSA9IGdldFNlcnZpY2VJbnN0YW5jZShnZW5Nb2QpIHx8IGdlbk1vZDtcblxuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBmb2N1c0FyZWFzOiBBcnJheS5pc0FycmF5KGZvY3VzQXJlYXMpID8gZm9jdXNBcmVhcyA6IGZvY3VzQXJlYXMuc3BsaXQoJywnKS5tYXAoYSA9PiBhLnRyaW0oKSksXG4gICAgICB0aW1lSG9yaXpvbixcbiAgICAgIGRldGFpbExldmVsLFxuICAgICAgbGFuZ3VhZ2VcbiAgICB9O1xuXG4gICAgY29uc3QgbmFycmF0aXZlID0gdHlwZW9mIGdlblNlcnZpY2UuZ2VuZXJhdGVQcmVkaWN0aXZlTmFycmF0aXZlID09PSAnZnVuY3Rpb24nXG4gICAgICA/IGF3YWl0IGdlblNlcnZpY2UuZ2VuZXJhdGVQcmVkaWN0aXZlTmFycmF0aXZlKHJpc2tEYXRhLCBvcHRpb25zKVxuICAgICAgOiBhd2FpdCAoZ2VuU2VydmljZS5nZW5lcmF0ZVByZWRpY3RpdmVOYXJyYXRpdmUgfHwgZ2VuU2VydmljZSkocmlza0RhdGEsIG9wdGlvbnMpO1xuXG4gICAgcmVzLnN0YXR1cygyMDApLmpzb24oe1xuICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgIHN0YXR1czogJ09LJyxcbiAgICAgIHNvdXJjZTogJ1ByYWV2aXNpby1BaW9uLUdlbmVyYXRpdmVBSScsXG4gICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIGRhdGE6IG5hcnJhdGl2ZVxuICAgIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdlbmVyYXRpbmcgQUkgYW5hbHlzaXM6JywgZXJyb3IpO1xuICAgIHJlcy5zdGF0dXMoNTAwKS5qc29uKHtcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgbWVzc2FnZTogJ0ludGVybmFsIFNlcnZlciBFcnJvcjogQ291bGQgbm90IGdlbmVyYXRlIEFJIGFuYWx5c2lzLidcbiAgICB9KTtc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RyxPQUFPRCxpQkFBaUIsQ0FBQ0UsY0FBYyxLQUFLLFVBQVUsR0FDbkUsTUFBTUYsaUJBQWlCLENBQUNFLGNBQWMsQ0FBQyxDQUFDLEdBQ3hDLE9BQU9GLGlCQUFpQixDQUFDRSxjQUFjLElBQUlGLGlCQUFpQixDQUFDO0lBRWpFLE1BQU1HLE1BQU0sR0FBRyxNQUFNeEYsUUFBUSxDQUFDLG9DQUFvQyxDQUFDO0lBQ25FLE1BQU15RixVQUFVLEdBQUc5RCxrQkFBa0IsQ0FBQzZELE1BQU0sQ0FBQyxJQUFJQSxNQUFNO0lBRXZELE1BQU1FLE9BQU8sR0FBRztNQUNkVixVQUFVLEVBQUVmLEtBQUssQ0FBQ0MsT0FBTyxDQUFDYyxVQUFVLENBQUMsR0FBR0EsVUFBVSxHQUFHQSxVQUFVLENBQUNyQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUNDLEdBQUcsQ0FBQytDLENBQUMsSUFBSUEsQ0FBQyxDQUFDN0MsSUFBSSxDQUFDLENBQUMsQ0FBQztNQUM3Rm1DLFdBQVc7TUFDWEMsV0FBVztNQUNYQztJQUNGLENBQUM7SUFFRCxNQUFNUyxTQUFTLEdBQUcsT0FBT0gsVUFBVSxDQUFDSSwyQkFBMkIsS0FBSyxVQUFVLEdBQzFFLE1BQU1KLFVBQVUsQ0FBQ0ksMkJBQTJCLENBQUNQLFFBQVEsRUFBRUksT0FBTyxDQUFDLEdBQy9ELE1BQU0sQ0FBQ0QsVUFBVSxDQUFDSSwyQkFBMkIsSUFBSUosVUFBVSxFQUFFSCxRQUFRLEVBQUVJLE9BQU8sQ0FBQztJQUVuRjVELEdBQUcsQ0FBQ0ssTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDQyxJQUFJLENBQUM7TUFDbkJDLE9BQU8sRUFBRSxJQUFJO01BQ2JGLE1BQU0sRUFBRSxJQUFJO01BQ1pHLE1BQU0sRUFBRSw2QkFBNkI7TUFDckNrQixTQUFTLEVBQUUsSUFBSUMsSUFBSSxDQUFDLENBQUMsQ0FBQ0MsV0FBVyxDQUFDLENBQUM7TUFDbkN6QixJQUFJLEVBQUUyRDtJQUNSLENBQUMsQ0FBQztFQUNKLENBQUMsQ0FBQyxPQUFPbkUsS0FBSyxFQUFFO0lBQ2RELE9BQU8sQ0FBQ0MsS0FBSyxDQUFDLCtCQUErQixFQUFFQSxLQUFLLENBQUM7SUFDckRLLEdBQUcsQ0FBQ0ssTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDQyxJQUFJLENBQUM7TUFDbkJDLE9BQU8sRUFBRSxLQUFLO01BQ2RFLE9BQU8sRUFBRTtJQUNYLENBQUMsQ0FBQztFQUNKO0FBQ0YsQ0FBQyxDQUFDO0FBQUMsSUFBQXVELFFBQUEsR0FBQUMsT0FBQSxDQUFBekgsT0FBQSxHQUVZdUIsTUFBTSIsImlnbm9yZUxpc3QiOltdfQ==