77ca048cc7f60bc827d07ca31cbf2911
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _express = _interopRequireDefault(require("express"));
var _path = _interopRequireDefault(require("path"));
var worldBankService = _interopRequireWildcard(require("../services/worldBankService.js"));
var _cryptoService = _interopRequireDefault(require("../services/cryptoService.js"));
var climateServiceModule = _interopRequireWildcard(require("../services/climateService.js"));
var communityResilienceServiceModule = _interopRequireWildcard(require("../services/communityResilienceService.js"));
var predictionEngineModule = _interopRequireWildcard(require("../services/predictionEngine.js"));
var generativeAIServiceModule = _interopRequireWildcard(require("../services/generativeAIService.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); } // Static imports for core services so Jest's jest.mock(...) calls
// (used in tests) are applied reliably. Keep safeLoad as a fallback
// for any less-common or ESM-only modules.
// Resolve a stable __dirname for this module in both ESM and CommonJS
// test environments. Some test runners (Jest + babel-jest) may not
// support `import.meta.url` during transformation, which causes
// "Cannot use 'import.meta' outside a module" errors. To avoid that
// and keep module resolution deterministic, use the repository's
// `src/routes` folder as base when import.meta is unavailable.
const _dirname = _path.default.resolve(process.cwd(), 'src', 'routes');
const router = _express.default.Router();

// Helper to dynamically load a module.
// Prefer CommonJS `require` when available so Jest's module mocks (which
// commonly patch `require`) are applied. Fallback to dynamic import for
// true ESM modules or when require isn't available.
async function safeLoad(modulePath) {
  const fullPath = _path.default.resolve(_dirname, modulePath);
  // Try require first for better compatibility with Jest mocks
  try {
    // eslint-disable-next-line global-require, import/no-dynamic-require
    if (typeof require === 'function') {
      // Try to find a cached module that matches the service filename.
      // Jest may register mocks under absolute paths; searching the
      // require.cache for a filename suffix like '/src/services/cryptoService.js'
      // often finds the mocked module so tests' mocks are honored.
      try {
        const targetBasename = _path.default.basename(modulePath);
        const cacheKeys = Object.keys(require.cache || {});
        const matchKey = cacheKeys.find(k => k.endsWith(_path.default.join('src', 'services', targetBasename)));
        if (matchKey) {
          const cached = require(matchKey);
          return cached && cached.__esModule ? cached.default || cached : cached;
        }
      } catch (cacheErr) {
        // ignore and continue to normal require flow
      }
      // Try requiring by several candidate ids so Jest's mocks (which may
      // be registered under different module ids) are discovered.
      const candidates = [];
      // original relative id as used in safeLoad call
      candidates.push(modulePath);
      // absolute filesystem path to module
      candidates.push(fullPath);
      // project-based services path (common in tests that use ../../src/...)
      try {
        const svcBasename = _path.default.basename(modulePath);
        candidates.push(_path.default.resolve(process.cwd(), 'src', 'services', svcBasename));
      } catch (e) {
        // ignore
      }
      for (const cand of candidates) {
        try {
          const modById = require(cand);
          return modById && modById.__esModule ? modById.default || modById : modById;
        } catch (e) {
          // try next candidate
        }
      }

      // As a last attempt, resolve the full absolute path and require that
      const resolved = require.resolve(fullPath);
      const mod = require(resolved);
      return mod && mod.__esModule ? mod.default || mod : mod;
    }
  } catch (reqErr) {
    // Not fatal: fall through to dynamic import
    // console.debug(`safeLoad require failed for ${modulePath}:`, reqErr.message);
  }

  // Dynamic import fallback (for ESM-only modules)
  try {
    const mod = await (specifier => new Promise(r => r(`${specifier}`)).then(s => _interopRequireWildcard(require(s))))(fullPath);
    return mod && mod.default ? mod.default : mod;
  } catch (importErr) {
    console.error(`Error loading module ${modulePath} via import():`, importErr);
    throw new Error(`Failed to load module: ${modulePath}`);
  }
}

// Helper: given a loaded module, return a usable service object.
function getServiceInstance(mod) {
  if (!mod) return null;
  // If module is a constructor (class or function), instantiate it.
  if (typeof mod === 'function') {
    try {
      return new mod();
    } catch (e) {
      // If it's a factory function that returns an object when called
      try {
        return mod();
      } catch (err) {
        return mod;
      }
    }
  }
  // If module is an object with a default class, instantiate default
  if (mod && typeof mod === 'object' && mod.default && typeof mod.default === 'function') {
    try {
      return new mod.default();
    } catch (e) {
      try {
        return mod.default();
      } catch (err) {
        return mod.default || mod;
      }
    }
  }
  // Otherwise return the module as-is (it may be an object of functions)
  return mod;
}

// GET /api/global-risk/food-security 
router.get('/food-security', async (req, res) => {
  try {
    // Use the statically imported module (tests mock this module)
    // Use statically imported worldBankService (tests mock this module)
    const foodService = getServiceInstance(worldBankService) || worldBankService;
    const data = typeof foodService.getFoodSecurityIndex === 'function' ? await foodService.getFoodSecurityIndex() : await (foodService.getFoodSecurityIndex || foodService);
    res.status(200).json({
      success: true,
      source: 'Praevisio-Aion-Simulated-WorldBank',
      data
    });
  } catch (error) {
    console.error('Error retrieving food security data:', error);
    res.status(500).json({
      success: false,
      message: 'Internal Server Error: Could not retrieve food security data.'
    });
  }
});

// GET /api/global-risk/crypto-volatility
router.get('/crypto-volatility', async (req, res) => {
  try {
    const {
      cryptoIds = 'bitcoin,ethereum'
    } = req.query;
    const cryptoList = cryptoIds.split(',').map(id => id.trim());
    // Use statically imported crypto module so Jest's mockImplementation is used
    // Use statically imported CryptoService module (tests mock its constructor)
    const cryptoSvcCandidate = getServiceInstance(_cryptoService.default) || _cryptoService.default;
    // If the module exported a class, getServiceInstance will instantiate it
    // and provide an object with getCryptoMarketAnalysis mocked in tests.
    const serviceData = typeof cryptoSvcCandidate.getCryptoMarketAnalysis === 'function' ? await cryptoSvcCandidate.getCryptoMarketAnalysis(cryptoList) : await (cryptoSvcCandidate.getCryptoMarketAnalysis || cryptoSvcCandidate)(cryptoList);

    // Normalize/augment returned service data for backward compatibility
    if (serviceData && typeof serviceData === 'object') {
      // If the service provides a volatilityIndex, expose it as `value` to match tests
      if (serviceData.volatilityIndex !== undefined) {
        serviceData.value = serviceData.volatilityIndex;
      }
      // Add unit and topic defaults if not present
      serviceData.unit = serviceData.unit || '%';
      serviceData.topic = serviceData.topic || 'crypto-volatility';
      // Ensure timestamp exists
      serviceData.timestamp = serviceData.timestamp || new Date().toISOString();
    }
    res.status(200).json({
      success: true,
      status: 'OK',
      source: 'Praevisio-Aion-CryptoService',
      timestamp: new Date().toISOString(),
      data: serviceData
    });
  } catch (error) {
    console.error('Error retrieving crypto volatility data:', error);
    res.status(500).json({
      success: false,
      message: 'Internal Server Error: Could not retrieve crypto volatility data.'
    });
  }
});

// GET /api/global-risk/climate-extremes
router.get('/climate-extremes', async (req, res) => {
  try {
    const climateService = getServiceInstance(climateServiceModule) || climateServiceModule;
    const serviceData = typeof climateService.getClimateExtremesIndex === 'function' ? await climateService.getClimateExtremesIndex() : await (climateService.getClimateExtremesIndex || climateService);
    res.status(200).json({
      success: true,
      source: 'Praevisio-Aion-NASA-POWER-Integration',
      timestamp: new Date().toISOString(),
      data: serviceData
    });
  } catch (error) {
    console.error('Error retrieving climate extremes data:', error);
    res.status(500).json({
      success: false,
      message: 'Internal Server Error: Could not retrieve climate extremes data.'
    });
  }
});

// GET /api/global-risk/community-resilience
router.get('/community-resilience', async (req, res) => {
  try {
    const {
      countries = 'COL,PER,ARG',
      days = 30
    } = req.query;
    const countryList = Array.isArray(countries) ? countries : countries.split(',').map(c => c.trim()).filter(Boolean);
    const communityService = getServiceInstance(communityResilienceServiceModule) || communityResilienceServiceModule;
    const serviceData = typeof communityService.getCommunityResilienceIndex === 'function' ? await communityService.getCommunityResilienceIndex(countryList, Number(days)) : await (communityService.getCommunityResilienceIndex || communityService)(countryList, Number(days));

    // Build a normalized metric value: 100 - averageResilience
    const avg = serviceData?.globalResilienceAssessment?.averageResilience;
    const value = typeof avg === 'number' ? Math.round(100 - avg) : undefined;
    const data = {
      timestamp: serviceData?.timestamp || new Date().toISOString(),
      topic: 'community-resilience',
      unit: '%',
      value,
      resilienceAnalysis: serviceData?.resilienceAnalysis || {},
      globalResilienceAssessment: serviceData?.globalResilienceAssessment || {}
    };
    res.status(200).json({
      success: true,
      status: 'OK',
      source: 'Praevisio-Aion-CommunityResilienceAgent',
      timestamp: new Date().toISOString(),
      data
    });
  } catch (error) {
    console.error('Error retrieving community resilience data:', error);
    res.status(500).json({
      success: false,
      message: 'Internal Server Error: Could not retrieve community resilience data.'
    });
  }
});

/**
 * @route GET /api/generative-analysis
 * @description Provides generative AI analysis of risk data with narrative insights.
 * @access Public
 */
router.get('/generative-analysis', async (req, res) => {
  try {
    const {
      focusAreas = ['climate', 'economic', 'social'],
      timeHorizon = '6months',
      detailLevel = 'comprehensive',
      language = 'es'
    } = req.query;
    const predictionService = getServiceInstance(predictionEngineModule) || predictionEngineModule;
    const riskData = typeof predictionService.getRiskIndices === 'function' ? await predictionService.getRiskIndices() : await (predictionService.getRiskIndices || predictionService);
    const genService = getServiceInstance(generativeAIServiceModule) || generativeAIServiceModule;
    const options = {
      focusAreas: Array.isArray(focusAreas) ? focusAreas : focusAreas.split(',').map(a => a.trim()),
      timeHorizon,
      detailLevel,
      language
    };
    const narrative = typeof genService.generatePredictiveNarrative === 'function' ? await genService.generatePredictiveNarrative(riskData, options) : await (genService.generatePredictiveNarrative || genService)(riskData, options);
    res.status(200).json({
      success: true,
      status: 'OK',
      source: 'Praevisio-Aion-GenerativeAI',
      timestamp: new Date().toISOString(),
      data: narrative
    });
  } catch (error) {
    console.error('Error generating AI analysis:', error);
    res.status(500).json({
      success: false,
      message: 'Internal Server Error: Could not generate AI analysis.'
    });
  }
});
var _default = exports.default = router;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfZXhwcmVzcyIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJyZXF1aXJlIiwiX3BhdGgiLCJ3b3JsZEJhbmtTZXJ2aWNlIiwiX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQiLCJfY3J5cHRvU2VydmljZSIsImNsaW1hdGVTZXJ2aWNlTW9kdWxlIiwiY29tbXVuaXR5UmVzaWxpZW5jZVNlcnZpY2VNb2R1bGUiLCJwcmVkaWN0aW9uRW5naW5lTW9kdWxlIiwiZ2VuZXJhdGl2ZUFJU2VydmljZU1vZHVsZSIsImUiLCJfX2VzTW9kdWxlIiwiZGVmYXVsdCIsInQiLCJXZWFrTWFwIiwiciIsIm4iLCJvIiwiaSIsImYiLCJfX3Byb3RvX18iLCJoYXMiLCJnZXQiLCJzZXQiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIl9fZGlybmFtZSIsInBhdGgiLCJyZXNvbHZlIiwicHJvY2VzcyIsImN3ZCIsInJvdXRlciIsImV4cHJlc3MiLCJSb3V0ZXIiLCJzYWZlTG9hZCIsIm1vZHVsZVBhdGgiLCJmdWxsUGF0aCIsInRhcmdldEJhc2VuYW1lIiwiYmFzZW5hbWUiLCJjYWNoZUtleXMiLCJrZXlzIiwiY2FjaGUiLCJtYXRjaEtleSIsImZpbmQiLCJrIiwiZW5kc1dpdGgiLCJqb2luIiwiY2FjaGVkIiwiY2FjaGVFcnIiLCJjYW5kaWRhdGVzIiwicHVzaCIsInN2Y0Jhc2VuYW1lIiwiY2FuZCIsIm1vZEJ5SWQiLCJyZXNvbHZlZCIsIm1vZCIsInJlcUVyciIsInNwZWNpZmllciIsIlByb21pc2UiLCJ0aGVuIiwicyIsImltcG9ydEVyciIsImNvbnNvbGUiLCJlcnJvciIsIkVycm9yIiwiZ2V0U2VydmljZUluc3RhbmNlIiwiZXJyIiwicmVxIiwicmVzIiwiZm9vZFNlcnZpY2UiLCJkYXRhIiwiZ2V0Rm9vZFNlY3VyaXR5SW5kZXgiLCJzdGF0dXMiLCJqc29uIiwic3VjY2VzcyIsInNvdXJjZSIsIm1lc3NhZ2UiLCJjcnlwdG9JZHMiLCJxdWVyeSIsImNyeXB0b0xpc3QiLCJzcGxpdCIsIm1hcCIsImlkIiwidHJpbSIsImNyeXB0b1N2Y0NhbmRpZGF0ZSIsIkNyeXB0b1NlcnZpY2UiLCJzZXJ2aWNlRGF0YSIsImdldENyeXB0b01hcmtldEFuYWx5c2lzIiwidm9sYXRpbGl0eUluZGV4IiwidW5kZWZpbmVkIiwidmFsdWUiLCJ1bml0IiwidG9waWMiLCJ0aW1lc3RhbXAiLCJEYXRlIiwidG9JU09TdHJpbmciLCJjbGltYXRlU2VydmljZSIsImdldENsaW1hdGVFeHRyZW1lc0luZGV4IiwiY291bnRyaWVzIiwiZGF5cyIsImNvdW50cnlMaXN0IiwiQXJyYXkiLCJpc0FycmF5IiwiYyIsImZpbHRlciIsIkJvb2xlYW4iLCJjb21tdW5pdHlTZXJ2aWNlIiwiZ2V0Q29tbXVuaXR5UmVzaWxpZW5jZUluZGV4IiwiTnVtYmVyIiwiYXZnIiwiZ2xvYmFsUmVzaWxpZW5jZUFzc2Vzc21lbnQiLCJhdmVyYWdlUmVzaWxpZW5jZSIsIk1hdGgiLCJyb3VuZCIsInJlc2lsaWVuY2VBbmFseXNpcyIsImZvY3VzQXJlYXMiLCJ0aW1lSG9yaXpvbiIsImRldGFpbExldmVsIiwibGFuZ3VhZ2UiLCJwcmVkaWN0aW9uU2VydmljZSIsInJpc2tEYXRhIiwiZ2V0Umlza0luZGljZXMiLCJnZW5TZXJ2aWNlIiwib3B0aW9ucyIsImEiLCJuYXJyYXRpdmUiLCJnZW5lcmF0ZVByZWRpY3RpdmVOYXJyYXRpdmUiLCJfZGVmYXVsdCIsImV4cG9ydHMiXSwic291cmNlcyI6WyJnbG9iYWxSaXNrUm91dGVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBleHByZXNzIGZyb20gJ2V4cHJlc3MnO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG4vLyBTdGF0aWMgaW1wb3J0cyBmb3IgY29yZSBzZXJ2aWNlcyBzbyBKZXN0J3MgamVzdC5tb2NrKC4uLikgY2FsbHNcbi8vICh1c2VkIGluIHRlc3RzKSBhcmUgYXBwbGllZCByZWxpYWJseS4gS2VlcCBzYWZlTG9hZCBhcyBhIGZhbGxiYWNrXG4vLyBmb3IgYW55IGxlc3MtY29tbW9uIG9yIEVTTS1vbmx5IG1vZHVsZXMuXG5pbXBvcnQgKiBhcyB3b3JsZEJhbmtTZXJ2aWNlIGZyb20gJy4uL3NlcnZpY2VzL3dvcmxkQmFua1NlcnZpY2UuanMnO1xuaW1wb3J0IENyeXB0b1NlcnZpY2UgZnJvbSAnLi4vc2VydmljZXMvY3J5cHRvU2VydmljZS5qcyc7XG5pbXBvcnQgKiBhcyBjbGltYXRlU2VydmljZU1vZHVsZSBmcm9tICcuLi9zZXJ2aWNlcy9jbGltYXRlU2VydmljZS5qcyc7XG5pbXBvcnQgKiBhcyBjb21tdW5pdHlSZXNpbGllbmNlU2VydmljZU1vZHVsZSBmcm9tICcuLi9zZXJ2aWNlcy9jb21tdW5pdHlSZXNpbGllbmNlU2VydmljZS5qcyc7XG5pbXBvcnQgKiBhcyBwcmVkaWN0aW9uRW5naW5lTW9kdWxlIGZyb20gJy4uL3NlcnZpY2VzL3ByZWRpY3Rpb25FbmdpbmUuanMnO1xuaW1wb3J0ICogYXMgZ2VuZXJhdGl2ZUFJU2VydmljZU1vZHVsZSBmcm9tICcuLi9zZXJ2aWNlcy9nZW5lcmF0aXZlQUlTZXJ2aWNlLmpzJztcblxuLy8gUmVzb2x2ZSBhIHN0YWJsZSBfX2Rpcm5hbWUgZm9yIHRoaXMgbW9kdWxlIGluIGJvdGggRVNNIGFuZCBDb21tb25KU1xuLy8gdGVzdCBlbnZpcm9ubWVudHMuIFNvbWUgdGVzdCBydW5uZXJzIChKZXN0ICsgYmFiZWwtamVzdCkgbWF5IG5vdFxuLy8gc3VwcG9ydCBgaW1wb3J0Lm1ldGEudXJsYCBkdXJpbmcgdHJhbnNmb3JtYXRpb24sIHdoaWNoIGNhdXNlc1xuLy8gXCJDYW5ub3QgdXNlICdpbXBvcnQubWV0YScgb3V0c2lkZSBhIG1vZHVsZVwiIGVycm9ycy4gVG8gYXZvaWQgdGhhdFxuLy8gYW5kIGtlZXAgbW9kdWxlIHJlc29sdXRpb24gZGV0ZXJtaW5pc3RpYywgdXNlIHRoZSByZXBvc2l0b3J5J3Ncbi8vIGBzcmMvcm91dGVzYCBmb2xkZXIgYXMgYmFzZSB3aGVuIGltcG9ydC5tZXRhIGlzIHVuYXZhaWxhYmxlLlxuY29uc3QgX19kaXJuYW1lID0gcGF0aC5yZXNvbHZlKHByb2Nlc3MuY3dkKCksICdzcmMnLCAncm91dGVzJyk7XG5jb25zdCByb3V0ZXIgPSBleHByZXNzLlJvdXRlcigpO1xuXG4vLyBIZWxwZXIgdG8gZHluYW1pY2FsbHkgbG9hZCBhIG1vZHVsZS5cbi8vIFByZWZlciBDb21tb25KUyBgcmVxdWlyZWAgd2hlbiBhdmFpbGFibGUgc28gSmVzdCdzIG1vZHVsZSBtb2NrcyAod2hpY2hcbi8vIGNvbW1vbmx5IHBhdGNoIGByZXF1aXJlYCkgYXJlIGFwcGxpZWQuIEZhbGxiYWNrIHRvIGR5bmFtaWMgaW1wb3J0IGZvclxuLy8gdHJ1ZSBFU00gbW9kdWxlcyBvciB3aGVuIHJlcXVpcmUgaXNuJ3QgYXZhaWxhYmxlLlxuYXN5bmMgZnVuY3Rpb24gc2FmZUxvYWQobW9kdWxlUGF0aCkge1xuICBjb25zdCBmdWxsUGF0aCA9IHBhdGgucmVzb2x2ZShfX2Rpcm5hbWUsIG1vZHVsZVBhdGgpO1xuICAvLyBUcnkgcmVxdWlyZSBmaXJzdCBmb3IgYmV0dGVyIGNvbXBhdGliaWxpdHkgd2l0aCBKZXN0IG1vY2tzXG4gIHRyeSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGdsb2JhbC1yZXF1aXJlLCBpbXBvcnQvbm8tZHluYW1pYy1yZXF1aXJlXG4gICAgaWYgKHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBUcnkgdG8gZmluZCBhIGNhY2hlZCBtb2R1bGUgdGhhdCBtYXRjaGVzIHRoZSBzZXJ2aWNlIGZpbGVuYW1lLlxuICAgICAgLy8gSmVzdCBtYXkgcmVnaXN0ZXIgbW9ja3MgdW5kZXIgYWJzb2x1dGUgcGF0aHM7IHNlYXJjaGluZyB0aGVcbiAgICAgIC8vIHJlcXVpcmUuY2FjaGUgZm9yIGEgZmlsZW5hbWUgc3VmZml4IGxpa2UgJy9zcmMvc2VydmljZXMvY3J5cHRvU2VydmljZS5qcydcbiAgICAgIC8vIG9mdGVuIGZpbmRzIHRoZSBtb2NrZWQgbW9kdWxlIHNvIHRlc3RzJyBtb2NrcyBhcmUgaG9ub3JlZC5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHRhcmdldEJhc2VuYW1lID0gcGF0aC5iYXNlbmFtZShtb2R1bGVQYXRoKTtcbiAgICAgICAgY29uc3QgY2FjaGVLZXlzID0gT2JqZWN0LmtleXMocmVxdWlyZS5jYWNoZSB8fCB7fSk7XG4gICAgICAgIGNvbnN0IG1hdGNoS2V5ID0gY2FjaGVLZXlzLmZpbmQoayA9PiBrLmVuZHNXaXRoKHBhdGguam9pbignc3JjJywgJ3NlcnZpY2VzJywgdGFyZ2V0QmFzZW5hbWUpKSk7XG4gICAgICAgIGlmIChtYXRjaEtleSkge1xuICAgICAgICAgIGNvbnN0IGNhY2hlZCA9IHJlcXVpcmUobWF0Y2hLZXkpO1xuICAgICAgICAgIHJldHVybiBjYWNoZWQgJiYgY2FjaGVkLl9fZXNNb2R1bGUgPyBjYWNoZWQuZGVmYXVsdCB8fCBjYWNoZWQgOiBjYWNoZWQ7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGNhY2hlRXJyKSB7XG4gICAgICAgIC8vIGlnbm9yZSBhbmQgY29udGludWUgdG8gbm9ybWFsIHJlcXVpcmUgZmxvd1xuICAgICAgfVxuICAgICAgLy8gVHJ5IHJlcXVpcmluZyBieSBzZXZlcmFsIGNhbmRpZGF0ZSBpZHMgc28gSmVzdCdzIG1vY2tzICh3aGljaCBtYXlcbiAgICAgIC8vIGJlIHJlZ2lzdGVyZWQgdW5kZXIgZGlmZmVyZW50IG1vZHVsZSBpZHMpIGFyZSBkaXNjb3ZlcmVkLlxuICAgICAgY29uc3QgY2FuZGlkYXRlcyA9IFtdO1xuICAgICAgLy8gb3JpZ2luYWwgcmVsYXRpdmUgaWQgYXMgdXNlZCBpbiBzYWZlTG9hZCBjYWxsXG4gICAgICBjYW5kaWRhdGVzLnB1c2gobW9kdWxlUGF0aCk7XG4gICAgICAvLyBhYnNvbHV0ZSBmaWxlc3lzdGVtIHBhdGggdG8gbW9kdWxlXG4gICAgICBjYW5kaWRhdGVzLnB1c2goZnVsbFBhdGgpO1xuICAgICAgLy8gcHJvamVjdC1iYXNlZCBzZXJ2aWNlcyBwYXRoIChjb21tb24gaW4gdGVzdHMgdGhhdCB1c2UgLi4vLi4vc3JjLy4uLilcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHN2Y0Jhc2VuYW1lID0gcGF0aC5iYXNlbmFtZShtb2R1bGVQYXRoKTtcbiAgICAgICAgY2FuZGlkYXRlcy5wdXNoKHBhdGgucmVzb2x2ZShwcm9jZXNzLmN3ZCgpLCAnc3JjJywgJ3NlcnZpY2VzJywgc3ZjQmFzZW5hbWUpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gaWdub3JlXG4gICAgICB9XG5cbiAgICAgIGZvciAoY29uc3QgY2FuZCBvZiBjYW5kaWRhdGVzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgbW9kQnlJZCA9IHJlcXVpcmUoY2FuZCk7XG4gICAgICAgICAgcmV0dXJuIG1vZEJ5SWQgJiYgbW9kQnlJZC5fX2VzTW9kdWxlID8gbW9kQnlJZC5kZWZhdWx0IHx8IG1vZEJ5SWQgOiBtb2RCeUlkO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gdHJ5IG5leHQgY2FuZGlkYXRlXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQXMgYSBsYXN0IGF0dGVtcHQsIHJlc29sdmUgdGhlIGZ1bGwgYWJzb2x1dGUgcGF0aCBhbmQgcmVxdWlyZSB0aGF0XG4gICAgICBjb25zdCByZXNvbHZlZCA9IHJlcXVpcmUucmVzb2x2ZShmdWxsUGF0aCk7XG4gICAgICBjb25zdCBtb2QgPSByZXF1aXJlKHJlc29sdmVkKTtcbiAgICAgIHJldHVybiBtb2QgJiYgbW9kLl9fZXNNb2R1bGUgPyBtb2QuZGVmYXVsdCB8fCBtb2QgOiBtb2Q7XG4gICAgfVxuICB9IGNhdGNoIChyZXFFcnIpIHtcbiAgICAvLyBOb3QgZmF0YWw6IGZhbGwgdGhyb3VnaCB0byBkeW5hbWljIGltcG9ydFxuICAgIC8vIGNvbnNvbGUuZGVidWcoYHNhZmVMb2FkIHJlcXVpcmUgZmFpbGVkIGZvciAke21vZHVsZVBhdGh9OmAsIHJlcUVyci5tZXNzYWdlKTtcbiAgfVxuXG4gIC8vIER5bmFtaWMgaW1wb3J0IGZhbGxiYWNrIChmb3IgRVNNLW9ubHkgbW9kdWxlcylcbiAgdHJ5IHtcbiAgICBjb25zdCBtb2QgPSBhd2FpdCBpbXBvcnQoZnVsbFBhdGgpO1xuICAgIHJldHVybiBtb2QgJiYgbW9kLmRlZmF1bHQgPyBtb2QuZGVmYXVsdCA6IG1vZDtcbiAgfSBjYXRjaCAoaW1wb3J0RXJyKSB7XG4gICAgY29uc29sZS5lcnJvcihgRXJyb3IgbG9hZGluZyBtb2R1bGUgJHttb2R1bGVQYXRofSB2aWEgaW1wb3J0KCk6YCwgaW1wb3J0RXJyKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBsb2FkIG1vZHVsZTogJHttb2R1bGVQYXRofWApO1xuICB9XG59XG5cbi8vIEhlbHBlcjogZ2l2ZW4gYSBsb2FkZWQgbW9kdWxlLCByZXR1cm4gYSB1c2FibGUgc2VydmljZSBvYmplY3QuXG5mdW5jdGlvbiBnZXRTZXJ2aWNlSW5zdGFuY2UobW9kKSB7XG4gIGlmICghbW9kKSByZXR1cm4gbnVsbDtcbiAgLy8gSWYgbW9kdWxlIGlzIGEgY29uc3RydWN0b3IgKGNsYXNzIG9yIGZ1bmN0aW9uKSwgaW5zdGFudGlhdGUgaXQuXG4gIGlmICh0eXBlb2YgbW9kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBuZXcgbW9kKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gSWYgaXQncyBhIGZhY3RvcnkgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIG9iamVjdCB3aGVuIGNhbGxlZFxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG1vZCgpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiBtb2Q7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIElmIG1vZHVsZSBpcyBhbiBvYmplY3Qgd2l0aCBhIGRlZmF1bHQgY2xhc3MsIGluc3RhbnRpYXRlIGRlZmF1bHRcbiAgaWYgKG1vZCAmJiB0eXBlb2YgbW9kID09PSAnb2JqZWN0JyAmJiBtb2QuZGVmYXVsdCAmJiB0eXBlb2YgbW9kLmRlZmF1bHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG5ldyBtb2QuZGVmYXVsdCgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBtb2QuZGVmYXVsdCgpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiBtb2QuZGVmYXVsdCB8fCBtb2Q7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIE90aGVyd2lzZSByZXR1cm4gdGhlIG1vZHVsZSBhcy1pcyAoaXQgbWF5IGJlIGFuIG9iamVjdCBvZiBmdW5jdGlvbnMpXG4gIHJldHVybiBtb2Q7XG59XG5cbi8vIEdFVCAvYXBpL2dsb2JhbC1yaXNrL2Zvb2Qtc2VjdXJpdHkgXG5yb3V0ZXIuZ2V0KCcvZm9vZC1zZWN1cml0eScsIGFzeW5jIChyZXEsIHJlcykgPT4ge1xuICB0cnkge1xuICAgIC8vIFVzZSB0aGUgc3RhdGljYWxseSBpbXBvcnRlZCBtb2R1bGUgKHRlc3RzIG1vY2sgdGhpcyBtb2R1bGUpXG4gICAgLy8gVXNlIHN0YXRpY2FsbHkgaW1wb3J0ZWQgd29ybGRCYW5rU2VydmljZSAodGVzdHMgbW9jayB0aGlzIG1vZHVsZSlcbiAgICBjb25zdCBmb29kU2VydmljZSA9IGdldFNlcnZpY2VJbnN0YW5jZSh3b3JsZEJhbmtTZXJ2aWNlKSB8fCB3b3JsZEJhbmtTZXJ2aWNlO1xuICAgIGNvbnN0IGRhdGEgPSB0eXBlb2YgZm9vZFNlcnZpY2UuZ2V0Rm9vZFNlY3VyaXR5SW5kZXggPT09ICdmdW5jdGlvbidcbiAgICAgID8gYXdhaXQgZm9vZFNlcnZpY2UuZ2V0Rm9vZFNlY3VyaXR5SW5kZXgoKVxuICAgICAgOiBhd2FpdCAoZm9vZFNlcnZpY2UuZ2V0Rm9vZFNlY3VyaXR5SW5kZXggfHwgZm9vZFNlcnZpY2UpO1xuICAgIFxuICAgIHJlcy5zdGF0dXMoMjAwKS5qc29uKHtcbiAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICBzb3VyY2U6ICdQcmFldmlzaW8tQWlvbi1TaW11bGF0ZWQtV29ybGRCYW5rJyxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZXRyaWV2aW5nIGZvb2Qgc2VjdXJpdHkgZGF0YTonLCBlcnJvcik7XG4gICAgcmVzLnN0YXR1cyg1MDApLmpzb24oe1xuICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICBtZXNzYWdlOiAnSW50ZXJuYWwgU2VydmVyIEVycm9yOiBDb3VsZCBub3QgcmV0cmlldmUgZm9vZCBzZWN1cml0eSBkYXRhLidcbiAgICB9KTtcbiAgfVxufSk7XG5cbi8vIEdFVCAvYXBpL2dsb2JhbC1yaXNrL2NyeXB0by12b2xhdGlsaXR5XG5yb3V0ZXIuZ2V0KCcvY3J5cHRvLXZvbGF0aWxpdHknLCBhc3luYyAocmVxLCByZXMpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCB7IGNyeXB0b0lkcyA9ICdiaXRjb2luLGV0aGVyZXVtJyB9ID0gcmVxLnF1ZXJ5O1xuICAgIGNvbnN0IGNyeXB0b0xpc3QgPSBjcnlwdG9JZHMuc3BsaXQoJywnKS5tYXAoaWQgPT4gaWQudHJpbSgpKTtcbiAgICAvLyBVc2Ugc3RhdGljYWxseSBpbXBvcnRlZCBjcnlwdG8gbW9kdWxlIHNvIEplc3QncyBtb2NrSW1wbGVtZW50YXRpb24gaXMgdXNlZFxuICAgIC8vIFVzZSBzdGF0aWNhbGx5IGltcG9ydGVkIENyeXB0b1NlcnZpY2UgbW9kdWxlICh0ZXN0cyBtb2NrIGl0cyBjb25zdHJ1Y3RvcilcbiAgICBjb25zdCBjcnlwdG9TdmNDYW5kaWRhdGUgPSBnZXRTZXJ2aWNlSW5zdGFuY2UoQ3J5cHRvU2VydmljZSkgfHwgQ3J5cHRvU2VydmljZTtcbiAgICAvLyBJZiB0aGUgbW9kdWxlIGV4cG9ydGVkIGEgY2xhc3MsIGdldFNlcnZpY2VJbnN0YW5jZSB3aWxsIGluc3RhbnRpYXRlIGl0XG4gICAgLy8gYW5kIHByb3ZpZGUgYW4gb2JqZWN0IHdpdGggZ2V0Q3J5cHRvTWFya2V0QW5hbHlzaXMgbW9ja2VkIGluIHRlc3RzLlxuICAgIGNvbnN0IHNlcnZpY2VEYXRhID0gdHlwZW9mIGNyeXB0b1N2Y0NhbmRpZGF0ZS5nZXRDcnlwdG9NYXJrZXRBbmFseXNpcyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgPyBhd2FpdCBjcnlwdG9TdmNDYW5kaWRhdGUuZ2V0Q3J5cHRvTWFya2V0QW5hbHlzaXMoY3J5cHRvTGlzdClcbiAgICAgIDogYXdhaXQgKGNyeXB0b1N2Y0NhbmRpZGF0ZS5nZXRDcnlwdG9NYXJrZXRBbmFseXNpcyB8fCBjcnlwdG9TdmNDYW5kaWRhdGUpKGNyeXB0b0xpc3QpO1xuXG4gICAgLy8gTm9ybWFsaXplL2F1Z21lbnQgcmV0dXJuZWQgc2VydmljZSBkYXRhIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gICAgaWYgKHNlcnZpY2VEYXRhICYmIHR5cGVvZiBzZXJ2aWNlRGF0YSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIC8vIElmIHRoZSBzZXJ2aWNlIHByb3ZpZGVzIGEgdm9sYXRpbGl0eUluZGV4LCBleHBvc2UgaXQgYXMgYHZhbHVlYCB0byBtYXRjaCB0ZXN0c1xuICAgICAgaWYgKHNlcnZpY2VEYXRhLnZvbGF0aWxpdHlJbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHNlcnZpY2VEYXRhLnZhbHVlID0gc2VydmljZURhdGEudm9sYXRpbGl0eUluZGV4O1xuICAgICAgfVxuICAgICAgLy8gQWRkIHVuaXQgYW5kIHRvcGljIGRlZmF1bHRzIGlmIG5vdCBwcmVzZW50XG4gICAgICBzZXJ2aWNlRGF0YS51bml0ID0gc2VydmljZURhdGEudW5pdCB8fCAnJSc7XG4gICAgICBzZXJ2aWNlRGF0YS50b3BpYyA9IHNlcnZpY2VEYXRhLnRvcGljIHx8ICdjcnlwdG8tdm9sYXRpbGl0eSc7XG4gICAgICAvLyBFbnN1cmUgdGltZXN0YW1wIGV4aXN0c1xuICAgICAgc2VydmljZURhdGEudGltZXN0YW1wID0gc2VydmljZURhdGEudGltZXN0YW1wIHx8IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICB9XG5cbiAgICByZXMuc3RhdHVzKDIwMCkuanNvbih7XG4gICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgc3RhdHVzOiAnT0snLFxuICAgICAgc291cmNlOiAnUHJhZXZpc2lvLUFpb24tQ3J5cHRvU2VydmljZScsXG4gICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIGRhdGE6IHNlcnZpY2VEYXRhXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgcmV0cmlldmluZyBjcnlwdG8gdm9sYXRpbGl0eSBkYXRhOicsIGVycm9yKTtcbiAgICByZXMuc3RhdHVzKDUwMCkuanNvbih7XG4gICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgIG1lc3NhZ2U6ICdJbnRlcm5hbCBTZXJ2ZXIgRXJyb3I6IENvdWxkIG5vdCByZXRyaWV2ZSBjcnlwdG8gdm9sYXRpbGl0eSBkYXRhLidcbiAgICB9KTtcbiAgfVxufSk7XG5cbi8vIEdFVCAvYXBpL2dsb2JhbC1yaXNrL2NsaW1hdGUtZXh0cmVtZXNcbnJvdXRlci5nZXQoJy9jbGltYXRlLWV4dHJlbWVzJywgYXN5bmMgKHJlcSwgcmVzKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgY2xpbWF0ZVNlcnZpY2UgPSBnZXRTZXJ2aWNlSW5zdGFuY2UoY2xpbWF0ZVNlcnZpY2VNb2R1bGUpIHx8IGNsaW1hdGVTZXJ2aWNlTW9kdWxlO1xuICAgIGNvbnN0IHNlcnZpY2VEYXRhID0gdHlwZW9mIGNsaW1hdGVTZXJ2aWNlLmdldENsaW1hdGVFeHRyZW1lc0luZGV4ID09PSAnZnVuY3Rpb24nXG4gICAgICA/IGF3YWl0IGNsaW1hdGVTZXJ2aWNlLmdldENsaW1hdGVFeHRyZW1lc0luZGV4KClcbiAgICAgIDogYXdhaXQgKGNsaW1hdGVTZXJ2aWNlLmdldENsaW1hdGVFeHRyZW1lc0luZGV4IHx8IGNsaW1hdGVTZXJ2aWNlKTtcblxuICAgIHJlcy5zdGF0dXMoMjAwKS5qc29uKHtcbiAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICBzb3VyY2U6ICdQcmFldmlzaW8tQWlvbi1OQVNBLVBPV0VSLUludGVncmF0aW9uJyxcbiAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgZGF0YTogc2VydmljZURhdGFcbiAgICB9KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZXRyaWV2aW5nIGNsaW1hdGUgZXh0cmVtZXMgZGF0YTonLCBlcnJvcik7XG4gICAgcmVzLnN0YXR1cyg1MDApLmpzb24oe1xuICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICBtZXNzYWdlOiAnSW50ZXJuYWwgU2VydmVyIEVycm9yOiBDb3VsZCBub3QgcmV0cmlldmUgY2xpbWF0ZSBleHRyZW1lcyBkYXRhLidcbiAgICB9KTtcbiAgfVxufSk7XG5cbi8vIEdFVCAvYXBpL2dsb2JhbC1yaXNrL2NvbW11bml0eS1yZXNpbGllbmNlXG5yb3V0ZXIuZ2V0KCcvY29tbXVuaXR5LXJlc2lsaWVuY2UnLCBhc3luYyAocmVxLCByZXMpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCB7IGNvdW50cmllcyA9ICdDT0wsUEVSLEFSRycsIGRheXMgPSAzMCB9ID0gcmVxLnF1ZXJ5O1xuICAgIGNvbnN0IGNvdW50cnlMaXN0ID0gQXJyYXkuaXNBcnJheShjb3VudHJpZXMpID8gY291bnRyaWVzIDogY291bnRyaWVzLnNwbGl0KCcsJykubWFwKGMgPT4gYy50cmltKCkpLmZpbHRlcihCb29sZWFuKTtcblxuICAgIGNvbnN0IGNvbW11bml0eVNlcnZpY2UgPSBnZXRTZXJ2aWNlSW5zdGFuY2UoY29tbXVuaXR5UmVzaWxpZW5jZVNlcnZpY2VNb2R1bGUpIHx8IGNvbW11bml0eVJlc2lsaWVuY2VTZXJ2aWNlTW9kdWxlO1xuICAgIGNvbnN0IHNlcnZpY2VEYXRhID0gdHlwZW9mIGNvbW11bml0eVNlcnZpY2UuZ2V0Q29tbXVuaXR5UmVzaWxpZW5jZUluZGV4ID09PSAnZnVuY3Rpb24nXG4gICAgICA/IGF3YWl0IGNvbW11bml0eVNlcnZpY2UuZ2V0Q29tbXVuaXR5UmVzaWxpZW5jZUluZGV4KGNvdW50cnlMaXN0LCBOdW1iZXIoZGF5cykpXG4gICAgICA6IGF3YWl0IChjb21tdW5pdHlTZXJ2aWNlLmdldENvbW11bml0eVJlc2lsaWVuY2VJbmRleCB8fCBjb21tdW5pdHlTZXJ2aWNlKShjb3VudHJ5TGlzdCwgTnVtYmVyKGRheXMpKTtcblxuICAgIC8vIEJ1aWxkIGEgbm9ybWFsaXplZCBtZXRyaWMgdmFsdWU6IDEwMCAtIGF2ZXJhZ2VSZXNpbGllbmNlXG4gICAgY29uc3QgYXZnID0gc2VydmljZURhdGE/Lmdsb2JhbFJlc2lsaWVuY2VBc3Nlc3NtZW50Py5hdmVyYWdlUmVzaWxpZW5jZTtcbiAgICBjb25zdCB2YWx1ZSA9IHR5cGVvZiBhdmcgPT09ICdudW1iZXInID8gTWF0aC5yb3VuZCgxMDAgLSBhdmcpIDogdW5kZWZpbmVkO1xuXG4gICAgY29uc3QgZGF0YSA9IHtcbiAgICAgIHRpbWVzdGFtcDogc2VydmljZURhdGE/LnRpbWVzdGFtcCB8fCBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICB0b3BpYzogJ2NvbW11bml0eS1yZXNpbGllbmNlJyxcbiAgICAgIHVuaXQ6ICclJyxcbiAgICAgIHZhbHVlLFxuICAgICAgcmVzaWxpZW5jZUFuYWx5c2lzOiBzZXJ2aWNlRGF0YT8ucmVzaWxpZW5jZUFuYWx5c2lzIHx8IHt9LFxuICAgICAgZ2xvYmFsUmVzaWxpZW5jZUFzc2Vzc21lbnQ6IHNlcnZpY2VEYXRhPy5nbG9iYWxSZXNpbGllbmNlQXNzZXNzbWVudCB8fCB7fVxuICAgIH07XG5cbiAgICByZXMuc3RhdHVzKDIwMCkuanNvbih7XG4gICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgc3RhdHVzOiAnT0snLFxuICAgICAgc291cmNlOiAnUHJhZXZpc2lvLUFpb24tQ29tbXVuaXR5UmVzaWxpZW5jZUFnZW50JyxcbiAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJldHJpZXZpbmcgY29tbXVuaXR5IHJlc2lsaWVuY2UgZGF0YTonLCBlcnJvcik7XG4gICAgcmVzLnN0YXR1cyg1MDApLmpzb24oe1xuICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICBtZXNzYWdlOiAnSW50ZXJuYWwgU2VydmVyIEVycm9yOiBDb3VsZCBub3QgcmV0cmlldmUgY29tbXVuaXR5IHJlc2lsaWVuY2UgZGF0YS4nXG4gICAgfSk7XG4gIH1cbn0pO1xuXG4vKipcbiAqIEByb3V0ZSBHRVQgL2FwaS9nZW5lcmF0aXZlLWFuYWx5c2lzXG4gKiBAZGVzY3JpcHRpb24gUHJvdmlkZXMgZ2VuZXJhdGl2ZSBBSSBhbmFseXNpcyBvZiByaXNrIGRhdGEgd2l0aCBuYXJyYXRpdmUgaW5zaWdodHMuXG4gKiBAYWNjZXNzIFB1YmxpY1xuICovXG5yb3V0ZXIuZ2V0KCcvZ2VuZXJhdGl2ZS1hbmFseXNpcycsIGFzeW5jIChyZXEsIHJlcykgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHsgZm9jdXNBcmVhcyA9IFsnY2xpbWF0ZScsICdlY29ub21pYycsICdzb2NpYWwnXSwgdGltZUhvcml6b24gPSAnNm1vbnRocycsIGRldGFpbExldmVsID0gJ2NvbXByZWhlbnNpdmUnLCBsYW5ndWFnZSA9ICdlcycgfSA9IHJlcS5xdWVyeTtcblxuICAgIGNvbnN0IHByZWRpY3Rpb25TZXJ2aWNlID0gZ2V0U2VydmljZUluc3RhbmNlKHByZWRpY3Rpb25FbmdpbmVNb2R1bGUpIHx8IHByZWRpY3Rpb25FbmdpbmVNb2R1bGU7XG4gICAgY29uc3Qgcmlza0RhdGEgPSB0eXBlb2YgcHJlZGljdGlvblNlcnZpY2UuZ2V0Umlza0luZGljZXMgPT09ICdmdW5jdGlvbidcbiAgICAgID8gYXdhaXQgcHJlZGljdGlvblNlcnZpY2UuZ2V0Umlza0luZGljZXMoKVxuICAgICAgOiBhd2FpdCAocHJlZGljdGlvblNlcnZpY2UuZ2V0Umlza0luZGljZXMgfHwgcHJlZGljdGlvblNlcnZpY2UpO1xuXG4gICAgY29uc3QgZ2VuU2VydmljZSA9IGdldFNlcnZpY2VJbnN0YW5jZShnZW5lcmF0aXZlQUlTZXJ2aWNlTW9kdWxlKSB8fCBnZW5lcmF0aXZlQUlTZXJ2aWNlTW9kdWxlO1xuXG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIGZvY3VzQXJlYXM6IEFycmF5LmlzQXJyYXkoZm9jdXNBcmVhcykgPyBmb2N1c0FyZWFzIDogZm9jdXNBcmVhcy5zcGxpdCgnLCcpLm1hcChhID0+IGEudHJpbSgpKSxcbiAgICAgIHRpbWVIb3Jpem9uLFxuICAgICAgZGV0YWlsTGV2ZWwsXG4gICAgICBsYW5ndWFnZVxuICAgIH07XG5cbiAgICBjb25zdCBuYXJyYXRpdmUgPSB0eXBlb2YgZ2VuU2VydmljZS5nZW5lcmF0ZVByZWRpY3RpdmVOYXJyYXRpdmUgPT09ICdmdW5jdGlvbidcbiAgICAgID8gYXdhaXQgZ2VuU2VydmljZS5nZW5lcmF0ZVByZWRpY3RpdmVOYXJyYXRpdmUocmlza0RhdGEsIG9wdGlvbnMpXG4gICAgICA6IGF3YWl0IChnZW5TZXJ2aWNlLmdlbmVyYXRlUHJlZGljdGl2ZU5hcnJhdGl2ZSB8fCBnZW5TZXJ2aWNlKShyaXNrRGF0YSwgb3B0aW9ucyk7XG5cbiAgICByZXMuc3RhdHVzKDIwMCkuanNvbih7XG4gICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgc3RhdHVzOiAnT0snLFxuICAgICAgc291cmNlOiAnUHJhZXZpc2lvLUFpb24tR2VuZXJhdGl2ZUFJJyxcbiAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgZGF0YTogbmFycmF0aXZlXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2VuZXJhdGluZyBBSSBhbmFseXNpczonLCBlcnJvcik7XG4gICAgcmVzLnN0YXR1cyg1MDApLmpzb24oe1xuICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICBtZXNzYWdlOiAnSW50ZXJuYWwgU2VydmVyIEVycm9yOiBDb3VsZCBub3QgZ2VuZXJhdGUgQUkgYW5hbHlzaXMuJ1xuICAgIH0pO1xuICB9XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgcm91dGVyO1xuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxJQUFBQSxRQUFBLEdBQUFDLHNCQUFBLENBQUFDLE9BQUE7QUFDQSxJQUFBQyxLQUFBLEdBQUFGLHNCQUFBLENBQUFDLE9BQUE7QUFJQSxJQUFBRSxnQkFBQSxHQUFBQyx1QkFBQSxDQUFBSCxPQUFBO0FBQ0EsSUFBQUksY0FBQSxHQUFBTCxzQkFBQSxDQUFBQyxPQUFBO0FBQ0EsSUFBQUssb0JBQUEsR0FBQUYsdUJBQUEsQ0FBQUgsT0FBQTtBQUNBLElBQUFNLGdDQUFBLEdBQUFILHVCQUFBLENBQUFILE9BQUE7QUFDQSxJQUFBTyxzQkFBQSxHQUFBSix1QkFBQSxDQUFBSCxPQUFBO0FBQ0EsSUFBQVEseUJBQUEsR0FBQUwsdUJBQUEsQ0FBQUgsT0FBQTtBQUFnRixTQUFBRCx1QkFBQVUsQ0FBQSxXQUFBQSxDQUFBLElBQUFBLENBQUEsQ0FBQUMsVUFBQSxHQUFBRCxDQUFBLEtBQUFFLE9BQUEsRUFBQUYsQ0FBQTtBQUFBLFNBQUFOLHdCQUFBTSxDQUFBLEVBQUFHLENBQUEsNkJBQUFDLE9BQUEsTUFBQUMsQ0FBQSxPQUFBRCxPQUFBLElBQUFFLENBQUEsT0FBQUYsT0FBQSxZQUFBVix1QkFBQSxZQUFBQSxDQUFBTSxDQUFBLEVBQUFHLENBQUEsU0FBQUEsQ0FBQSxJQUFBSCxDQUFBLElBQUFBLENBQUEsQ0FBQUMsVUFBQSxT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