{"version":3,"names":["_http","require","_http2","_interopRequireDefault","_https","_https2","_net","_net2","__http_common","_stream","_outvariant","normalizeSocketWriteArgs","args","normalized","MockSocket","default","Socket","constructor","options","connecting","connect","_final","callback","write","chunk","encoding","end","apply","push","read","baseUrlFromConnectionOptions","URL","href","protocol","port","host","url","toString","path","pathname","auth","username","password","split","kRawHeaders","Symbol","kRestorePatches","recordRawHeader","headers","behavior","ensureRawHeadersSymbol","rawHeaders","Reflect","get","index","length","toLowerCase","splice","has","defineRawHeadersSymbol","Object","defineProperty","value","enumerable","configurable","recordRawFetchHeaders","Headers","OriginalHeaders","Request","OriginalRequest","Response","OriginalResponse","globalThis","set","append","delete","headersDeleteMethod","prototype","deleteProperty","writable","Proxy","construct","target","newTarget","headersInit","headers2","rawHeadersInit","Array","isArray","entries","thisArg","request","inferredRawHeaders","inferRawHeaders","response","restoreHeadersPrototype","getRawFetchHeaders","from","kRequestId","MockHttpSocket","_a","socketState","writeBuffer","originalSocket","requestParser","execute","Buffer","isBuffer","responseParser","requestRawHeadersBuffer","responseRawHeadersBuffer","onRequestHeaders","onRequestStart","versionMajor","versionMinor","_","__","___","____","shouldKeepAlive","baseUrl","method","connectionOptions","toUpperCase","_chunkA7U44ARPjs","FetchResponse","parseRawHeaders","canHaveBody","requestStream","Readable","flushWriteBuffer","requestId","createRequestId","call","credentials","duplex","body","toWeb","_chunkSMXZPJEAjs","setRawRequest","_chunk4YBV77DGjs","setRawRequestBodyStream","INTERNAL_REQUEST_ID_HEADER_NAME","passthrough","onRequest","socket","onResponseHeaders","onResponseStart","status","statusText","isResponseWithBody","responseStream","invariant","setUrl","responseListenersPromise","onResponse","isMockedResponse","createConnection","HTTPParser","initialize","REQUEST","kOnHeaders","bind","kOnHeadersComplete","kOnBody","onRequestBody","kOnMessageComplete","onRequestEnd","RESPONSE","onResponseBody","onResponseEnd","once","free","emit","event","emitEvent","finally","listenerCount","destroy","error","destroyed","_handle","address","writeArgs","headersWritten","shift","chunkString","chunkBeforeRequestHeaders","slice","indexOf","chunkAfterRequestHeaders","rawRequestHeaders","requestHeadersString","filter","name","map","join","headersChunk","tlsProperties","forEach","propertyName","on","session","hadError","respondWith","_chunk72ZIHMEBjs","isPropertyAccessible","type","errorWith","TypeError","mockConnect","serverResponse","ServerResponse","IncomingMessage","assignSocket","removeHeader","rawResponseHeaders","writeHead","STATUS_CODES","reader","getReader","done","createServerErrorResponse","isIPv6","hostname","family","addressInfo","writeCall","MockAgent","Agent","customAgent","createConnectionOptions","MockHttpsAgent","_url","_logger","logger","Logger","DEFAULT_PATH","DEFAULT_PROTOCOL","DEFAULT_HOSTNAME","SSL_PORT","getAgent","agent","getProtocolByRequestOptions","agentProtocol","getPortByRequestOptions","isSecureRequest","cert","uri","Number","defaultPort","getAuthByRequestOptions","isRawIPv6Address","includes","startsWith","endsWith","getHostname","getUrlByRequestOptions","info","authString","portString","logger2","isPlainObject","obj","cloneObject","enumerableProperties","reduce","acc","key","assign","getPrototypeOf","logger3","resolveRequestOptions","urlToHttpOptions","requestOptionsFromUrl","clonedRequestOptions","overrideUrlByRequestOptions","parsedOptionsPath","parse","search","resolveCallback","normalizeClientRequestArgs","defaultProtocol","url2","options2","isObject","legacyUrl","resolvedUrl","Error","_defaultAgent","globalAgent","_ClientRequestInterceptor","Interceptor","symbol","controller","RequestController","isRequestHandled","handleRequest","emitter","onRequestError","onError","emitAsync","setup","ClientRequest","OriginalClientRequest","originalGet","originalRequest","originalHttpsGet","originalHttpsRequest","Agent2","mockAgent","subscriptions","ClientRequestInterceptor"],"sources":["../../src/interceptors/ClientRequest/index.ts","../../src/interceptors/ClientRequest/MockHttpSocket.ts","../../src/interceptors/Socket/MockSocket.ts","../../src/interceptors/Socket/utils/normalizeSocketWriteArgs.ts","../../src/interceptors/Socket/utils/baseUrlFromConnectionOptions.ts","../../src/interceptors/ClientRequest/utils/recordRawHeaders.ts","../../src/interceptors/ClientRequest/agents.ts","../../src/interceptors/ClientRequest/utils/normalizeClientRequestArgs.ts","../../src/utils/getUrlByRequestOptions.ts","../../src/utils/cloneObject.ts"],"sourcesContent":["import http from 'node:http'\nimport https from 'node:https'\nimport { Interceptor } from '../../Interceptor'\nimport type { HttpRequestEventMap } from '../../glossary'\nimport {\n  kRequestId,\n  MockHttpSocketRequestCallback,\n  MockHttpSocketResponseCallback,\n} from './MockHttpSocket'\nimport { MockAgent, MockHttpsAgent } from './agents'\nimport { RequestController } from '../../RequestController'\nimport { emitAsync } from '../../utils/emitAsync'\nimport { normalizeClientRequestArgs } from './utils/normalizeClientRequestArgs'\nimport { handleRequest } from '../../utils/handleRequest'\nimport {\n  recordRawFetchHeaders,\n  restoreHeadersPrototype,\n} from './utils/recordRawHeaders'\n\nexport class ClientRequestInterceptor extends Interceptor<HttpRequestEventMap> {\n  static symbol = Symbol('client-request-interceptor')\n\n  constructor() {\n    super(ClientRequestInterceptor.symbol)\n  }\n\n  protected setup(): void {\n    const {\n      ClientRequest: OriginalClientRequest,\n      get: originalGet,\n      request: originalRequest,\n    } = http\n    const { get: originalHttpsGet, request: originalHttpsRequest } = https\n\n    const onRequest = this.onRequest.bind(this)\n    const onResponse = this.onResponse.bind(this)\n\n    // Support requests performed via the `ClientRequest` constructor directly.\n    http.ClientRequest = new Proxy(http.ClientRequest, {\n      construct: (target, args: Parameters<typeof http.request>) => {\n        const [url, options, callback] = normalizeClientRequestArgs(\n          'http:',\n          args\n        )\n\n        // Create a mock agent instance appropriate for the request protocol.\n        const Agent = options.protocol === 'https:' ? MockHttpsAgent : MockAgent\n        const mockAgent = new Agent({\n          customAgent: options.agent,\n          onRequest,\n          onResponse,\n        })\n        options.agent = mockAgent\n\n        return Reflect.construct(target, [url, options, callback])\n      },\n    })\n\n    http.request = new Proxy(http.request, {\n      apply: (target, thisArg, args: Parameters<typeof http.request>) => {\n        const [url, options, callback] = normalizeClientRequestArgs(\n          'http:',\n          args\n        )\n        const mockAgent = new MockAgent({\n          customAgent: options.agent,\n          onRequest,\n          onResponse,\n        })\n        options.agent = mockAgent\n\n        return Reflect.apply(target, thisArg, [url, options, callback])\n      },\n    })\n\n    http.get = new Proxy(http.get, {\n      apply: (target, thisArg, args: Parameters<typeof http.get>) => {\n        const [url, options, callback] = normalizeClientRequestArgs(\n          'http:',\n          args\n        )\n\n        const mockAgent = new MockAgent({\n          customAgent: options.agent,\n          onRequest,\n          onResponse,\n        })\n        options.agent = mockAgent\n\n        return Reflect.apply(target, thisArg, [url, options, callback])\n      },\n    })\n\n    //\n    // HTTPS.\n    //\n\n    https.request = new Proxy(https.request, {\n      apply: (target, thisArg, args: Parameters<typeof https.request>) => {\n        const [url, options, callback] = normalizeClientRequestArgs(\n          'https:',\n          args\n        )\n\n        const mockAgent = new MockHttpsAgent({\n          customAgent: options.agent,\n          onRequest,\n          onResponse,\n        })\n        options.agent = mockAgent\n\n        return Reflect.apply(target, thisArg, [url, options, callback])\n      },\n    })\n\n    https.get = new Proxy(https.get, {\n      apply: (target, thisArg, args: Parameters<typeof https.get>) => {\n        const [url, options, callback] = normalizeClientRequestArgs(\n          'https:',\n          args\n        )\n\n        const mockAgent = new MockHttpsAgent({\n          customAgent: options.agent,\n          onRequest,\n          onResponse,\n        })\n        options.agent = mockAgent\n\n        return Reflect.apply(target, thisArg, [url, options, callback])\n      },\n    })\n\n    // Spy on `Header.prototype.set` and `Header.prototype.append` calls\n    // and record the raw header names provided. This is to support\n    // `IncomingMessage.prototype.rawHeaders`.\n    recordRawFetchHeaders()\n\n    this.subscriptions.push(() => {\n      http.ClientRequest = OriginalClientRequest\n\n      http.get = originalGet\n      http.request = originalRequest\n\n      https.get = originalHttpsGet\n      https.request = originalHttpsRequest\n\n      restoreHeadersPrototype()\n    })\n  }\n\n  private onRequest: MockHttpSocketRequestCallback = async ({\n    request,\n    socket,\n  }) => {\n    const requestId = Reflect.get(request, kRequestId)\n    const controller = new RequestController(request)\n\n    const isRequestHandled = await handleRequest({\n      request,\n      requestId,\n      controller,\n      emitter: this.emitter,\n      onResponse: (response) => {\n        socket.respondWith(response)\n      },\n      onRequestError: (response) => {\n        socket.respondWith(response)\n      },\n      onError: (error) => {\n        if (error instanceof Error) {\n          socket.errorWith(error)\n        }\n      },\n    })\n\n    if (!isRequestHandled) {\n      return socket.passthrough()\n    }\n  }\n\n  public onResponse: MockHttpSocketResponseCallback = async ({\n    requestId,\n    request,\n    response,\n    isMockedResponse,\n  }) => {\n    // Return the promise to when all the response event listeners\n    // are finished.\n    return emitAsync(this.emitter, 'response', {\n      requestId,\n      request,\n      response,\n      isMockedResponse,\n    })\n  }\n}\n","import net from 'node:net'\nimport {\n  type HeadersCallback,\n  HTTPParser,\n  type RequestHeadersCompleteCallback,\n  type ResponseHeadersCompleteCallback,\n} from '_http_common'\nimport { STATUS_CODES, IncomingMessage, ServerResponse } from 'node:http'\nimport { Readable } from 'node:stream'\nimport { invariant } from 'outvariant'\nimport { INTERNAL_REQUEST_ID_HEADER_NAME } from '../../Interceptor'\nimport { MockSocket } from '../Socket/MockSocket'\nimport type { NormalizedSocketWriteArgs } from '../Socket/utils/normalizeSocketWriteArgs'\nimport { isPropertyAccessible } from '../../utils/isPropertyAccessible'\nimport { baseUrlFromConnectionOptions } from '../Socket/utils/baseUrlFromConnectionOptions'\nimport { createServerErrorResponse } from '../../utils/responseUtils'\nimport { createRequestId } from '../../createRequestId'\nimport { getRawFetchHeaders } from './utils/recordRawHeaders'\nimport { FetchResponse } from '../../utils/fetchUtils'\nimport { setRawRequest } from '../../getRawRequest'\nimport { setRawRequestBodyStream } from '../../utils/node'\n\ntype HttpConnectionOptions = any\n\nexport type MockHttpSocketRequestCallback = (args: {\n  requestId: string\n  request: Request\n  socket: MockHttpSocket\n}) => void\n\nexport type MockHttpSocketResponseCallback = (args: {\n  requestId: string\n  request: Request\n  response: Response\n  isMockedResponse: boolean\n  socket: MockHttpSocket\n}) => Promise<void>\n\ninterface MockHttpSocketOptions {\n  connectionOptions: HttpConnectionOptions\n  createConnection: () => net.Socket\n  onRequest: MockHttpSocketRequestCallback\n  onResponse: MockHttpSocketResponseCallback\n}\n\nexport const kRequestId = Symbol('kRequestId')\n\nexport class MockHttpSocket extends MockSocket {\n  private connectionOptions: HttpConnectionOptions\n  private createConnection: () => net.Socket\n  private baseUrl: URL\n\n  private onRequest: MockHttpSocketRequestCallback\n  private onResponse: MockHttpSocketResponseCallback\n  private responseListenersPromise?: Promise<void>\n\n  private requestRawHeadersBuffer: Array<string> = []\n  private responseRawHeadersBuffer: Array<string> = []\n  private writeBuffer: Array<NormalizedSocketWriteArgs> = []\n  private request?: Request\n  private requestParser: HTTPParser<0>\n  private requestStream?: Readable\n  private shouldKeepAlive?: boolean\n\n  private socketState: 'unknown' | 'mock' | 'passthrough' = 'unknown'\n  private responseParser: HTTPParser<1>\n  private responseStream?: Readable\n  private originalSocket?: net.Socket\n\n  constructor(options: MockHttpSocketOptions) {\n    super({\n      write: (chunk, encoding, callback) => {\n        // Buffer the writes so they can be flushed in case of the original connection\n        // and when reading the request body in the interceptor. If the connection has\n        // been established, no need to buffer the chunks anymore, they will be forwarded.\n        if (this.socketState !== 'passthrough') {\n          this.writeBuffer.push([chunk, encoding, callback])\n        }\n\n        if (chunk) {\n          /**\n           * Forward any writes to the mock socket to the underlying original socket.\n           * This ensures functional duplex connections, like WebSocket.\n           * @see https://github.com/mswjs/interceptors/issues/682\n           */\n          if (this.socketState === 'passthrough') {\n            this.originalSocket?.write(chunk, encoding, callback)\n          }\n\n          this.requestParser.execute(\n            Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk, encoding)\n          )\n        }\n      },\n      read: (chunk) => {\n        if (chunk !== null) {\n          /**\n           * @todo We need to free the parser if the connection has been\n           * upgraded to a non-HTTP protocol. It won't be able to parse data\n           * from that point onward anyway. No need to keep it in memory.\n           */\n          this.responseParser.execute(\n            Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk)\n          )\n        }\n      },\n    })\n\n    this.connectionOptions = options.connectionOptions\n    this.createConnection = options.createConnection\n    this.onRequest = options.onRequest\n    this.onResponse = options.onResponse\n\n    this.baseUrl = baseUrlFromConnectionOptions(this.connectionOptions)\n\n    // Request parser.\n    this.requestParser = new HTTPParser()\n    this.requestParser.initialize(HTTPParser.REQUEST, {})\n    this.requestParser[HTTPParser.kOnHeaders] = this.onRequestHeaders.bind(this)\n    this.requestParser[HTTPParser.kOnHeadersComplete] =\n      this.onRequestStart.bind(this)\n    this.requestParser[HTTPParser.kOnBody] = this.onRequestBody.bind(this)\n    this.requestParser[HTTPParser.kOnMessageComplete] =\n      this.onRequestEnd.bind(this)\n\n    // Response parser.\n    this.responseParser = new HTTPParser()\n    this.responseParser.initialize(HTTPParser.RESPONSE, {})\n    this.responseParser[HTTPParser.kOnHeaders] =\n      this.onResponseHeaders.bind(this)\n    this.responseParser[HTTPParser.kOnHeadersComplete] =\n      this.onResponseStart.bind(this)\n    this.responseParser[HTTPParser.kOnBody] = this.onResponseBody.bind(this)\n    this.responseParser[HTTPParser.kOnMessageComplete] =\n      this.onResponseEnd.bind(this)\n\n    // Once the socket is finished, nothing can write to it\n    // anymore. It has also flushed any buffered chunks.\n    this.once('finish', () => this.requestParser.free())\n\n    if (this.baseUrl.protocol === 'https:') {\n      Reflect.set(this, 'encrypted', true)\n      // The server certificate is not the same as a CA\n      // passed to the TLS socket connection options.\n      Reflect.set(this, 'authorized', false)\n      Reflect.set(this, 'getProtocol', () => 'TLSv1.3')\n      Reflect.set(this, 'getSession', () => undefined)\n      Reflect.set(this, 'isSessionReused', () => false)\n    }\n  }\n\n  public emit(event: string | symbol, ...args: any[]): boolean {\n    const emitEvent = super.emit.bind(this, event as any, ...args)\n\n    if (this.responseListenersPromise) {\n      this.responseListenersPromise.finally(emitEvent)\n      return this.listenerCount(event) > 0\n    }\n\n    return emitEvent()\n  }\n\n  public destroy(error?: Error | undefined): this {\n    // Destroy the response parser when the socket gets destroyed.\n    // Normally, we should listen to the \"close\" event but it\n    // can be suppressed by using the \"emitClose: false\" option.\n    this.responseParser.free()\n\n    if (error) {\n      this.emit('error', error)\n    }\n\n    return super.destroy(error)\n  }\n\n  /**\n   * Establish this Socket connection as-is and pipe\n   * its data/events through this Socket.\n   */\n  public passthrough(): void {\n    this.socketState = 'passthrough'\n\n    if (this.destroyed) {\n      return\n    }\n\n    const socket = this.createConnection()\n    this.originalSocket = socket\n\n    /**\n     * @note Inherit the original socket's connection handle.\n     * Without this, each push to the mock socket results in a\n     * new \"connection\" listener being added (i.e. buffering pushes).\n     * @see https://github.com/nodejs/node/blob/b18153598b25485ce4f54d0c5cb830a9457691ee/lib/net.js#L734\n     */\n    if ('_handle' in socket) {\n      Object.defineProperty(this, '_handle', {\n        value: socket._handle,\n        enumerable: true,\n        writable: true,\n      })\n    }\n\n    // If the developer destroys the socket, destroy the original connection.\n    this.once('error', (error) => {\n      socket.destroy(error)\n    })\n\n    this.address = socket.address.bind(socket)\n\n    // Flush the buffered \"socket.write()\" calls onto\n    // the original socket instance (i.e. write request body).\n    // Exhaust the \"requestBuffer\" in case this Socket\n    // gets reused for different requests.\n    let writeArgs: NormalizedSocketWriteArgs | undefined\n    let headersWritten = false\n\n    while ((writeArgs = this.writeBuffer.shift())) {\n      if (writeArgs !== undefined) {\n        if (!headersWritten) {\n          const [chunk, encoding, callback] = writeArgs\n          const chunkString = chunk.toString()\n          const chunkBeforeRequestHeaders = chunkString.slice(\n            0,\n            chunkString.indexOf('\\r\\n') + 2\n          )\n          const chunkAfterRequestHeaders = chunkString.slice(\n            chunk.indexOf('\\r\\n\\r\\n')\n          )\n          const rawRequestHeaders = getRawFetchHeaders(this.request!.headers)\n          const requestHeadersString = rawRequestHeaders\n            // Skip the internal request ID deduplication header.\n            .filter(([name]) => {\n              return name.toLowerCase() !== INTERNAL_REQUEST_ID_HEADER_NAME\n            })\n            .map(([name, value]) => `${name}: ${value}`)\n            .join('\\r\\n')\n\n          // Modify the HTTP request message headers\n          // to reflect any changes to the request headers\n          // from the \"request\" event listener.\n          const headersChunk = `${chunkBeforeRequestHeaders}${requestHeadersString}${chunkAfterRequestHeaders}`\n          socket.write(headersChunk, encoding, callback)\n          headersWritten = true\n          continue\n        }\n\n        socket.write(...writeArgs)\n      }\n    }\n\n    // Forward TLS Socket properties onto this Socket instance\n    // in the case of a TLS/SSL connection.\n    if (Reflect.get(socket, 'encrypted')) {\n      const tlsProperties = [\n        'encrypted',\n        'authorized',\n        'getProtocol',\n        'getSession',\n        'isSessionReused',\n      ]\n\n      tlsProperties.forEach((propertyName) => {\n        Object.defineProperty(this, propertyName, {\n          enumerable: true,\n          get: () => {\n            const value = Reflect.get(socket, propertyName)\n            return typeof value === 'function' ? value.bind(socket) : value\n          },\n        })\n      })\n    }\n\n    socket\n      .on('lookup', (...args) => this.emit('lookup', ...args))\n      .on('connect', () => {\n        this.connecting = socket.connecting\n        this.emit('connect')\n      })\n      .on('secureConnect', () => this.emit('secureConnect'))\n      .on('secure', () => this.emit('secure'))\n      .on('session', (session) => this.emit('session', session))\n      .on('ready', () => this.emit('ready'))\n      .on('drain', () => this.emit('drain'))\n      .on('data', (chunk) => {\n        // Push the original response to this socket\n        // so it triggers the HTTP response parser. This unifies\n        // the handling pipeline for original and mocked response.\n        this.push(chunk)\n      })\n      .on('error', (error) => {\n        Reflect.set(this, '_hadError', Reflect.get(socket, '_hadError'))\n        this.emit('error', error)\n      })\n      .on('resume', () => this.emit('resume'))\n      .on('timeout', () => this.emit('timeout'))\n      .on('prefinish', () => this.emit('prefinish'))\n      .on('finish', () => this.emit('finish'))\n      .on('close', (hadError) => this.emit('close', hadError))\n      .on('end', () => this.emit('end'))\n  }\n\n  /**\n   * Convert the given Fetch API `Response` instance to an\n   * HTTP message and push it to the socket.\n   */\n  public async respondWith(response: Response): Promise<void> {\n    // Ignore the mocked response if the socket has been destroyed\n    // (e.g. aborted or timed out),\n    if (this.destroyed) {\n      return\n    }\n\n    // Handle \"type: error\" responses.\n    if (isPropertyAccessible(response, 'type') && response.type === 'error') {\n      this.errorWith(new TypeError('Network error'))\n      return\n    }\n\n    // First, emit all the connection events\n    // to emulate a successful connection.\n    this.mockConnect()\n    this.socketState = 'mock'\n\n    // Flush the write buffer to trigger write callbacks\n    // if it hasn't been flushed already (e.g. someone started reading request stream).\n    this.flushWriteBuffer()\n\n    // Create a `ServerResponse` instance to delegate HTTP message parsing,\n    // Transfer-Encoding, and other things to Node.js internals.\n    const serverResponse = new ServerResponse(new IncomingMessage(this))\n\n    /**\n     * Assign a mock socket instance to the server response to\n     * spy on the response chunk writes. Push the transformed response chunks\n     * to this `MockHttpSocket` instance to trigger the \"data\" event.\n     * @note Providing the same `MockSocket` instance when creating `ServerResponse`\n     * does not have the same effect.\n     * @see https://github.com/nodejs/node/blob/10099bb3f7fd97bb9dd9667188426866b3098e07/test/parallel/test-http-server-response-standalone.js#L32\n     */\n    serverResponse.assignSocket(\n      new MockSocket({\n        write: (chunk, encoding, callback) => {\n          this.push(chunk, encoding)\n          callback?.()\n        },\n        read() {},\n      })\n    )\n\n    /**\n     * @note Remove the `Connection` and `Date` response headers\n     * injected by `ServerResponse` by default. Those are required\n     * from the server but the interceptor is NOT technically a server.\n     * It's confusing to add response headers that the developer didn't\n     * specify themselves. They can always add these if they wish.\n     * @see https://www.rfc-editor.org/rfc/rfc9110#field.date\n     * @see https://www.rfc-editor.org/rfc/rfc9110#field.connection\n     */\n    serverResponse.removeHeader('connection')\n    serverResponse.removeHeader('date')\n\n    const rawResponseHeaders = getRawFetchHeaders(response.headers)\n\n    /**\n     * @note Call `.writeHead` in order to set the raw response headers\n     * in the same case as they were provided by the developer. Using\n     * `.setHeader()`/`.appendHeader()` normalizes header names.\n     */\n    serverResponse.writeHead(\n      response.status,\n      response.statusText || STATUS_CODES[response.status],\n      rawResponseHeaders\n    )\n\n    // If the developer destroy the socket, gracefully destroy the response.\n    this.once('error', () => {\n      serverResponse.destroy()\n    })\n\n    if (response.body) {\n      try {\n        const reader = response.body.getReader()\n\n        while (true) {\n          const { done, value } = await reader.read()\n\n          if (done) {\n            serverResponse.end()\n            break\n          }\n\n          serverResponse.write(value)\n        }\n      } catch (error) {\n        // Coerce response stream errors to 500 responses.\n        this.respondWith(createServerErrorResponse(error))\n        return\n      }\n    } else {\n      serverResponse.end()\n    }\n\n    // Close the socket if the connection wasn't marked as keep-alive.\n    if (!this.shouldKeepAlive) {\n      this.emit('readable')\n\n      /**\n       * @todo @fixme This is likely a hack.\n       * Since we push null to the socket, it never propagates to the\n       * parser, and the parser never calls \"onResponseEnd\" to close\n       * the response stream. We are closing the stream here manually\n       * but that shouldn't be the case.\n       */\n      this.responseStream?.push(null)\n      this.push(null)\n    }\n  }\n\n  /**\n   * Close this socket connection with the given error.\n   */\n  public errorWith(error?: Error): void {\n    this.destroy(error)\n  }\n\n  private mockConnect(): void {\n    // Calling this method immediately puts the socket\n    // into the connected state.\n    this.connecting = false\n\n    const isIPv6 =\n      net.isIPv6(this.connectionOptions.hostname) ||\n      this.connectionOptions.family === 6\n    const addressInfo = {\n      address: isIPv6 ? '::1' : '127.0.0.1',\n      family: isIPv6 ? 'IPv6' : 'IPv4',\n      port: this.connectionOptions.port,\n    }\n    // Return fake address information for the socket.\n    this.address = () => addressInfo\n    this.emit(\n      'lookup',\n      null,\n      addressInfo.address,\n      addressInfo.family === 'IPv6' ? 6 : 4,\n      this.connectionOptions.host\n    )\n    this.emit('connect')\n    this.emit('ready')\n\n    if (this.baseUrl.protocol === 'https:') {\n      this.emit('secure')\n      this.emit('secureConnect')\n\n      // A single TLS connection is represented by two \"session\" events.\n      this.emit(\n        'session',\n        this.connectionOptions.session ||\n          Buffer.from('mock-session-renegotiate')\n      )\n      this.emit('session', Buffer.from('mock-session-resume'))\n    }\n  }\n\n  private flushWriteBuffer(): void {\n    for (const writeCall of this.writeBuffer) {\n      if (typeof writeCall[2] === 'function') {\n        writeCall[2]()\n        /**\n         * @note Remove the callback from the write call\n         * so it doesn't get called twice on passthrough\n         * if `request.end()` was called within `request.write()`.\n         * @see https://github.com/mswjs/interceptors/issues/684\n         */\n        writeCall[2] = undefined\n      }\n    }\n  }\n\n  /**\n   * This callback might be called when the request is \"slow\":\n   * - Request headers were fragmented across multiple TCP packages;\n   * - Request headers were too large to be processed in a single run\n   * (e.g. more than 30 request headers).\n   * @note This is called before request start.\n   */\n  private onRequestHeaders: HeadersCallback = (rawHeaders) => {\n    this.requestRawHeadersBuffer.push(...rawHeaders)\n  }\n\n  private onRequestStart: RequestHeadersCompleteCallback = (\n    versionMajor,\n    versionMinor,\n    rawHeaders,\n    _,\n    path,\n    __,\n    ___,\n    ____,\n    shouldKeepAlive\n  ) => {\n    this.shouldKeepAlive = shouldKeepAlive\n\n    const url = new URL(path || '', this.baseUrl)\n    const method = this.connectionOptions.method?.toUpperCase() || 'GET'\n    const headers = FetchResponse.parseRawHeaders([\n      ...this.requestRawHeadersBuffer,\n      ...(rawHeaders || []),\n    ])\n    this.requestRawHeadersBuffer.length = 0\n\n    const canHaveBody = method !== 'GET' && method !== 'HEAD'\n\n    // Translate the basic authorization in the URL to the request header.\n    // Constructing a Request instance with a URL containing auth is no-op.\n    if (url.username || url.password) {\n      if (!headers.has('authorization')) {\n        headers.set('authorization', `Basic ${url.username}:${url.password}`)\n      }\n      url.username = ''\n      url.password = ''\n    }\n\n    // Create a new stream for each request.\n    // If this Socket is reused for multiple requests,\n    // this ensures that each request gets its own stream.\n    // One Socket instance can only handle one request at a time.\n    this.requestStream = new Readable({\n      /**\n       * @note Provide the `read()` method so a `Readable` could be\n       * used as the actual request body (the stream calls \"read()\").\n       * We control the queue in the onRequestBody/End functions.\n       */\n      read: () => {\n        // If the user attempts to read the request body,\n        // flush the write buffer to trigger the callbacks.\n        // This way, if the request stream ends in the write callback,\n        // it will indeed end correctly.\n        this.flushWriteBuffer()\n      },\n    })\n\n    const requestId = createRequestId()\n    this.request = new Request(url, {\n      method,\n      headers,\n      credentials: 'same-origin',\n      // @ts-expect-error Undocumented Fetch property.\n      duplex: canHaveBody ? 'half' : undefined,\n      body: canHaveBody ? (Readable.toWeb(this.requestStream!) as any) : null,\n    })\n\n    Reflect.set(this.request, kRequestId, requestId)\n\n    // Set the raw `http.ClientRequest` instance on the request instance.\n    // This is useful for cases like getting the raw headers of the request.\n    setRawRequest(this.request, Reflect.get(this, '_httpMessage'))\n\n    // Create a copy of the request body stream and store it on the request.\n    // This is only needed for the consumers who wish to read the request body stream\n    // of requests that cannot have a body per Fetch API specification (i.e. GET, HEAD).\n    setRawRequestBodyStream(this.request, this.requestStream)\n\n    // Skip handling the request that's already being handled\n    // by another (parent) interceptor. For example, XMLHttpRequest\n    // is often implemented via ClientRequest in Node.js (e.g. JSDOM).\n    // In that case, XHR interceptor will bubble down to the ClientRequest\n    // interceptor. No need to try to handle that request again.\n    /**\n     * @fixme Stop relying on the \"X-Request-Id\" request header\n     * to figure out if one interceptor has been invoked within another.\n     * @see https://github.com/mswjs/interceptors/issues/378\n     */\n    if (this.request.headers.has(INTERNAL_REQUEST_ID_HEADER_NAME)) {\n      this.passthrough()\n      return\n    }\n\n    this.onRequest({\n      requestId,\n      request: this.request,\n      socket: this,\n    })\n  }\n\n  private onRequestBody(chunk: Buffer): void {\n    invariant(\n      this.requestStream,\n      'Failed to write to a request stream: stream does not exist'\n    )\n\n    this.requestStream.push(chunk)\n  }\n\n  private onRequestEnd(): void {\n    // Request end can be called for requests without body.\n    if (this.requestStream) {\n      this.requestStream.push(null)\n    }\n  }\n\n  /**\n   * This callback might be called when the response is \"slow\":\n   * - Response headers were fragmented across multiple TCP packages;\n   * - Response headers were too large to be processed in a single run\n   * (e.g. more than 30 response headers).\n   * @note This is called before response start.\n   */\n  private onResponseHeaders: HeadersCallback = (rawHeaders) => {\n    this.responseRawHeadersBuffer.push(...rawHeaders)\n  }\n\n  private onResponseStart: ResponseHeadersCompleteCallback = (\n    versionMajor,\n    versionMinor,\n    rawHeaders,\n    method,\n    url,\n    status,\n    statusText\n  ) => {\n    const headers = FetchResponse.parseRawHeaders([\n      ...this.responseRawHeadersBuffer,\n      ...(rawHeaders || []),\n    ])\n    this.responseRawHeadersBuffer.length = 0\n\n    const response = new FetchResponse(\n      /**\n       * @note The Fetch API response instance exposed to the consumer\n       * is created over the response stream of the HTTP parser. It is NOT\n       * related to the Socket instance. This way, you can read response body\n       * in response listener while the Socket instance delays the emission\n       * of \"end\" and other events until those response listeners are finished.\n       */\n      FetchResponse.isResponseWithBody(status)\n        ? (Readable.toWeb(\n            (this.responseStream = new Readable({ read() {} }))\n          ) as any)\n        : null,\n      {\n        url,\n        status,\n        statusText,\n        headers,\n      }\n    )\n\n    invariant(\n      this.request,\n      'Failed to handle a response: request does not exist'\n    )\n\n    FetchResponse.setUrl(this.request.url, response)\n\n    /**\n     * @fixme Stop relying on the \"X-Request-Id\" request header\n     * to figure out if one interceptor has been invoked within another.\n     * @see https://github.com/mswjs/interceptors/issues/378\n     */\n    if (this.request.headers.has(INTERNAL_REQUEST_ID_HEADER_NAME)) {\n      return\n    }\n\n    this.responseListenersPromise = this.onResponse({\n      response,\n      isMockedResponse: this.socketState === 'mock',\n      requestId: Reflect.get(this.request, kRequestId),\n      request: this.request,\n      socket: this,\n    })\n  }\n\n  private onResponseBody(chunk: Buffer) {\n    invariant(\n      this.responseStream,\n      'Failed to write to a response stream: stream does not exist'\n    )\n\n    this.responseStream.push(chunk)\n  }\n\n  private onResponseEnd(): void {\n    // Response end can be called for responses without body.\n    if (this.responseStream) {\n      this.responseStream.push(null)\n    }\n  }\n}\n","import net from 'node:net'\nimport {\n  normalizeSocketWriteArgs,\n  type WriteArgs,\n  type WriteCallback,\n} from './utils/normalizeSocketWriteArgs'\n\nexport interface MockSocketOptions {\n  write: (\n    chunk: Buffer | string,\n    encoding: BufferEncoding | undefined,\n    callback?: WriteCallback\n  ) => void\n\n  read: (chunk: Buffer, encoding: BufferEncoding | undefined) => void\n}\n\nexport class MockSocket extends net.Socket {\n  public connecting: boolean\n\n  constructor(protected readonly options: MockSocketOptions) {\n    super()\n    this.connecting = false\n    this.connect()\n\n    this._final = (callback) => {\n      callback(null)\n    }\n  }\n\n  public connect() {\n    // The connection will remain pending until\n    // the consumer decides to handle it.\n    this.connecting = true\n    return this\n  }\n\n  public write(...args: Array<unknown>): boolean {\n    const [chunk, encoding, callback] = normalizeSocketWriteArgs(\n      args as WriteArgs\n    )\n    this.options.write(chunk, encoding, callback)\n    return true\n  }\n\n  public end(...args: Array<unknown>) {\n    const [chunk, encoding, callback] = normalizeSocketWriteArgs(\n      args as WriteArgs\n    )\n    this.options.write(chunk, encoding, callback)\n    return super.end.apply(this, args as any)\n  }\n\n  public push(chunk: any, encoding?: BufferEncoding): boolean {\n    this.options.read(chunk, encoding)\n    return super.push(chunk, encoding)\n  }\n}\n","export type WriteCallback = (error?: Error | null) => void\n\nexport type WriteArgs =\n  | [chunk: unknown, callback?: WriteCallback]\n  | [chunk: unknown, encoding: BufferEncoding, callback?: WriteCallback]\n\nexport type NormalizedSocketWriteArgs = [\n  chunk: any,\n  encoding?: BufferEncoding,\n  callback?: WriteCallback,\n]\n\n/**\n * Normalizes the arguments provided to the `Writable.prototype.write()`\n * and `Writable.prototype.end()`.\n */\nexport function normalizeSocketWriteArgs(\n  args: WriteArgs\n): NormalizedSocketWriteArgs {\n  const normalized: NormalizedSocketWriteArgs = [args[0], undefined, undefined]\n\n  if (typeof args[1] === 'string') {\n    normalized[1] = args[1]\n  } else if (typeof args[1] === 'function') {\n    normalized[2] = args[1]\n  }\n\n  if (typeof args[2] === 'function') {\n    normalized[2] = args[2]\n  }\n\n  return normalized\n}\n","export function baseUrlFromConnectionOptions(options: any): URL {\n  if ('href' in options) {\n    return new URL(options.href)\n  }\n\n  const protocol = options.port === 443 ? 'https:' : 'http:'\n  const host = options.host\n\n  const url = new URL(`${protocol}//${host}`)\n\n  if (options.port) {\n    url.port = options.port.toString()\n  }\n\n  if (options.path) {\n    url.pathname = options.path\n  }\n\n  if (options.auth) {\n    const [username, password] = options.auth.split(':')\n    url.username = username\n    url.password = password\n  }\n\n  return url\n}\n","type HeaderTuple = [string, string]\ntype RawHeaders = Array<HeaderTuple>\ntype SetHeaderBehavior = 'set' | 'append'\n\nconst kRawHeaders = Symbol('kRawHeaders')\nconst kRestorePatches = Symbol('kRestorePatches')\n\nfunction recordRawHeader(\n  headers: Headers,\n  args: HeaderTuple,\n  behavior: SetHeaderBehavior\n) {\n  ensureRawHeadersSymbol(headers, [])\n  const rawHeaders = Reflect.get(headers, kRawHeaders) as RawHeaders\n\n  if (behavior === 'set') {\n    // When recording a set header, ensure we remove any matching existing headers.\n    for (let index = rawHeaders.length - 1; index >= 0; index--) {\n      if (rawHeaders[index][0].toLowerCase() === args[0].toLowerCase()) {\n        rawHeaders.splice(index, 1)\n      }\n    }\n  }\n\n  rawHeaders.push(args)\n}\n\n/**\n * Define the raw headers symbol on the given `Headers` instance.\n * If the symbol already exists, this function does nothing.\n */\nfunction ensureRawHeadersSymbol(\n  headers: Headers,\n  rawHeaders: RawHeaders\n): void {\n  if (Reflect.has(headers, kRawHeaders)) {\n    return\n  }\n\n  defineRawHeadersSymbol(headers, rawHeaders)\n}\n\n/**\n * Define the raw headers symbol on the given `Headers` instance.\n * If the symbol already exists, it gets overridden.\n */\nfunction defineRawHeadersSymbol(headers: Headers, rawHeaders: RawHeaders) {\n  Object.defineProperty(headers, kRawHeaders, {\n    value: rawHeaders,\n    enumerable: false,\n    // Mark the symbol as configurable so its value can be overridden.\n    // Overrides happen when merging raw headers from multiple sources.\n    // E.g. new Request(new Request(url, { headers }), { headers })\n    configurable: true,\n  })\n}\n\n/**\n * Patch the global `Headers` class to store raw headers.\n * This is for compatibility with `IncomingMessage.prototype.rawHeaders`.\n *\n * @note Node.js has their own raw headers symbol but it\n * only records the first header name in case of multi-value headers.\n * Any other headers are normalized before comparing. This makes it\n * incompatible with the `rawHeaders` format.\n *\n * let h = new Headers()\n * h.append('X-Custom', 'one')\n * h.append('x-custom', 'two')\n * h[Symbol('headers map')] // Map { 'X-Custom' => 'one, two' }\n */\nexport function recordRawFetchHeaders() {\n  // Prevent patching the Headers prototype multiple times.\n  if (Reflect.get(Headers, kRestorePatches)) {\n    return Reflect.get(Headers, kRestorePatches)\n  }\n\n  const {\n    Headers: OriginalHeaders,\n    Request: OriginalRequest,\n    Response: OriginalResponse,\n  } = globalThis\n  const { set, append, delete: headersDeleteMethod } = Headers.prototype\n\n  Object.defineProperty(Headers, kRestorePatches, {\n    value: () => {\n      Headers.prototype.set = set\n      Headers.prototype.append = append\n      Headers.prototype.delete = headersDeleteMethod\n      globalThis.Headers = OriginalHeaders\n\n      globalThis.Request = OriginalRequest\n      globalThis.Response = OriginalResponse\n\n      Reflect.deleteProperty(Headers, kRestorePatches)\n    },\n    enumerable: false,\n    /**\n     * @note Mark this property as configurable\n     * so we can delete it using `Reflect.delete` during cleanup.\n     */\n    configurable: true,\n  })\n\n  Object.defineProperty(globalThis, 'Headers', {\n    enumerable: true,\n    writable: true,\n    value: new Proxy(Headers, {\n      construct(target, args, newTarget) {\n        const headersInit = args[0] || []\n\n        if (\n          headersInit instanceof Headers &&\n          Reflect.has(headersInit, kRawHeaders)\n        ) {\n          const headers = Reflect.construct(\n            target,\n            [Reflect.get(headersInit, kRawHeaders)],\n            newTarget\n          )\n          ensureRawHeadersSymbol(headers, [\n            /**\n             * @note Spread the retrieved headers to clone them.\n             * This prevents multiple Headers instances from pointing\n             * at the same internal \"rawHeaders\" array.\n             */\n            ...Reflect.get(headersInit, kRawHeaders),\n          ])\n          return headers\n        }\n\n        const headers = Reflect.construct(target, args, newTarget)\n\n        // Request/Response constructors will set the symbol\n        // upon creating a new instance, using the raw developer\n        // input as the raw headers. Skip the symbol altogether\n        // in those cases because the input to Headers will be normalized.\n        if (!Reflect.has(headers, kRawHeaders)) {\n          const rawHeadersInit = Array.isArray(headersInit)\n            ? headersInit\n            : Object.entries(headersInit)\n          ensureRawHeadersSymbol(headers, rawHeadersInit)\n        }\n\n        return headers\n      },\n    }),\n  })\n\n  Headers.prototype.set = new Proxy(Headers.prototype.set, {\n    apply(target, thisArg, args: HeaderTuple) {\n      recordRawHeader(thisArg, args, 'set')\n      return Reflect.apply(target, thisArg, args)\n    },\n  })\n\n  Headers.prototype.append = new Proxy(Headers.prototype.append, {\n    apply(target, thisArg, args: HeaderTuple) {\n      recordRawHeader(thisArg, args, 'append')\n      return Reflect.apply(target, thisArg, args)\n    },\n  })\n\n  Headers.prototype.delete = new Proxy(Headers.prototype.delete, {\n    apply(target, thisArg, args: [string]) {\n      const rawHeaders = Reflect.get(thisArg, kRawHeaders) as RawHeaders\n\n      if (rawHeaders) {\n        for (let index = rawHeaders.length - 1; index >= 0; index--) {\n          if (rawHeaders[index][0].toLowerCase() === args[0].toLowerCase()) {\n            rawHeaders.splice(index, 1)\n          }\n        }\n      }\n\n      return Reflect.apply(target, thisArg, args)\n    },\n  })\n\n  Object.defineProperty(globalThis, 'Request', {\n    enumerable: true,\n    writable: true,\n    value: new Proxy(Request, {\n      construct(target, args, newTarget) {\n        const request = Reflect.construct(target, args, newTarget)\n        const inferredRawHeaders: RawHeaders = []\n\n        // Infer raw headers from a `Request` instance used as init.\n        if (typeof args[0] === 'object' && args[0].headers != null) {\n          inferredRawHeaders.push(...inferRawHeaders(args[0].headers))\n        }\n\n        // Infer raw headers from the \"headers\" init argument.\n        if (typeof args[1] === 'object' && args[1].headers != null) {\n          inferredRawHeaders.push(...inferRawHeaders(args[1].headers))\n        }\n\n        if (inferredRawHeaders.length > 0) {\n          ensureRawHeadersSymbol(request.headers, inferredRawHeaders)\n        }\n\n        return request\n      },\n    }),\n  })\n\n  Object.defineProperty(globalThis, 'Response', {\n    enumerable: true,\n    writable: true,\n    value: new Proxy(Response, {\n      construct(target, args, newTarget) {\n        const response = Reflect.construct(target, args, newTarget)\n\n        if (typeof args[1] === 'object' && args[1].headers != null) {\n          ensureRawHeadersSymbol(\n            response.headers,\n            inferRawHeaders(args[1].headers)\n          )\n        }\n\n        return response\n      },\n    }),\n  })\n}\n\nexport function restoreHeadersPrototype() {\n  if (!Reflect.get(Headers, kRestorePatches)) {\n    return\n  }\n\n  Reflect.get(Headers, kRestorePatches)()\n}\n\nexport function getRawFetchHeaders(headers: Headers): RawHeaders {\n  // If the raw headers recording failed for some reason,\n  // use the normalized header entries instead.\n  if (!Reflect.has(headers, kRawHeaders)) {\n    return Array.from(headers.entries())\n  }\n\n  const rawHeaders = Reflect.get(headers, kRawHeaders) as RawHeaders\n  return rawHeaders.length > 0 ? rawHeaders : Array.from(headers.entries())\n}\n\n/**\n * Infers the raw headers from the given `HeadersInit` provided\n * to the Request/Response constructor.\n *\n * If the `init.headers` is a Headers instance, use it directly.\n * That means the headers were created standalone and already have\n * the raw headers stored.\n * If the `init.headers` is a HeadersInit, create a new Headers\n * instance out of it.\n */\nfunction inferRawHeaders(headers: HeadersInit): RawHeaders {\n  if (headers instanceof Headers) {\n    return Reflect.get(headers, kRawHeaders) || []\n  }\n\n  return Reflect.get(new Headers(headers), kRawHeaders)\n}\n","/**\n * Here's how requests are handled in Node.js:\n *\n * 1. http.ClientRequest instance calls `agent.addRequest(request, options, cb)`.\n * 2. Agent creates a new socket: `agent.createSocket(options, cb)`.\n * 3. Agent creates a new connection: `agent.createConnection(options, cb)`.\n */\nimport net from 'node:net'\nimport http from 'node:http'\nimport https from 'node:https'\nimport {\n  MockHttpSocket,\n  type MockHttpSocketRequestCallback,\n  type MockHttpSocketResponseCallback,\n} from './MockHttpSocket'\n\ndeclare module 'node:http' {\n  interface Agent {\n    options?: http.AgentOptions\n    createConnection(options: any, callback: any): net.Socket\n  }\n}\n\ninterface MockAgentOptions {\n  customAgent?: http.RequestOptions['agent']\n  onRequest: MockHttpSocketRequestCallback\n  onResponse: MockHttpSocketResponseCallback\n}\n\nexport class MockAgent extends http.Agent {\n  private customAgent?: http.RequestOptions['agent']\n  private onRequest: MockHttpSocketRequestCallback\n  private onResponse: MockHttpSocketResponseCallback\n\n  constructor(options: MockAgentOptions) {\n    super()\n    this.customAgent = options.customAgent\n    this.onRequest = options.onRequest\n    this.onResponse = options.onResponse\n  }\n\n  public createConnection(options: any, callback: any): net.Socket {\n    const createConnection =\n      this.customAgent instanceof http.Agent\n        ? this.customAgent.createConnection\n        : super.createConnection\n\n    const createConnectionOptions =\n      this.customAgent instanceof http.Agent\n        ? {\n            ...options,\n            ...this.customAgent.options,\n          }\n        : options\n\n    const socket = new MockHttpSocket({\n      connectionOptions: options,\n      createConnection: createConnection.bind(\n        this.customAgent || this,\n        createConnectionOptions,\n        callback\n      ),\n      onRequest: this.onRequest.bind(this),\n      onResponse: this.onResponse.bind(this),\n    })\n\n    return socket\n  }\n}\n\nexport class MockHttpsAgent extends https.Agent {\n  private customAgent?: https.RequestOptions['agent']\n  private onRequest: MockHttpSocketRequestCallback\n  private onResponse: MockHttpSocketResponseCallback\n\n  constructor(options: MockAgentOptions) {\n    super()\n    this.customAgent = options.customAgent\n    this.onRequest = options.onRequest\n    this.onResponse = options.onResponse\n  }\n\n  public createConnection(options: any, callback: any): net.Socket {\n    const createConnection =\n      this.customAgent instanceof http.Agent\n        ? this.customAgent.createConnection\n        : super.createConnection\n\n    const createConnectionOptions =\n      this.customAgent instanceof http.Agent\n        ? {\n            ...options,\n            ...this.customAgent.options,\n          }\n        : options\n\n    const socket = new MockHttpSocket({\n      connectionOptions: options,\n      createConnection: createConnection.bind(\n        this.customAgent || this,\n        createConnectionOptions,\n        callback\n      ),\n      onRequest: this.onRequest.bind(this),\n      onResponse: this.onResponse.bind(this),\n    })\n\n    return socket\n  }\n}\n","import { urlToHttpOptions } from 'node:url'\nimport {\n  Agent as HttpAgent,\n  globalAgent as httpGlobalAgent,\n  IncomingMessage,\n} from 'node:http'\nimport {\n  RequestOptions,\n  Agent as HttpsAgent,\n  globalAgent as httpsGlobalAgent,\n} from 'node:https'\nimport {\n  /**\n   * @note Use the Node.js URL instead of the global URL\n   * because environments like JSDOM may override the global,\n   * breaking the compatibility with Node.js.\n   * @see https://github.com/node-fetch/node-fetch/issues/1376#issuecomment-966435555\n   */\n  URL,\n  Url as LegacyURL,\n  parse as parseUrl,\n} from 'node:url'\nimport { Logger } from '@open-draft/logger'\nimport {\n  ResolvedRequestOptions,\n  getUrlByRequestOptions,\n} from '../../../utils/getUrlByRequestOptions'\nimport { cloneObject } from '../../../utils/cloneObject'\nimport { isObject } from '../../../utils/isObject'\n\nconst logger = new Logger('http normalizeClientRequestArgs')\n\nexport type HttpRequestCallback = (response: IncomingMessage) => void\n\nexport type ClientRequestArgs =\n  // Request without any arguments is also possible.\n  | []\n  | [string | URL | LegacyURL, HttpRequestCallback?]\n  | [string | URL | LegacyURL, RequestOptions, HttpRequestCallback?]\n  | [RequestOptions, HttpRequestCallback?]\n\nfunction resolveRequestOptions(\n  args: ClientRequestArgs,\n  url: URL\n): RequestOptions {\n  // Calling `fetch` provides only URL to `ClientRequest`\n  // without any `RequestOptions` or callback.\n  if (typeof args[1] === 'undefined' || typeof args[1] === 'function') {\n    logger.info('request options not provided, deriving from the url', url)\n    return urlToHttpOptions(url)\n  }\n\n  if (args[1]) {\n    logger.info('has custom RequestOptions!', args[1])\n    const requestOptionsFromUrl = urlToHttpOptions(url)\n\n    logger.info('derived RequestOptions from the URL:', requestOptionsFromUrl)\n\n    /**\n     * Clone the request options to lock their state\n     * at the moment they are provided to `ClientRequest`.\n     * @see https://github.com/mswjs/interceptors/issues/86\n     */\n    logger.info('cloning RequestOptions...')\n    const clonedRequestOptions = cloneObject(args[1])\n    logger.info('successfully cloned RequestOptions!', clonedRequestOptions)\n\n    return {\n      ...requestOptionsFromUrl,\n      ...clonedRequestOptions,\n    }\n  }\n\n  logger.info('using an empty object as request options')\n  return {} as RequestOptions\n}\n\n/**\n * Overrides the given `URL` instance with the explicit properties provided\n * on the `RequestOptions` object. The options object takes precedence,\n * and will replace URL properties like \"host\", \"path\", and \"port\", if specified.\n */\nfunction overrideUrlByRequestOptions(url: URL, options: RequestOptions): URL {\n  url.host = options.host || url.host\n  url.hostname = options.hostname || url.hostname\n  url.port = options.port ? options.port.toString() : url.port\n\n  if (options.path) {\n    const parsedOptionsPath = parseUrl(options.path, false)\n    url.pathname = parsedOptionsPath.pathname || ''\n    url.search = parsedOptionsPath.search || ''\n  }\n\n  return url\n}\n\nfunction resolveCallback(\n  args: ClientRequestArgs\n): HttpRequestCallback | undefined {\n  return typeof args[1] === 'function' ? args[1] : args[2]\n}\n\nexport type NormalizedClientRequestArgs = [\n  url: URL,\n  options: ResolvedRequestOptions,\n  callback?: HttpRequestCallback\n]\n\n/**\n * Normalizes parameters given to a `http.request` call\n * so it always has a `URL` and `RequestOptions`.\n */\nexport function normalizeClientRequestArgs(\n  defaultProtocol: string,\n  args: ClientRequestArgs\n): NormalizedClientRequestArgs {\n  let url: URL\n  let options: ResolvedRequestOptions\n  let callback: HttpRequestCallback | undefined\n\n  logger.info('arguments', args)\n  logger.info('using default protocol:', defaultProtocol)\n\n  // Support \"http.request()\" calls without any arguments.\n  // That call results in a \"GET http://localhost\" request.\n  if (args.length === 0) {\n    const url = new URL('http://localhost')\n    const options = resolveRequestOptions(args, url)\n    return [url, options]\n  }\n\n  // Convert a url string into a URL instance\n  // and derive request options from it.\n  if (typeof args[0] === 'string') {\n    logger.info('first argument is a location string:', args[0])\n\n    url = new URL(args[0])\n    logger.info('created a url:', url)\n\n    const requestOptionsFromUrl = urlToHttpOptions(url)\n    logger.info('request options from url:', requestOptionsFromUrl)\n\n    options = resolveRequestOptions(args, url)\n    logger.info('resolved request options:', options)\n\n    callback = resolveCallback(args)\n  }\n  // Handle a given URL instance as-is\n  // and derive request options from it.\n  else if (args[0] instanceof URL) {\n    url = args[0]\n    logger.info('first argument is a URL:', url)\n\n    // Check if the second provided argument is RequestOptions.\n    // If it is, check if \"options.path\" was set and rewrite it\n    // on the input URL.\n    // Do this before resolving options from the URL below\n    // to prevent query string from being duplicated in the path.\n    if (typeof args[1] !== 'undefined' && isObject<RequestOptions>(args[1])) {\n      url = overrideUrlByRequestOptions(url, args[1])\n    }\n\n    options = resolveRequestOptions(args, url)\n    logger.info('derived request options:', options)\n\n    callback = resolveCallback(args)\n  }\n  // Handle a legacy URL instance and re-normalize from either a RequestOptions object\n  // or a WHATWG URL.\n  else if ('hash' in args[0] && !('method' in args[0])) {\n    const [legacyUrl] = args\n    logger.info('first argument is a legacy URL:', legacyUrl)\n\n    if (legacyUrl.hostname === null) {\n      /**\n       * We are dealing with a relative url, so use the path as an \"option\" and\n       * merge in any existing options, giving priority to existing options -- i.e. a path in any\n       * existing options will take precedence over the one contained in the url. This is consistent\n       * with the behaviour in ClientRequest.\n       * @see https://github.com/nodejs/node/blob/d84f1312915fe45fe0febe888db692c74894c382/lib/_http_client.js#L122\n       */\n      logger.info('given legacy URL is relative (no hostname)')\n\n      return isObject(args[1])\n        ? normalizeClientRequestArgs(defaultProtocol, [\n            { path: legacyUrl.path, ...args[1] },\n            args[2],\n          ])\n        : normalizeClientRequestArgs(defaultProtocol, [\n            { path: legacyUrl.path },\n            args[1] as HttpRequestCallback,\n          ])\n    }\n\n    logger.info('given legacy url is absolute')\n\n    // We are dealing with an absolute URL, so convert to WHATWG and try again.\n    const resolvedUrl = new URL(legacyUrl.href)\n\n    return args[1] === undefined\n      ? normalizeClientRequestArgs(defaultProtocol, [resolvedUrl])\n      : typeof args[1] === 'function'\n      ? normalizeClientRequestArgs(defaultProtocol, [resolvedUrl, args[1]])\n      : normalizeClientRequestArgs(defaultProtocol, [\n          resolvedUrl,\n          args[1],\n          args[2],\n        ])\n  }\n  // Handle a given \"RequestOptions\" object as-is\n  // and derive the URL instance from it.\n  else if (isObject(args[0])) {\n    options = { ...(args[0] as any) }\n    logger.info('first argument is RequestOptions:', options)\n\n    // When handling a \"RequestOptions\" object without an explicit \"protocol\",\n    // infer the protocol from the request issuing module (http/https).\n    options.protocol = options.protocol || defaultProtocol\n    logger.info('normalized request options:', options)\n\n    url = getUrlByRequestOptions(options)\n    logger.info('created a URL from RequestOptions:', url.href)\n\n    callback = resolveCallback(args)\n  } else {\n    throw new Error(\n      `Failed to construct ClientRequest with these parameters: ${args}`\n    )\n  }\n\n  options.protocol = options.protocol || url.protocol\n  options.method = options.method || 'GET'\n\n  /**\n   * Ensure that the default Agent is always set.\n   * This prevents the protocol mismatch for requests with { agent: false },\n   * where the global Agent is inferred.\n   * @see https://github.com/mswjs/msw/issues/1150\n   * @see https://github.com/nodejs/node/blob/418ff70b810f0e7112d48baaa72932a56cfa213b/lib/_http_client.js#L130\n   * @see https://github.com/nodejs/node/blob/418ff70b810f0e7112d48baaa72932a56cfa213b/lib/_http_client.js#L157-L159\n   */\n  if (!options._defaultAgent) {\n    logger.info(\n      'has no default agent, setting the default agent for \"%s\"',\n      options.protocol\n    )\n\n    options._defaultAgent =\n      options.protocol === 'https:' ? httpsGlobalAgent : httpGlobalAgent\n  }\n\n  logger.info('successfully resolved url:', url.href)\n  logger.info('successfully resolved options:', options)\n  logger.info('successfully resolved callback:', callback)\n\n  /**\n   * @note If the user-provided URL is not a valid URL in Node.js,\n   * (e.g. the one provided by the JSDOM polyfills), case it to\n   * string. Otherwise, this throws on Node.js incompatibility\n   * (`ERR_INVALID_ARG_TYPE` on the connection listener)\n   * @see https://github.com/node-fetch/node-fetch/issues/1376#issuecomment-966435555\n   */\n  if (!(url instanceof URL)) {\n    url = (url as any).toString()\n  }\n\n  return [url, options, callback]\n}\n","import { Agent } from 'http'\nimport { RequestOptions, Agent as HttpsAgent } from 'https'\nimport { Logger } from '@open-draft/logger'\n\nconst logger = new Logger('utils getUrlByRequestOptions')\n\n// Request instance constructed by the \"request\" library\n// has a \"self\" property that has a \"uri\" field. This is\n// reproducible by performing a \"XMLHttpRequest\" request in JSDOM.\nexport interface RequestSelf {\n  uri?: URL\n}\n\nexport type ResolvedRequestOptions = RequestOptions & RequestSelf\n\nexport const DEFAULT_PATH = '/'\nconst DEFAULT_PROTOCOL = 'http:'\nconst DEFAULT_HOSTNAME = 'localhost'\nconst SSL_PORT = 443\n\nfunction getAgent(\n  options: ResolvedRequestOptions\n): Agent | HttpsAgent | undefined {\n  return options.agent instanceof Agent ? options.agent : undefined\n}\n\nfunction getProtocolByRequestOptions(options: ResolvedRequestOptions): string {\n  if (options.protocol) {\n    return options.protocol\n  }\n\n  const agent = getAgent(options)\n  const agentProtocol = (agent as RequestOptions)?.protocol\n\n  if (agentProtocol) {\n    return agentProtocol\n  }\n\n  const port = getPortByRequestOptions(options)\n  const isSecureRequest = options.cert || port === SSL_PORT\n\n  return isSecureRequest ? 'https:' : options.uri?.protocol || DEFAULT_PROTOCOL\n}\n\nfunction getPortByRequestOptions(\n  options: ResolvedRequestOptions\n): number | undefined {\n  // Use the explicitly provided port.\n  if (options.port) {\n    return Number(options.port)\n  }\n\n  // Otherwise, try to resolve port from the agent.\n  const agent = getAgent(options)\n\n  if ((agent as HttpsAgent)?.options.port) {\n    return Number((agent as HttpsAgent).options.port)\n  }\n\n  if ((agent as RequestOptions)?.defaultPort) {\n    return Number((agent as RequestOptions).defaultPort)\n  }\n\n  // Lastly, return undefined indicating that the port\n  // must inferred from the protocol. Do not infer it here.\n  return undefined\n}\n\ninterface RequestAuth {\n  username: string\n  password: string\n}\n\nfunction getAuthByRequestOptions(\n  options: ResolvedRequestOptions\n): RequestAuth | undefined {\n  if (options.auth) {\n    const [username, password] = options.auth.split(':')\n    return { username, password }\n  }\n}\n\n/**\n * Returns true if host looks like an IPv6 address without surrounding brackets\n * It assumes any host containing `:` is definitely not IPv4 and probably IPv6,\n * but note that this could include invalid IPv6 addresses as well.\n */\nfunction isRawIPv6Address(host: string): boolean {\n  return host.includes(':') && !host.startsWith('[') && !host.endsWith(']')\n}\n\nfunction getHostname(options: ResolvedRequestOptions): string | undefined {\n  let host = options.hostname || options.host\n\n  if (host) {\n    if (isRawIPv6Address(host)) {\n       host = `[${host}]`\n    }\n\n    // Check the presence of the port, and if it's present,\n    // remove it from the host, returning a hostname.\n    return new URL(`http://${host}`).hostname\n  }\n\n  return DEFAULT_HOSTNAME\n}\n\n/**\n * Creates a `URL` instance from a given `RequestOptions` object.\n */\nexport function getUrlByRequestOptions(options: ResolvedRequestOptions): URL {\n  logger.info('request options', options)\n\n  if (options.uri) {\n    logger.info(\n      'constructing url from explicitly provided \"options.uri\": %s',\n      options.uri\n    )\n    return new URL(options.uri.href)\n  }\n\n  logger.info('figuring out url from request options...')\n\n  const protocol = getProtocolByRequestOptions(options)\n  logger.info('protocol', protocol)\n\n  const port = getPortByRequestOptions(options)\n  logger.info('port', port)\n\n  const hostname = getHostname(options)\n  logger.info('hostname', hostname)\n\n  const path = options.path || DEFAULT_PATH\n  logger.info('path', path)\n\n  const credentials = getAuthByRequestOptions(options)\n  logger.info('credentials', credentials)\n\n  const authString = credentials\n    ? `${credentials.username}:${credentials.password}@`\n    : ''\n  logger.info('auth string:', authString)\n\n  const portString = typeof port !== 'undefined' ? `:${port}` : ''\n  const url = new URL(`${protocol}//${hostname}${portString}${path}`)\n  url.username = credentials?.username || ''\n  url.password = credentials?.password || ''\n\n  logger.info('created url:', url)\n\n  return url\n}\n","import { Logger } from '@open-draft/logger'\n\nconst logger = new Logger('cloneObject')\n\nfunction isPlainObject(obj?: Record<string, any>): boolean {\n  logger.info('is plain object?', obj)\n\n  if (obj == null || !obj.constructor?.name) {\n    logger.info('given object is undefined, not a plain object...')\n    return false\n  }\n\n  logger.info('checking the object constructor:', obj.constructor.name)\n  return obj.constructor.name === 'Object'\n}\n\nexport function cloneObject<ObjectType extends Record<string, any>>(\n  obj: ObjectType\n): ObjectType {\n  logger.info('cloning object:', obj)\n\n  const enumerableProperties = Object.entries(obj).reduce<Record<string, any>>(\n    (acc, [key, value]) => {\n      logger.info('analyzing key-value pair:', key, value)\n\n      // Recursively clone only plain objects, omitting class instances.\n      acc[key] = isPlainObject(value) ? cloneObject(value) : value\n      return acc\n    },\n    {}\n  )\n\n  return isPlainObject(obj)\n    ? enumerableProperties\n    : Object.assign(Object.getPrototypeOf(obj), enumerableProperties)\n}\n"],"mappings":";;;;;;;;;;;;;;;;AAAA,IAAAA,KAAO,GAAAC,OAAU;AAAA,IAAAC,MAAA,GAAAC,sBAAA,CAAAH,KAAA;AACjB,IAAAI,MAAO,GAAAH,OAAW;AAAA,IAAAI,OAAA,GAAAF,sBAAA,CAAAC,MAAA;;;ACDlB,IAAAE,IAAO,GAAAL,OAAS;AAAA,IAAAM,KAAA,GAAAJ,sBAAA,CAAAG,IAAA;AAGd,IAAAE,aAGK,GAAAP,OAAA;AAEP,IAAAQ,OAAS,GAAAR,OAAA,SAAgB;AACzB,IAAAS,WAAS,GAAAT,OAAA,CAAiB;;;;;AEOnB,SAASU,yBACdC,IAAA,EAC2B;EAC3B,MAAMC,UAAA,GAAwC,CAACD,IAAA,CAAK,CAAC,GAAG,QAAW,MAAS;EAE5E,IAAI,OAAOA,IAAA,CAAK,CAAC,MAAM,UAAU;IAC/BC,UAAA,CAAW,CAAC,IAAID,IAAA,CAAK,CAAC;EACxB,WAAW,OAAOA,IAAA,CAAK,CAAC,MAAM,YAAY;IACxCC,UAAA,CAAW,CAAC,IAAID,IAAA,CAAK,CAAC;EACxB;EAEA,IAAI,OAAOA,IAAA,CAAK,CAAC,MAAM,YAAY;IACjCC,UAAA,CAAW,CAAC,IAAID,IAAA,CAAK,CAAC;EACxB;EAEA,OAAOC,UAAA;AACT;;;ADfO,IAAMC,UAAA,GAAN,cAAyBP,KAAI,CAAAQ,OAAO,CAAAC,MAAA;EAGzCC,YAA+BC,OAAA,EAA4B;IACzD,MAAM;IADuB,KAAAA,OAAA,GAAAA,OAAA;IAE7B,KAAKC,UAAA,GAAa;IAClB,KAAKC,OAAA,CAAQ;IAEb,KAAKC,MAAA,GAAUC,QAAA,IAAa;MAC1BA,QAAA,CAAS,IAAI;IACf;EACF;EAEOF,QAAA,EAAU;IAGf,KAAKD,UAAA,GAAa;IAClB,OAAO;EACT;EAEOI,MAAA,GAASX,IAAA,EAA+B;IAC7C,MAAM,CAACY,KAAA,EAAOC,QAAA,EAAUH,QAAQ,IAAIX,wBAAA,CAClCC,IACF;IACA,KAAKM,OAAA,CAAQK,KAAA,CAAMC,KAAA,EAAOC,QAAA,EAAUH,QAAQ;IAC5C,OAAO;EACT;EAEOI,IAAA,GAAOd,IAAA,EAAsB;IAClC,MAAM,CAACY,KAAA,EAAOC,QAAA,EAAUH,QAAQ,IAAIX,wBAAA,CAClCC,IACF;IACA,KAAKM,OAAA,CAAQK,KAAA,CAAMC,KAAA,EAAOC,QAAA,EAAUH,QAAQ;IAC5C,OAAO,MAAMI,GAAA,CAAIC,KAAA,CAAM,MAAMf,IAAW;EAC1C;EAEOgB,KAAKJ,KAAA,EAAYC,QAAA,EAAoC;IAC1D,KAAKP,OAAA,CAAQW,IAAA,CAAKL,KAAA,EAAOC,QAAQ;IACjC,OAAO,MAAMG,IAAA,CAAKJ,KAAA,EAAOC,QAAQ;EACnC;AACF;;;AEzDO,SAASK,6BAA6BZ,OAAA,EAAmB;EAC9D,IAAI,UAAUA,OAAA,EAAS;IACrB,OAAO,IAAIa,GAAA,CAAIb,OAAA,CAAQc,IAAI;EAC7B;EAEA,MAAMC,QAAA,GAAWf,OAAA,CAAQgB,IAAA,KAAS,MAAM,WAAW;EACnD,MAAMC,IAAA,GAAOjB,OAAA,CAAQiB,IAAA;EAErB,MAAMC,GAAA,GAAM,IAAIL,GAAA,CAAI,GAAGE,QAAA,KAAaE,IAAA,EAAM;EAE1C,IAAIjB,OAAA,CAAQgB,IAAA,EAAM;IAChBE,GAAA,CAAIF,IAAA,GAAOhB,OAAA,CAAQgB,IAAA,CAAKG,QAAA,CAAS;EACnC;EAEA,IAAInB,OAAA,CAAQoB,IAAA,EAAM;IAChBF,GAAA,CAAIG,QAAA,GAAWrB,OAAA,CAAQoB,IAAA;EACzB;EAEA,IAAIpB,OAAA,CAAQsB,IAAA,EAAM;IAChB,MAAM,CAACC,QAAA,EAAUC,QAAQ,IAAIxB,OAAA,CAAQsB,IAAA,CAAKG,KAAA,CAAM,GAAG;IACnDP,GAAA,CAAIK,QAAA,GAAWA,QAAA;IACfL,GAAA,CAAIM,QAAA,GAAWA,QAAA;EACjB;EAEA,OAAON,GAAA;AACT;;;ACrBA,IAAMQ,WAAA,GAAcC,MAAA,CAAO,aAAa;AACxC,IAAMC,eAAA,GAAkBD,MAAA,CAAO,iBAAiB;AAEhD,SAASE,gBACPC,OAAA,EACApC,IAAA,EACAqC,QAAA,EACA;EACAC,sBAAA,CAAuBF,OAAA,EAAS,EAAE;EAClC,MAAMG,UAAA,GAAaC,OAAA,CAAQC,GAAA,CAAIL,OAAA,EAASJ,WAAW;EAEnD,IAAIK,QAAA,KAAa,OAAO;IAEtB,SAASK,KAAA,GAAQH,UAAA,CAAWI,MAAA,GAAS,GAAGD,KAAA,IAAS,GAAGA,KAAA,IAAS;MAC3D,IAAIH,UAAA,CAAWG,KAAK,EAAE,CAAC,EAAEE,WAAA,CAAY,MAAM5C,IAAA,CAAK,CAAC,EAAE4C,WAAA,CAAY,GAAG;QAChEL,UAAA,CAAWM,MAAA,CAAOH,KAAA,EAAO,CAAC;MAC5B;IACF;EACF;EAEAH,UAAA,CAAWvB,IAAA,CAAKhB,IAAI;AACtB;AAMA,SAASsC,uBACPF,OAAA,EACAG,UAAA,EACM;EACN,IAAIC,OAAA,CAAQM,GAAA,CAAIV,OAAA,EAASJ,WAAW,GAAG;IACrC;EACF;EAEAe,sBAAA,CAAuBX,OAAA,EAASG,UAAU;AAC5C;AAMA,SAASQ,uBAAuBX,OAAA,EAAkBG,UAAA,EAAwB;EACxES,MAAA,CAAOC,cAAA,CAAeb,OAAA,EAASJ,WAAA,EAAa;IAC1CkB,KAAA,EAAOX,UAAA;IACPY,UAAA,EAAY;IAAA;IAAA;IAAA;IAIZC,YAAA,EAAc;EAChB,CAAC;AACH;AAgBO,SAASC,sBAAA,EAAwB;EAEtC,IAAIb,OAAA,CAAQC,GAAA,CAAIa,OAAA,EAASpB,eAAe,GAAG;IACzC,OAAOM,OAAA,CAAQC,GAAA,CAAIa,OAAA,EAASpB,eAAe;EAC7C;EAEA,MAAM;IACJoB,OAAA,EAASC,eAAA;IACTC,OAAA,EAASC,eAAA;IACTC,QAAA,EAAUC;EACZ,IAAIC,UAAA;EACJ,MAAM;IAAEC,GAAA;IAAKC,MAAA;IAAQC,MAAA,EAAQC;EAAoB,IAAIV,OAAA,CAAQW,SAAA;EAE7DjB,MAAA,CAAOC,cAAA,CAAeK,OAAA,EAASpB,eAAA,EAAiB;IAC9CgB,KAAA,EAAOA,CAAA,KAAM;MACXI,OAAA,CAAQW,SAAA,CAAUJ,GAAA,GAAMA,GAAA;MACxBP,OAAA,CAAQW,SAAA,CAAUH,MAAA,GAASA,MAAA;MAC3BR,OAAA,CAAQW,SAAA,CAAUF,MAAA,GAASC,mBAAA;MAC3BJ,UAAA,CAAWN,OAAA,GAAUC,eAAA;MAErBK,UAAA,CAAWJ,OAAA,GAAUC,eAAA;MACrBG,UAAA,CAAWF,QAAA,GAAWC,gBAAA;MAEtBnB,OAAA,CAAQ0B,cAAA,CAAeZ,OAAA,EAASpB,eAAe;IACjD;IACAiB,UAAA,EAAY;IAAA;AAAA;AAAA;AAAA;IAKZC,YAAA,EAAc;EAChB,CAAC;EAEDJ,MAAA,CAAOC,cAAA,CAAeW,UAAA,EAAY,WAAW;IAC3CT,UAAA,EAAY;IACZgB,QAAA,EAAU;IACVjB,KAAA,EAAO,IAAIkB,KAAA,CAAMd,OAAA,EAAS;MACxBe,UAAUC,MAAA,EAAQtE,IAAA,EAAMuE,SAAA,EAAW;QACjC,MAAMC,WAAA,GAAcxE,IAAA,CAAK,CAAC,KAAK,EAAC;QAEhC,IACEwE,WAAA,YAAuBlB,OAAA,IACvBd,OAAA,CAAQM,GAAA,CAAI0B,WAAA,EAAaxC,WAAW,GACpC;UACA,MAAMyC,QAAA,GAAUjC,OAAA,CAAQ6B,SAAA,CACtBC,MAAA,EACA,CAAC9B,OAAA,CAAQC,GAAA,CAAI+B,WAAA,EAAaxC,WAAW,CAAC,GACtCuC,SACF;UACAjC,sBAAA,CAAuBmC,QAAA,EAAS;UAAA;AAAA;AAAA;AAAA;AAAA;UAM9B,GAAGjC,OAAA,CAAQC,GAAA,CAAI+B,WAAA,EAAaxC,WAAW,EACxC;UACD,OAAOyC,QAAA;QACT;QAEA,MAAMrC,OAAA,GAAUI,OAAA,CAAQ6B,SAAA,CAAUC,MAAA,EAAQtE,IAAA,EAAMuE,SAAS;QAMzD,IAAI,CAAC/B,OAAA,CAAQM,GAAA,CAAIV,OAAA,EAASJ,WAAW,GAAG;UACtC,MAAM0C,cAAA,GAAiBC,KAAA,CAAMC,OAAA,CAAQJ,WAAW,IAC5CA,WAAA,GACAxB,MAAA,CAAO6B,OAAA,CAAQL,WAAW;UAC9BlC,sBAAA,CAAuBF,OAAA,EAASsC,cAAc;QAChD;QAEA,OAAOtC,OAAA;MACT;IACF,CAAC;EACH,CAAC;EAEDkB,OAAA,CAAQW,SAAA,CAAUJ,GAAA,GAAM,IAAIO,KAAA,CAAMd,OAAA,CAAQW,SAAA,CAAUJ,GAAA,EAAK;IACvD9C,MAAMuD,MAAA,EAAQQ,OAAA,EAAS9E,IAAA,EAAmB;MACxCmC,eAAA,CAAgB2C,OAAA,EAAS9E,IAAA,EAAM,KAAK;MACpC,OAAOwC,OAAA,CAAQzB,KAAA,CAAMuD,MAAA,EAAQQ,OAAA,EAAS9E,IAAI;IAC5C;EACF,CAAC;EAEDsD,OAAA,CAAQW,SAAA,CAAUH,MAAA,GAAS,IAAIM,KAAA,CAAMd,OAAA,CAAQW,SAAA,CAAUH,MAAA,EAAQ;IAC7D/C,MAAMuD,MAAA,EAAQQ,OAAA,EAAS9E,IAAA,EAAmB;MACxCmC,eAAA,CAAgB2C,OAAA,EAAS9E,IAAA,EAAM,QAAQ;MACvC,OAAOwC,OAAA,CAAQzB,KAAA,CAAMuD,MAAA,EAAQQ,OAAA,EAAS9E,IAAI;IAC5C;EACF,CAAC;EAEDsD,OAAA,CAAQW,SAAA,CAAUF,MAAA,GAAS,IAAIK,KAAA,CAAMd,OAAA,CAAQW,SAAA,CAAUF,MAAA,EAAQ;IAC7DhD,MAAMuD,MAAA,EAAQQ,OAAA,EAAS9E,IAAA,EAAgB;MACrC,MAAMuC,UAAA,GAAaC,OAAA,CAAQC,GAAA,CAAIqC,OAAA,EAAS9C,WAAW;MAEnD,IAAIO,UAAA,EAAY;QACd,SAASG,KAAA,GAAQH,UAAA,CAAWI,MAAA,GAAS,GAAGD,KAAA,IAAS,GAAGA,KAAA,IAAS;UAC3D,IAAIH,UAAA,CAAWG,KAAK,EAAE,CAAC,EAAEE,WAAA,CAAY,MAAM5C,IAAA,CAAK,CAAC,EAAE4C,WAAA,CAAY,GAAG;YAChEL,UAAA,CAAWM,MAAA,CAAOH,KAAA,EAAO,CAAC;UAC5B;QACF;MACF;MAEA,OAAOF,OAAA,CAAQzB,KAAA,CAAMuD,MAAA,EAAQQ,OAAA,EAAS9E,IAAI;IAC5C;EACF,CAAC;EAEDgD,MAAA,CAAOC,cAAA,CAAeW,UAAA,EAAY,WAAW;IAC3CT,UAAA,EAAY;IACZgB,QAAA,EAAU;IACVjB,KAAA,EAAO,IAAIkB,KAAA,CAAMZ,OAAA,EAAS;MACxBa,UAAUC,MAAA,EAAQtE,IAAA,EAAMuE,SAAA,EAAW;QACjC,MAAMQ,OAAA,GAAUvC,OAAA,CAAQ6B,SAAA,CAAUC,MAAA,EAAQtE,IAAA,EAAMuE,SAAS;QACzD,MAAMS,kBAAA,GAAiC,EAAC;QAGxC,IAAI,OAAOhF,IAAA,CAAK,CAAC,MAAM,YAAYA,IAAA,CAAK,CAAC,EAAEoC,OAAA,IAAW,MAAM;UAC1D4C,kBAAA,CAAmBhE,IAAA,CAAK,GAAGiE,eAAA,CAAgBjF,IAAA,CAAK,CAAC,EAAEoC,OAAO,CAAC;QAC7D;QAGA,IAAI,OAAOpC,IAAA,CAAK,CAAC,MAAM,YAAYA,IAAA,CAAK,CAAC,EAAEoC,OAAA,IAAW,MAAM;UAC1D4C,kBAAA,CAAmBhE,IAAA,CAAK,GAAGiE,eAAA,CAAgBjF,IAAA,CAAK,CAAC,EAAEoC,OAAO,CAAC;QAC7D;QAEA,IAAI4C,kBAAA,CAAmBrC,MAAA,GAAS,GAAG;UACjCL,sBAAA,CAAuByC,OAAA,CAAQ3C,OAAA,EAAS4C,kBAAkB;QAC5D;QAEA,OAAOD,OAAA;MACT;IACF,CAAC;EACH,CAAC;EAED/B,MAAA,CAAOC,cAAA,CAAeW,UAAA,EAAY,YAAY;IAC5CT,UAAA,EAAY;IACZgB,QAAA,EAAU;IACVjB,KAAA,EAAO,IAAIkB,KAAA,CAAMV,QAAA,EAAU;MACzBW,UAAUC,MAAA,EAAQtE,IAAA,EAAMuE,SAAA,EAAW;QACjC,MAAMW,QAAA,GAAW1C,OAAA,CAAQ6B,SAAA,CAAUC,MAAA,EAAQtE,IAAA,EAAMuE,SAAS;QAE1D,IAAI,OAAOvE,IAAA,CAAK,CAAC,MAAM,YAAYA,IAAA,CAAK,CAAC,EAAEoC,OAAA,IAAW,MAAM;UAC1DE,sBAAA,CACE4C,QAAA,CAAS9C,OAAA,EACT6C,eAAA,CAAgBjF,IAAA,CAAK,CAAC,EAAEoC,OAAO,CACjC;QACF;QAEA,OAAO8C,QAAA;MACT;IACF,CAAC;EACH,CAAC;AACH;AAEO,SAASC,wBAAA,EAA0B;EACxC,IAAI,CAAC3C,OAAA,CAAQC,GAAA,CAAIa,OAAA,EAASpB,eAAe,GAAG;IAC1C;EACF;EAEAM,OAAA,CAAQC,GAAA,CAAIa,OAAA,EAASpB,eAAe,EAAE;AACxC;AAEO,SAASkD,mBAAmBhD,OAAA,EAA8B;EAG/D,IAAI,CAACI,OAAA,CAAQM,GAAA,CAAIV,OAAA,EAASJ,WAAW,GAAG;IACtC,OAAO2C,KAAA,CAAMU,IAAA,CAAKjD,OAAA,CAAQyC,OAAA,CAAQ,CAAC;EACrC;EAEA,MAAMtC,UAAA,GAAaC,OAAA,CAAQC,GAAA,CAAIL,OAAA,EAASJ,WAAW;EACnD,OAAOO,UAAA,CAAWI,MAAA,GAAS,IAAIJ,UAAA,GAAaoC,KAAA,CAAMU,IAAA,CAAKjD,OAAA,CAAQyC,OAAA,CAAQ,CAAC;AAC1E;AAYA,SAASI,gBAAgB7C,OAAA,EAAkC;EACzD,IAAIA,OAAA,YAAmBkB,OAAA,EAAS;IAC9B,OAAOd,OAAA,CAAQC,GAAA,CAAIL,OAAA,EAASJ,WAAW,KAAK,EAAC;EAC/C;EAEA,OAAOQ,OAAA,CAAQC,GAAA,CAAI,IAAIa,OAAA,CAAQlB,OAAO,GAAGJ,WAAW;AACtD;;;AJxNO,IAAMsD,UAAA,GAAarD,MAAA,CAAO,YAAY;AAEtC,IAAMsD,cAAA,GAAN,cAA6BrF,UAAA,CAAW;EAsB7CG,YAAYC,OAAA,EAAgC;IAC1C,MAAM;MACJK,KAAA,EAAOA,CAACC,KAAA,EAAOC,QAAA,EAAUH,QAAA,KAAa;QAvE5C,IAAA8E,EAAA;QA2EQ,IAAI,KAAKC,WAAA,KAAgB,eAAe;UACtC,KAAKC,WAAA,CAAY1E,IAAA,CAAK,CAACJ,KAAA,EAAOC,QAAA,EAAUH,QAAQ,CAAC;QACnD;QAEA,IAAIE,KAAA,EAAO;UAMT,IAAI,KAAK6E,WAAA,KAAgB,eAAe;YACtC,CAAAD,EAAA,QAAKG,cAAA,KAAL,gBAAAH,EAAA,CAAqB7E,KAAA,CAAMC,KAAA,EAAOC,QAAA,EAAUH,QAAA;UAC9C;UAEA,KAAKkF,aAAA,CAAcC,OAAA,CACjBC,MAAA,CAAOC,QAAA,CAASnF,KAAK,IAAIA,KAAA,GAAQkF,MAAA,CAAOT,IAAA,CAAKzE,KAAA,EAAOC,QAAQ,CAC9D;QACF;MACF;MACAI,IAAA,EAAOL,KAAA,IAAU;QACf,IAAIA,KAAA,KAAU,MAAM;UAMlB,KAAKoF,cAAA,CAAeH,OAAA,CAClBC,MAAA,CAAOC,QAAA,CAASnF,KAAK,IAAIA,KAAA,GAAQkF,MAAA,CAAOT,IAAA,CAAKzE,KAAK,CACpD;QACF;MACF;IACF,CAAC;IAlDH,KAAQqF,uBAAA,GAAyC,EAAC;IAClD,KAAQC,wBAAA,GAA0C,EAAC;IACnD,KAAQR,WAAA,GAAgD,EAAC;IAMzD,KAAQD,WAAA,GAAkD;IAua1D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;IAAA,KAAQU,gBAAA,GAAqC5D,UAAA,IAAe;MAC1D,KAAK0D,uBAAA,CAAwBjF,IAAA,CAAK,GAAGuB,UAAU;IACjD;IAEA,KAAQ6D,cAAA,GAAiD,CACvDC,YAAA,EACAC,YAAA,EACA/D,UAAA,EACAgE,CAAA,EACA7E,IAAA,EACA8E,EAAA,EACAC,GAAA,EACAC,IAAA,EACAC,eAAA,KACG;MArfP,IAAAnB,EAAA;MAsfI,KAAKmB,eAAA,GAAkBA,eAAA;MAEvB,MAAMnF,GAAA,GAAM,IAAIL,GAAA,CAAIO,IAAA,IAAQ,IAAI,KAAKkF,OAAO;MAC5C,MAAMC,MAAA,KAASrB,EAAA,QAAKsB,iBAAA,CAAkBD,MAAA,KAAvB,gBAAArB,EAAA,CAA+BuB,WAAA,OAAiB;MAC/D,MAAM3E,OAAA,GAAU4E,gBAAc,CAAAC,aAAgB,CAAAC,eAAA,EAC5C,GAAG,KAAKjB,uBAAA,EACR,IAAI1D,UAAA,IAAc,EAAC,EACpB;MACD,KAAK0D,uBAAA,CAAwBtD,MAAA,GAAS;MAEtC,MAAMwE,WAAA,GAAcN,MAAA,KAAW,SAASA,MAAA,KAAW;MAInD,IAAIrF,GAAA,CAAIK,QAAA,IAAYL,GAAA,CAAIM,QAAA,EAAU;QAChC,IAAI,CAACM,OAAA,CAAQU,GAAA,CAAI,eAAe,GAAG;UACjCV,OAAA,CAAQyB,GAAA,CAAI,iBAAiB,SAASrC,GAAA,CAAIK,QAAA,IAAYL,GAAA,CAAIM,QAAA,EAAU;QACtE;QACAN,GAAA,CAAIK,QAAA,GAAW;QACfL,GAAA,CAAIM,QAAA,GAAW;MACjB;MAMA,KAAKsF,aAAA,GAAgB,KAAI,GAAAvH,OAAS,CAAAwH,QAAA;QAAA;AAAA;AAAA;AAAA;AAAA;QAMhCpG,IAAA,EAAMA,CAAA,KAAM;UAKV,KAAKqG,gBAAA,CAAiB;QACxB;MACF,CAAC;MAED,MAAMC,SAAA,GAAYP,gBAAgB,CAAAQ,eAAA,CAAAC,IAAA;MAClC,KAAK1C,OAAA,GAAU,IAAIvB,OAAA,CAAQhC,GAAA,EAAK;QAC9BqF,MAAA;QACAzE,OAAA;QACAsF,WAAA,EAAa;QAAA;QAEbC,MAAA,EAAQR,WAAA,GAAc,SAAS;QAC/BS,IAAA,EAAMT,WAAA,GAAetH,OAAA,CAAAwH,QAAe,CAAAQ,KAAK,MAAAT,aAA0B;MACrE,CAAC;MAED5E,OAAA,CAAQqB,GAAA,CAAI,KAAKkB,OAAA,EAASO,UAAA,EAAYiC,SAAS;MAI/CO,gBAAc,CAAAC,aAAc,CAAAN,IAAA,CAAQ,KAAI,OAAM,CAAA1C,OAAA,EAAAvC,OAAe,CAAAC,GAAA;MAK7DuF,gBAAA,CAAAC,uBAAsC,CAAAR,IAAK,aAAa,CAAA1C,OAAA,OAAAqC,aAAA;MAYxD,IAAI,KAAKrC,OAAA,CAAQ3C,OAAA,CAAQU,GAAA,CAAIkE,gBAAA,CAAAkB,+BAAkC;QAC7D,KAAKC,WAAA,CAAY;QACjB;MACF;MAEA,KAAKC,SAAA,CAAU;QACbb,SAAA;QACAxC,OAAA,EAAS,KAAKA,OAAA;QACdsD,MAAA,EAAQ;MACV,CAAC;IACH;IAyBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;IAAA,KAAQC,iBAAA,GAAsC/F,UAAA,IAAe;MAC3D,KAAK2D,wBAAA,CAAyBlF,IAAA,CAAK,GAAGuB,UAAU;IAClD;IAEA,KAAQgG,eAAA,GAAmD,CACzDlC,YAAA,EACAC,YAAA,EACA/D,UAAA,EACAsE,MAAA,EACArF,GAAA,EACAgH,MAAA,EACAC,UAAA,KACG;MACH,MAAMrG,OAAA,GAAU4E,gBAAc,CAAAC,aAAgB,CAAAC,eAAA,EAC5C,GAAG,KAAKhB,wBAAA,EACR,IAAI3D,UAAA,IAAc,EAAC,EACpB;MACD,KAAK2D,wBAAA,CAAyBvD,MAAA,GAAS;MAEvC,MAAMuC,QAAA,GAAW,KAAI,GAAA8B,gBAAA,CAAAC,aAAA;MAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;MAQnBD,gBAAc,CAAAC,aAAA,CAAAyB,kBACT,CAAAF,MAAS,IAAA3I,OAAA,CAAAwH,QAAA,CAAAQ,KAAA,CACP,KAAKc,cAAA,GAAiB,KAAI,GAAA9I,OAAW,CAAAwH,QAAO;QAAApG,KAAA,GAAC;MAAE,CAAC,CACnD,IACA,MACJ;QACEO,GAAA;QACAgH,MAAA;QACAC,UAAA;QACArG;MACF,CACF;MAEAtC,WAAA,CAAA8I,SAAA,CAAAnB,IAAA,SACE,KAAK1C,OAAA,EACL,qDACF;MAEAiC,gBAAc,CAAAC,aAAY,CAAA4B,MAAQ,KAAK,CAAA9D,OAAQ,CAAAvD,GAAA,EAAA0D,QAAA;MAO/C,IAAI,KAAKH,OAAA,CAAQ3C,OAAA,CAAQU,GAAA,CAAIkE,gBAAA,CAAAkB,+BAAkC;QAC7D;MACF;MAEA,KAAKY,wBAAA,GAA2B,KAAKC,UAAA,CAAW;QAC9C7D,QAAA;QACA8D,gBAAA,EAAkB,KAAKvD,WAAA,KAAgB;QACvC8B,SAAA,EAAW/E,OAAA,CAAQC,GAAA,CAAI,KAAKsC,OAAA,EAASO,UAAU;QAC/CP,OAAA,EAAS,KAAKA,OAAA;QACdsD,MAAA,EAAQ;MACV,CAAC;IACH;IApjBE,KAAKvB,iBAAA,GAAoBxG,OAAA,CAAQwG,iBAAA;IACjC,KAAKmC,gBAAA,GAAmB3I,OAAA,CAAQ2I,gBAAA;IAChC,KAAKb,SAAA,GAAY9H,OAAA,CAAQ8H,SAAA;IACzB,KAAKW,UAAA,GAAazI,OAAA,CAAQyI,UAAA;IAE1B,KAAKnC,OAAA,GAAU1F,4BAAA,CAA6B,KAAK4F,iBAAiB;IAGlE,KAAKlB,aAAA,GAAgB,KAAI,GAAAhG,aAAW,CAAAsJ,UAAA;IACpC,KAAKtD,aAAA,CAAcuD,UAAA,CAAWvJ,aAAW,CAAAsJ,UAAW,CAAAE,OAAA;IACpD,KAAKxD,aAAA,CAAchG,aAAW,CAAAsJ,UAAU,CAAIG,UAAK,SAAAlD,gBAA0B,CAAAmD,IAAA;IAC3E,KAAK1D,aAAA,CAAchG,aAAW,CAAAsJ,UAAA,CAAAK,kBACvB,SAAAnD,cAAwB,CAAAkD,IAAA;IAC/B,KAAK1D,aAAA,CAAchG,aAAW,CAAAsJ,UAAW,CAAAM,OAAK,SAAcC,aAAS,CAAAH,IAAA;IACrE,KAAK1D,aAAA,CAAchG,aAAW,CAAAsJ,UAAA,CAAAQ,kBACvB,QAAa,CAAAC,YAAS,CAAAL,IAAA;IAG7B,KAAKtD,cAAA,GAAiB,KAAI,GAAApG,aAAW,CAAAsJ,UAAA;IACrC,KAAKlD,cAAA,CAAemD,UAAA,CAAWvJ,aAAW,CAAAsJ,UAAY,CAAAU,QAAA;IACtD,KAAK5D,cAAA,CAAepG,aAAW,CAAAsJ,UAAU,CACvCG,UAAK,SAAAf,iBAA2B,CAAAgB,IAAA;IAClC,KAAKtD,cAAA,CAAepG,aAAW,CAAAsJ,UAAA,CAAAK,kBACxB,SAAAhB,eAAyB,CAAAe,IAAA;IAChC,KAAKtD,cAAA,CAAepG,aAAW,CAAAsJ,UAAW,CAAAM,OAAK,SAAAK,cAAwB,CAAAP,IAAA;IACvE,KAAKtD,cAAA,CAAepG,aAAW,CAAAsJ,UAAA,CAAAQ,kBACxB,SAAcI,aAAS,CAAAR,IAAA;IAI9B,KAAKS,IAAA,CAAK,UAAU,MAAM,KAAKnE,aAAA,CAAcoE,IAAA,CAAK,CAAC;IAEnD,IAAI,KAAKpD,OAAA,CAAQvF,QAAA,KAAa,UAAU;MACtCmB,OAAA,CAAQqB,GAAA,CAAI,MAAM,aAAa,IAAI;MAGnCrB,OAAA,CAAQqB,GAAA,CAAI,MAAM,cAAc,KAAK;MACrCrB,OAAA,CAAQqB,GAAA,CAAI,MAAM,eAAe,MAAM,SAAS;MAChDrB,OAAA,CAAQqB,GAAA,CAAI,MAAM,cAAc,MAAM,MAAS;MAC/CrB,OAAA,CAAQqB,GAAA,CAAI,MAAM,mBAAmB,MAAM,KAAK;IAClD;EACF;EAEOoG,KAAKC,KAAA,KAA2BlK,IAAA,EAAsB;IAC3D,MAAMmK,SAAA,GAAY,MAAMF,IAAA,CAAKX,IAAA,CAAK,MAAMY,KAAA,EAAc,GAAGlK,IAAI;IAE7D,IAAI,KAAK8I,wBAAA,EAA0B;MACjC,KAAKA,wBAAA,CAAyBsB,OAAA,CAAQD,SAAS;MAC/C,OAAO,KAAKE,aAAA,CAAcH,KAAK,IAAI;IACrC;IAEA,OAAOC,SAAA,CAAU;EACnB;EAEOG,QAAQC,KAAA,EAAiC;IAI9C,KAAKvE,cAAA,CAAegE,IAAA,CAAK;IAEzB,IAAIO,KAAA,EAAO;MACT,KAAKN,IAAA,CAAK,SAASM,KAAK;IAC1B;IAEA,OAAO,MAAMD,OAAA,CAAQC,KAAK;EAC5B;EAAA;AAAA;AAAA;AAAA;EAMOpC,YAAA,EAAoB;IACzB,KAAK1C,WAAA,GAAc;IAEnB,IAAI,KAAK+E,SAAA,EAAW;MAClB;IACF;IAEA,MAAMnC,MAAA,GAAS,KAAKY,gBAAA,CAAiB;IACrC,KAAKtD,cAAA,GAAiB0C,MAAA;IAQtB,IAAI,aAAaA,MAAA,EAAQ;MACvBrF,MAAA,CAAOC,cAAA,CAAe,MAAM,WAAW;QACrCC,KAAA,EAAOmF,MAAA,CAAOoC,OAAA;QACdtH,UAAA,EAAY;QACZgB,QAAA,EAAU;MACZ,CAAC;IACH;IAGA,KAAK4F,IAAA,CAAK,SAAUQ,KAAA,IAAU;MAC5BlC,MAAA,CAAOiC,OAAA,CAAQC,KAAK;IACtB,CAAC;IAED,KAAKG,OAAA,GAAUrC,MAAA,CAAOqC,OAAA,CAAQpB,IAAA,CAAKjB,MAAM;IAMzC,IAAIsC,SAAA;IACJ,IAAIC,cAAA,GAAiB;IAErB,OAAQD,SAAA,GAAY,KAAKjF,WAAA,CAAYmF,KAAA,CAAM,GAAI;MAC7C,IAAIF,SAAA,KAAc,QAAW;QAC3B,IAAI,CAACC,cAAA,EAAgB;UACnB,MAAM,CAAChK,KAAA,EAAOC,QAAA,EAAUH,QAAQ,IAAIiK,SAAA;UACpC,MAAMG,WAAA,GAAclK,KAAA,CAAMa,QAAA,CAAS;UACnC,MAAMsJ,yBAAA,GAA4BD,WAAA,CAAYE,KAAA,CAC5C,GACAF,WAAA,CAAYG,OAAA,CAAQ,MAAM,IAAI,CAChC;UACA,MAAMC,wBAAA,GAA2BJ,WAAA,CAAYE,KAAA,CAC3CpK,KAAA,CAAMqK,OAAA,CAAQ,UAAU,CAC1B;UACA,MAAME,iBAAA,GAAoB/F,kBAAA,CAAmB,KAAKL,OAAA,CAAS3C,OAAO;UAClE,MAAMgJ,oBAAA,GAAuBD,iBAAA,CAE1BE,MAAA,CAAO,CAAC,CAACC,IAAI,MAAM;YAClB,OAAOA,IAAA,CAAK1I,WAAA,CAAY,MAAMoE,gBAAA,CAAAkB,+BAAA;UAChC,CAAC,EACAqD,GAAA,CAAI,CAAC,CAACD,IAAA,EAAMpI,KAAK,MAAM,GAAGoI,IAAA,KAASpI,KAAA,EAAO,EAC1CsI,IAAA,CAAK,MAAM;UAKd,MAAMC,YAAA,GAAe,GAAGV,yBAAA,GAA4BK,oBAAA,GAAuBF,wBAAA;UAC3E7C,MAAA,CAAO1H,KAAA,CAAM8K,YAAA,EAAc5K,QAAA,EAAUH,QAAQ;UAC7CkK,cAAA,GAAiB;UACjB;QACF;QAEAvC,MAAA,CAAO1H,KAAA,CAAM,GAAGgK,SAAS;MAC3B;IACF;IAIA,IAAInI,OAAA,CAAQC,GAAA,CAAI4F,MAAA,EAAQ,WAAW,GAAG;MACpC,MAAMqD,aAAA,GAAgB,CACpB,aACA,cACA,eACA,cACA,kBACF;MAEAA,aAAA,CAAcC,OAAA,CAASC,YAAA,IAAiB;QACtC5I,MAAA,CAAOC,cAAA,CAAe,MAAM2I,YAAA,EAAc;UACxCzI,UAAA,EAAY;UACZV,GAAA,EAAKA,CAAA,KAAM;YACT,MAAMS,KAAA,GAAQV,OAAA,CAAQC,GAAA,CAAI4F,MAAA,EAAQuD,YAAY;YAC9C,OAAO,OAAO1I,KAAA,KAAU,aAAaA,KAAA,CAAMoG,IAAA,CAAKjB,MAAM,IAAInF,KAAA;UAC5D;QACF,CAAC;MACH,CAAC;IACH;IAEAmF,MAAA,CACGwD,EAAA,CAAG,UAAU,IAAI7L,IAAA,KAAS,KAAKiK,IAAA,CAAK,UAAU,GAAGjK,IAAI,CAAC,EACtD6L,EAAA,CAAG,WAAW,MAAM;MACnB,KAAKtL,UAAA,GAAa8H,MAAA,CAAO9H,UAAA;MACzB,KAAK0J,IAAA,CAAK,SAAS;IACrB,CAAC,EACA4B,EAAA,CAAG,iBAAiB,MAAM,KAAK5B,IAAA,CAAK,eAAe,CAAC,EACpD4B,EAAA,CAAG,UAAU,MAAM,KAAK5B,IAAA,CAAK,QAAQ,CAAC,EACtC4B,EAAA,CAAG,WAAYC,OAAA,IAAY,KAAK7B,IAAA,CAAK,WAAW6B,OAAO,CAAC,EACxDD,EAAA,CAAG,SAAS,MAAM,KAAK5B,IAAA,CAAK,OAAO,CAAC,EACpC4B,EAAA,CAAG,SAAS,MAAM,KAAK5B,IAAA,CAAK,OAAO,CAAC,EACpC4B,EAAA,CAAG,QAASjL,KAAA,IAAU;MAIrB,KAAKI,IAAA,CAAKJ,KAAK;IACjB,CAAC,EACAiL,EAAA,CAAG,SAAUtB,KAAA,IAAU;MACtB/H,OAAA,CAAQqB,GAAA,CAAI,MAAM,aAAarB,OAAA,CAAQC,GAAA,CAAI4F,MAAA,EAAQ,WAAW,CAAC;MAC/D,KAAK4B,IAAA,CAAK,SAASM,KAAK;IAC1B,CAAC,EACAsB,EAAA,CAAG,UAAU,MAAM,KAAK5B,IAAA,CAAK,QAAQ,CAAC,EACtC4B,EAAA,CAAG,WAAW,MAAM,KAAK5B,IAAA,CAAK,SAAS,CAAC,EACxC4B,EAAA,CAAG,aAAa,MAAM,KAAK5B,IAAA,CAAK,WAAW,CAAC,EAC5C4B,EAAA,CAAG,UAAU,MAAM,KAAK5B,IAAA,CAAK,QAAQ,CAAC,EACtC4B,EAAA,CAAG,SAAUE,QAAA,IAAa,KAAK9B,IAAA,CAAK,SAAS8B,QAAQ,CAAC,EACtDF,EAAA,CAAG,OAAO,MAAM,KAAK5B,IAAA,CAAK,KAAK,CAAC;EACrC;EAAA;AAAA;AAAA;AAAA;EAMA,MAAa+B,YAAY9G,QAAA,EAAmC;IAlT9D,IAAAM,EAAA;IAqTI,IAAI,KAAKgF,SAAA,EAAW;MAClB;IACF;IAGA,IAAIyB,gBAAA,CAAAC,oBAAqC,CAAAzE,IAAK,SAASvC,QAAA,EAAS,WAASA,QAAA,CAAAiH,IAAA;MACvE,KAAKC,SAAA,CAAU,IAAIC,SAAA,CAAU,eAAe,CAAC;MAC7C;IACF;IAIA,KAAKC,WAAA,CAAY;IACjB,KAAK7G,WAAA,GAAc;IAInB,KAAK6B,gBAAA,CAAiB;IAItB,MAAMiF,cAAA,GAAiB,KAAI,GAAAnN,KAAA,CAAAoN,cAAmB,UAAApN,KAAoB,CAACqN,eAAA;IAUnEF,cAAA,CAAeG,YAAA,CACb,IAAIxM,UAAA,CAAW;MACbS,KAAA,EAAOA,CAACC,KAAA,EAAOC,QAAA,EAAUH,QAAA,KAAa;QACpC,KAAKM,IAAA,CAAKJ,KAAA,EAAOC,QAAQ;QACzBH,QAAA,oBAAAA,QAAA;MACF;MACAO,KAAA,EAAO,CAAC;IACV,CAAC,CACH;IAWAsL,cAAA,CAAeI,YAAA,CAAa,YAAY;IACxCJ,cAAA,CAAeI,YAAA,CAAa,MAAM;IAElC,MAAMC,kBAAA,GAAqBxH,kBAAA,CAAmBF,QAAA,CAAS9C,OAAO;IAO9DmK,cAAA,CAAeM,SAAA,CACb3H,QAAA,CAASsD,MAAA,EACTtD,QAAA,CAASuD,UAAA,IAAcrJ,KAAA,CAAA0N,YAAa,CAAA5H,QAAS,CAAMsD,MAAA,GACnDoE,kBACF;IAGA,KAAK7C,IAAA,CAAK,SAAS,MAAM;MACvBwC,cAAA,CAAejC,OAAA,CAAQ;IACzB,CAAC;IAED,IAAIpF,QAAA,CAAS0C,IAAA,EAAM;MACjB,IAAI;QACF,MAAMmF,MAAA,GAAS7H,QAAA,CAAS0C,IAAA,CAAKoF,SAAA,CAAU;QAEvC,OAAO,MAAM;UACX,MAAM;YAAEC,IAAA;YAAM/J;UAAM,IAAI,MAAM6J,MAAA,CAAO9L,IAAA,CAAK;UAE1C,IAAIgM,IAAA,EAAM;YACRV,cAAA,CAAezL,GAAA,CAAI;YACnB;UACF;UAEAyL,cAAA,CAAe5L,KAAA,CAAMuC,KAAK;QAC5B;MACF,SAASqH,KAAA,EAAP;QAEA,KAAKyB,WAAA,CAAYC,gBAAA,CAAAiB,yBAAgC,CAAAzF,IAAA,SAAA8C,KAAA;QACjD;MACF;IACF,OAAO;MACLgC,cAAA,CAAezL,GAAA,CAAI;IACrB;IAGA,IAAI,CAAC,KAAK6F,eAAA,EAAiB;MACzB,KAAKsD,IAAA,CAAK,UAAU;MASpB,CAAAzE,EAAA,QAAKmD,cAAA,KAAL,gBAAAnD,EAAA,CAAqBxE,IAAA,CAAK;MAC1B,KAAKA,IAAA,CAAK,IAAI;IAChB;EACF;EAAA;AAAA;AAAA;EAKOoL,UAAU7B,KAAA,EAAqB;IACpC,KAAKD,OAAA,CAAQC,KAAK;EACpB;EAEQ+B,YAAA,EAAoB;IAG1B,KAAK/L,UAAA,GAAa;IAElB,MAAM4M,MAAA,GACJxN,KAAI,CAAAQ,OAAO,CAAAgN,MAAK,MAAArG,iBAA0B,CAAAsG,QAC1C,CAAK,SAAAtG,iBAAkB,CAAAuG,MAAW;IACpC,MAAMC,WAAA,GAAc;MAClB5C,OAAA,EAASyC,MAAA,GAAS,QAAQ;MAC1BE,MAAA,EAAQF,MAAA,GAAS,SAAS;MAC1B7L,IAAA,EAAM,KAAKwF,iBAAA,CAAkBxF;IAC/B;IAEA,KAAKoJ,OAAA,GAAU,MAAM4C,WAAA;IACrB,KAAKrD,IAAA,CACH,UACA,MACAqD,WAAA,CAAY5C,OAAA,EACZ4C,WAAA,CAAYD,MAAA,KAAW,SAAS,IAAI,GACpC,KAAKvG,iBAAA,CAAkBvF,IACzB;IACA,KAAK0I,IAAA,CAAK,SAAS;IACnB,KAAKA,IAAA,CAAK,OAAO;IAEjB,IAAI,KAAKrD,OAAA,CAAQvF,QAAA,KAAa,UAAU;MACtC,KAAK4I,IAAA,CAAK,QAAQ;MAClB,KAAKA,IAAA,CAAK,eAAe;MAGzB,KAAKA,IAAA,CACH,WACA,KAAKnD,iBAAA,CAAkBgF,OAAA,IACrBhG,MAAA,CAAOT,IAAA,CAAK,0BAA0B,CAC1C;MACA,KAAK4E,IAAA,CAAK,WAAWnE,MAAA,CAAOT,IAAA,CAAK,qBAAqB,CAAC;IACzD;EACF;EAEQiC,iBAAA,EAAyB;IAC/B,WAAWiG,SAAA,IAAa,KAAK7H,WAAA,EAAa;MACxC,IAAI,OAAO6H,SAAA,CAAU,CAAC,MAAM,YAAY;QACtCA,SAAA,CAAU,CAAC,EAAE;QAObA,SAAA,CAAU,CAAC,IAAI;MACjB;IACF;EACF;EA4GQ9D,cAAc7I,KAAA,EAAqB;IACzCd,WAAA,CAAA8I,SAAA,CAAAnB,IAAA,SACE,KAAKL,aAAA,EACL,4DACF;IAEA,KAAKA,aAAA,CAAcpG,IAAA,CAAKJ,KAAK;EAC/B;EAEQ+I,aAAA,EAAqB;IAE3B,IAAI,KAAKvC,aAAA,EAAe;MACtB,KAAKA,aAAA,CAAcpG,IAAA,CAAK,IAAI;IAC9B;EACF;EA0EQ6I,eAAejJ,KAAA,EAAe;IACpCd,WAAA,CAAA8I,SAAA,CAAAnB,IAAA,SACE,KAAKkB,cAAA,EACL,6DACF;IAEA,KAAKA,cAAA,CAAe3H,IAAA,CAAKJ,KAAK;EAChC;EAEQkJ,cAAA,EAAsB;IAE5B,IAAI,KAAKnB,cAAA,EAAgB;MACvB,KAAKA,cAAA,CAAe3H,IAAA,CAAK,IAAI;IAC/B;EACF;AACF;;;;AKppBO,IAAMwM,SAAA,GAAN,cAAwBlO,MAAK,CAAAa,OAAM,CAAAsN,KAAA;EAKxCpN,YAAYC,OAAA,EAA2B;IACrC,MAAM;IACN,KAAKoN,WAAA,GAAcpN,OAAA,CAAQoN,WAAA;IAC3B,KAAKtF,SAAA,GAAY9H,OAAA,CAAQ8H,SAAA;IACzB,KAAKW,UAAA,GAAazI,OAAA,CAAQyI,UAAA;EAC5B;EAEOE,iBAAiB3I,OAAA,EAAcI,QAAA,EAA2B;IAC/D,MAAMuI,gBAAA,GACJ,KAAKyE,WAAA,YAAuBpO,MAAK,CAAAa,OAC7B,CAAAsN,KAAK,QAAAC,WAAY,CAAAzE,gBACX,SAAAA,gBAAA;IAEZ,MAAM0E,uBAAA,GACJ,KAAKD,WAAA,YAAuBpO,MAAK,CAAAa,OAC7B,CAAAsN,KAAA;MACE,GAAGnN,OAAA;MACH,GAAG,KAAKoN,WAAA,CAAYpN;IACtB,IACAA,OAAA;IAEN,MAAM+H,MAAA,GAAS,IAAI9C,cAAA,CAAe;MAChCuB,iBAAA,EAAmBxG,OAAA;MACnB2I,gBAAA,EAAkBA,gBAAA,CAAiBK,IAAA,CACjC,KAAKoE,WAAA,IAAe,MACpBC,uBAAA,EACAjN,QACF;MACA0H,SAAA,EAAW,KAAKA,SAAA,CAAUkB,IAAA,CAAK,IAAI;MACnCP,UAAA,EAAY,KAAKA,UAAA,CAAWO,IAAA,CAAK,IAAI;IACvC,CAAC;IAED,OAAOjB,MAAA;EACT;AACF;AAEO,IAAMuF,cAAA,GAAN,cAA6BnO,OAAM,CAAAU,OAAM,CAAAsN,KAAA;EAK9CpN,YAAYC,OAAA,EAA2B;IACrC,MAAM;IACN,KAAKoN,WAAA,GAAcpN,OAAA,CAAQoN,WAAA;IAC3B,KAAKtF,SAAA,GAAY9H,OAAA,CAAQ8H,SAAA;IACzB,KAAKW,UAAA,GAAazI,OAAA,CAAQyI,UAAA;EAC5B;EAEOE,iBAAiB3I,OAAA,EAAcI,QAAA,EAA2B;IAC/D,MAAMuI,gBAAA,GACJ,KAAKyE,WAAA,YAAuBpO,MAAK,CAAAa,OAC7B,CAAAsN,KAAK,QAAAC,WAAY,CAAAzE,gBACX,SAAAA,gBAAA;IAEZ,MAAM0E,uBAAA,GACJ,KAAKD,WAAA,YAAuBpO,MAAK,CAAAa,OAC7B,CAAAsN,KAAA;MACE,GAAGnN,OAAA;MACH,GAAG,KAAKoN,WAAA,CAAYpN;IACtB,IACAA,OAAA;IAEN,MAAM+H,MAAA,GAAS,IAAI9C,cAAA,CAAe;MAChCuB,iBAAA,EAAmBxG,OAAA;MACnB2I,gBAAA,EAAkBA,gBAAA,CAAiBK,IAAA,CACjC,KAAKoE,WAAA,IAAe,MACpBC,uBAAA,EACAjN,QACF;MACA0H,SAAA,EAAW,KAAKA,SAAA,CAAUkB,IAAA,CAAK,IAAI;MACnCP,UAAA,EAAY,KAAKA,UAAA,CAAWO,IAAA,CAAK,IAAI;IACvC,CAAC;IAED,OAAOjB,MAAA;EACT;AACF;;;AC7GA,IAAAwF,IAAA,GAASxO,OAAA;AAsBT,IAAAyO,OAAS,GAAAzO,OAAA,qBAAc;;;;AClBvB,IAAM0O,MAAA,GAAS,KAAI,GAAAD,OAAO,CAAAE,MAAA,gCAA8B;AAWjD,IAAMC,YAAA,GAAe;AAC5B,IAAMC,gBAAA,GAAmB;AACzB,IAAMC,gBAAA,GAAmB;AACzB,IAAMC,QAAA,GAAW;AAEjB,SAASC,SACP/N,OAAA,EACgC;EAChC,OAAOA,OAAA,CAAQgO,KAAA,YAAiBlP,KAAA,CAAAqO,KAAQ,GAAAnN,OAAQ,CAAAgO,KAAQ;AAC1D;AAEA,SAASC,4BAA4BjO,OAAA,EAAyC;EA1B9E,IAAAkF,EAAA;EA2BE,IAAIlF,OAAA,CAAQe,QAAA,EAAU;IACpB,OAAOf,OAAA,CAAQe,QAAA;EACjB;EAEA,MAAMiN,KAAA,GAAQD,QAAA,CAAS/N,OAAO;EAC9B,MAAMkO,aAAA,GAAiBF,KAAA,oBAAAA,KAAA,CAA0BjN,QAAA;EAEjD,IAAImN,aAAA,EAAe;IACjB,OAAOA,aAAA;EACT;EAEA,MAAMlN,IAAA,GAAOmN,uBAAA,CAAwBnO,OAAO;EAC5C,MAAMoO,eAAA,GAAkBpO,OAAA,CAAQqO,IAAA,IAAQrN,IAAA,KAAS8M,QAAA;EAEjD,OAAOM,eAAA,GAAkB,aAAWlJ,EAAA,GAAAlF,OAAA,CAAQsO,GAAA,KAAR,gBAAApJ,EAAA,CAAanE,QAAA,KAAY6M,gBAAA;AAC/D;AAEA,SAASO,wBACPnO,OAAA,EACoB;EAEpB,IAAIA,OAAA,CAAQgB,IAAA,EAAM;IAChB,OAAOuN,MAAA,CAAOvO,OAAA,CAAQgB,IAAI;EAC5B;EAGA,MAAMgN,KAAA,GAAQD,QAAA,CAAS/N,OAAO;EAE9B,IAAKgO,KAAA,oBAAAA,KAAA,CAAsBhO,OAAA,CAAQgB,IAAA,EAAM;IACvC,OAAOuN,MAAA,CAAQP,KAAA,CAAqBhO,OAAA,CAAQgB,IAAI;EAClD;EAEA,IAAKgN,KAAA,oBAAAA,KAAA,CAA0BQ,WAAA,EAAa;IAC1C,OAAOD,MAAA,CAAQP,KAAA,CAAyBQ,WAAW;EACrD;EAIA,OAAO;AACT;AAOA,SAASC,wBACPzO,OAAA,EACyB;EACzB,IAAIA,OAAA,CAAQsB,IAAA,EAAM;IAChB,MAAM,CAACC,QAAA,EAAUC,QAAQ,IAAIxB,OAAA,CAAQsB,IAAA,CAAKG,KAAA,CAAM,GAAG;IACnD,OAAO;MAAEF,QAAA;MAAUC;IAAS;EAC9B;AACF;AAOA,SAASkN,iBAAiBzN,IAAA,EAAuB;EAC/C,OAAOA,IAAA,CAAK0N,QAAA,CAAS,GAAG,KAAK,CAAC1N,IAAA,CAAK2N,UAAA,CAAW,GAAG,KAAK,CAAC3N,IAAA,CAAK4N,QAAA,CAAS,GAAG;AAC1E;AAEA,SAASC,YAAY9O,OAAA,EAAqD;EACxE,IAAIiB,IAAA,GAAOjB,OAAA,CAAQ8M,QAAA,IAAY9M,OAAA,CAAQiB,IAAA;EAEvC,IAAIA,IAAA,EAAM;IACR,IAAIyN,gBAAA,CAAiBzN,IAAI,GAAG;MACzBA,IAAA,GAAO,IAAIA,IAAA;IACd;IAIA,OAAO,IAAIJ,GAAA,CAAI,UAAUI,IAAA,EAAM,EAAE6L,QAAA;EACnC;EAEA,OAAOe,gBAAA;AACT;AAKO,SAASkB,uBAAuB/O,OAAA,EAAsC;EAC3EyN,MAAA,CAAOuB,IAAA,CAAK,mBAAmBhP,OAAO;EAEtC,IAAIA,OAAA,CAAQsO,GAAA,EAAK;IACfb,MAAA,CAAOuB,IAAA,CACL,+DACAhP,OAAA,CAAQsO,GACV;IACA,OAAO,IAAIzN,GAAA,CAAIb,OAAA,CAAQsO,GAAA,CAAIxN,IAAI;EACjC;EAEA2M,MAAA,CAAOuB,IAAA,CAAK,0CAA0C;EAEtD,MAAMjO,QAAA,GAAWkN,2BAAA,CAA4BjO,OAAO;EACpDyN,MAAA,CAAOuB,IAAA,CAAK,YAAYjO,QAAQ;EAEhC,MAAMC,IAAA,GAAOmN,uBAAA,CAAwBnO,OAAO;EAC5CyN,MAAA,CAAOuB,IAAA,CAAK,QAAQhO,IAAI;EAExB,MAAM8L,QAAA,GAAWgC,WAAA,CAAY9O,OAAO;EACpCyN,MAAA,CAAOuB,IAAA,CAAK,YAAYlC,QAAQ;EAEhC,MAAM1L,IAAA,GAAOpB,OAAA,CAAQoB,IAAA,IAAQuM,YAAA;EAC7BF,MAAA,CAAOuB,IAAA,CAAK,QAAQ5N,IAAI;EAExB,MAAMgG,WAAA,GAAcqH,uBAAA,CAAwBzO,OAAO;EACnDyN,MAAA,CAAOuB,IAAA,CAAK,eAAe5H,WAAW;EAEtC,MAAM6H,UAAA,GAAa7H,WAAA,GACf,GAAGA,WAAA,CAAY7F,QAAA,IAAY6F,WAAA,CAAY5F,QAAA,MACvC;EACJiM,MAAA,CAAOuB,IAAA,CAAK,gBAAgBC,UAAU;EAEtC,MAAMC,UAAA,GAAa,OAAOlO,IAAA,KAAS,cAAc,IAAIA,IAAA,KAAS;EAC9D,MAAME,GAAA,GAAM,IAAIL,GAAA,CAAI,GAAGE,QAAA,KAAa+L,QAAA,GAAWoC,UAAA,GAAa9N,IAAA,EAAM;EAClEF,GAAA,CAAIK,QAAA,IAAW6F,WAAA,oBAAAA,WAAA,CAAa7F,QAAA,KAAY;EACxCL,GAAA,CAAIM,QAAA,IAAW4F,WAAA,oBAAAA,WAAA,CAAa5F,QAAA,KAAY;EAExCiM,MAAA,CAAOuB,IAAA,CAAK,gBAAgB9N,GAAG;EAE/B,OAAOA,GAAA;AACT;;;;ACrJA,IAAMiO,OAAA,GAAS,KAAI,GAAA3B,OAAO,CAAAE,MAAA,eAAa;AAEvC,SAAS0B,cAAcC,GAAA,EAAoC;EAJ3D,IAAAnK,EAAA;EAKEiK,OAAA,CAAOH,IAAA,CAAK,oBAAoBK,GAAG;EAEnC,IAAIA,GAAA,IAAO,QAAQ,GAACnK,EAAA,GAAAmK,GAAA,CAAItP,WAAA,KAAJ,gBAAAmF,EAAA,CAAiB8F,IAAA,GAAM;IACzCmE,OAAA,CAAOH,IAAA,CAAK,kDAAkD;IAC9D,OAAO;EACT;EAEAG,OAAA,CAAOH,IAAA,CAAK,oCAAoCK,GAAA,CAAItP,WAAA,CAAYiL,IAAI;EACpE,OAAOqE,GAAA,CAAItP,WAAA,CAAYiL,IAAA,KAAS;AAClC;AAEO,SAASsE,YACdD,GAAA,EACY;EACZF,OAAA,CAAOH,IAAA,CAAK,mBAAmBK,GAAG;EAElC,MAAME,oBAAA,GAAuB7M,MAAA,CAAO6B,OAAA,CAAQ8K,GAAG,EAAEG,MAAA,CAC/C,CAACC,GAAA,EAAK,CAACC,GAAA,EAAK9M,KAAK,MAAM;IACrBuM,OAAA,CAAOH,IAAA,CAAK,6BAA6BU,GAAA,EAAK9M,KAAK;IAGnD6M,GAAA,CAAIC,GAAG,IAAIN,aAAA,CAAcxM,KAAK,IAAI0M,WAAA,CAAY1M,KAAK,IAAIA,KAAA;IACvD,OAAO6M,GAAA;EACT,GACA,CAAC,CACH;EAEA,OAAOL,aAAA,CAAcC,GAAG,IACpBE,oBAAA,GACA7M,MAAA,CAAOiN,MAAA,CAAOjN,MAAA,CAAOkN,cAAA,CAAeP,GAAG,GAAGE,oBAAoB;AACpE;;;AFLA,IAAMM,OAAA,GAAS,KAAI,GAAArC,OAAO,CAAAE,MAAA,mCAAiC;AAW3D,SAASoC,sBACPpQ,IAAA,EACAwB,GAAA,EACgB;EAGhB,IAAI,OAAOxB,IAAA,CAAK,CAAC,MAAM,eAAe,OAAOA,IAAA,CAAK,CAAC,MAAM,YAAY;IACnEmQ,OAAA,CAAOb,IAAA,CAAK,uDAAuD9N,GAAG;IACtE,OAAOqM,IAAA,CAAAwC,gBAAoB,CAAA5I,IAAA,SAAAjG,GAAA;EAC7B;EAEA,IAAIxB,IAAA,CAAK,CAAC,GAAG;IACXmQ,OAAA,CAAOb,IAAA,CAAK,8BAA8BtP,IAAA,CAAK,CAAC,CAAC;IACjD,MAAMsQ,qBAAA,GAAwBzC,IAAA,CAAAwC,gBAAoB,CAAA5I,IAAA,SAAAjG,GAAA;IAElD2O,OAAA,CAAOb,IAAA,CAAK,wCAAwCgB,qBAAqB;IAOzEH,OAAA,CAAOb,IAAA,CAAK,2BAA2B;IACvC,MAAMiB,oBAAA,GAAuBX,WAAA,CAAY5P,IAAA,CAAK,CAAC,CAAC;IAChDmQ,OAAA,CAAOb,IAAA,CAAK,uCAAuCiB,oBAAoB;IAEvE,OAAO;MACL,GAAGD,qBAAA;MACH,GAAGC;IACL;EACF;EAEAJ,OAAA,CAAOb,IAAA,CAAK,0CAA0C;EACtD,OAAO,CAAC;AACV;AAOA,SAASkB,4BAA4BhP,GAAA,EAAUlB,OAAA,EAA8B;EAC3EkB,GAAA,CAAID,IAAA,GAAOjB,OAAA,CAAQiB,IAAA,IAAQC,GAAA,CAAID,IAAA;EAC/BC,GAAA,CAAI4L,QAAA,GAAW9M,OAAA,CAAQ8M,QAAA,IAAY5L,GAAA,CAAI4L,QAAA;EACvC5L,GAAA,CAAIF,IAAA,GAAOhB,OAAA,CAAQgB,IAAA,GAAOhB,OAAA,CAAQgB,IAAA,CAAKG,QAAA,CAAS,IAAID,GAAA,CAAIF,IAAA;EAExD,IAAIhB,OAAA,CAAQoB,IAAA,EAAM;IAChB,MAAM+O,iBAAA,GAAoB5C,IAAA,CAAA6C,KAAS,CAAAjJ,IAAA,MAAQ,GAAMnH,OAAK,CAAAoB,IAAA;IACtDF,GAAA,CAAIG,QAAA,GAAW8O,iBAAA,CAAkB9O,QAAA,IAAY;IAC7CH,GAAA,CAAImP,MAAA,GAASF,iBAAA,CAAkBE,MAAA,IAAU;EAC3C;EAEA,OAAOnP,GAAA;AACT;AAEA,SAASoP,gBACP5Q,IAAA,EACiC;EACjC,OAAO,OAAOA,IAAA,CAAK,CAAC,MAAM,aAAaA,IAAA,CAAK,CAAC,IAAIA,IAAA,CAAK,CAAC;AACzD;AAYO,SAAS6Q,2BACdC,eAAA,EACA9Q,IAAA,EAC6B;EAC7B,IAAIwB,GAAA;EACJ,IAAIlB,OAAA;EACJ,IAAII,QAAA;EAEJyP,OAAA,CAAOb,IAAA,CAAK,aAAatP,IAAI;EAC7BmQ,OAAA,CAAOb,IAAA,CAAK,2BAA2BwB,eAAe;EAItD,IAAI9Q,IAAA,CAAK2C,MAAA,KAAW,GAAG;IACrB,MAAMoO,IAAA,GAAM,KAAI,GAAAlD,IAAI,CAAA1M,GAAA,oBAAkB;IACtC,MAAM6P,QAAA,GAAUZ,qBAAA,CAAsBpQ,IAAA,EAAM+Q,IAAG;IAC/C,OAAO,CAACA,IAAA,EAAKC,QAAO;EACtB;EAIA,IAAI,OAAOhR,IAAA,CAAK,CAAC,MAAM,UAAU;IAC/BmQ,OAAA,CAAOb,IAAA,CAAK,wCAAwCtP,IAAA,CAAK,CAAC,CAAC;IAE3DwB,GAAA,GAAM,KAAI,GAAAqM,IAAI,CAAA1M,GAAO,EAAAnB,IAAA;IACrBmQ,OAAA,CAAOb,IAAA,CAAK,kBAAkB9N,GAAG;IAEjC,MAAM8O,qBAAA,GAAwBzC,IAAA,CAAAwC,gBAAoB,CAAA5I,IAAA,SAAAjG,GAAA;IAClD2O,OAAA,CAAOb,IAAA,CAAK,6BAA6BgB,qBAAqB;IAE9DhQ,OAAA,GAAU8P,qBAAA,CAAsBpQ,IAAA,EAAMwB,GAAG;IACzC2O,OAAA,CAAOb,IAAA,CAAK,6BAA6BhP,OAAO;IAEhDI,QAAA,GAAWkQ,eAAA,CAAgB5Q,IAAI;EACjC,WAGSA,IAAA,CAAK,CAAC,aAAa6N,IAAA,CAAA1M,GAAK;IAC/BK,GAAA,GAAMxB,IAAA,CAAK,CAAC;IACZmQ,OAAA,CAAOb,IAAA,CAAK,4BAA4B9N,GAAG;IAO3C,IAAI,OAAOxB,IAAA,CAAK,CAAC,MAAM,eAAeiM,gBAAgC,CAAAgF,QAAG,CAAAxJ,IAAA,SAAAzH,IAAA;MACvEwB,GAAA,GAAMgP,2BAAA,CAA4BhP,GAAA,EAAKxB,IAAA,CAAK,CAAC,CAAC;IAChD;IAEAM,OAAA,GAAU8P,qBAAA,CAAsBpQ,IAAA,EAAMwB,GAAG;IACzC2O,OAAA,CAAOb,IAAA,CAAK,4BAA4BhP,OAAO;IAE/CI,QAAA,GAAWkQ,eAAA,CAAgB5Q,IAAI;EACjC,WAGS,UAAUA,IAAA,CAAK,CAAC,KAAK,EAAE,YAAYA,IAAA,CAAK,CAAC,IAAI;IACpD,MAAM,CAACkR,SAAS,IAAIlR,IAAA;IACpBmQ,OAAA,CAAOb,IAAA,CAAK,mCAAmC4B,SAAS;IAExD,IAAIA,SAAA,CAAU9D,QAAA,KAAa,MAAM;MAQ/B+C,OAAA,CAAOb,IAAA,CAAK,4CAA4C;MAExD,OAAOrD,gBAAgB,CAAAgF,QACnB,CAAAxJ,IAAA,SAAAzH,IAAA,IAA2B,GAAA6Q,0BAAiB,CAAAC,eAAA,GAC1C;QAAEpP,IAAA,EAAMwP,SAAA,CAAUxP,IAAA;QAAM,GAAG1B,IAAA,CAAK,CAAC;MAAE,GACnCA,IAAA,CAAK,CAAC,EACP,IACD6Q,0BAAA,CAA2BC,eAAA,EAAiB,CAC1C;QAAEpP,IAAA,EAAMwP,SAAA,CAAUxP;MAAK,GACvB1B,IAAA,CAAK,CAAC,EACP;IACP;IAEAmQ,OAAA,CAAOb,IAAA,CAAK,8BAA8B;IAG1C,MAAM6B,WAAA,GAAc,KAAI,GAAAtD,IAAI,CAAA1M,GAAA,EAAA+P,SAAc,CAAA9P,IAAA;IAE1C,OAAOpB,IAAA,CAAK,CAAC,MAAM,SACf6Q,0BAAA,CAA2BC,eAAA,EAAiB,CAACK,WAAW,CAAC,IACzD,OAAOnR,IAAA,CAAK,CAAC,MAAM,aACnB6Q,0BAAA,CAA2BC,eAAA,EAAiB,CAACK,WAAA,EAAanR,IAAA,CAAK,CAAC,CAAC,CAAC,IAClE6Q,0BAAA,CAA2BC,eAAA,EAAiB,CAC1CK,WAAA,EACAnR,IAAA,CAAK,CAAC,GACNA,IAAA,CAAK,CAAC,EACP;EACP,WAGSiM,gBAAgB,CAAAgF,QAAG,CAAAxJ,IAAA,SAAAzH,IAAA;IAC1BM,OAAA,GAAU;MAAE,GAAIN,IAAA,CAAK,CAAC;IAAU;IAChCmQ,OAAA,CAAOb,IAAA,CAAK,qCAAqChP,OAAO;IAIxDA,OAAA,CAAQe,QAAA,GAAWf,OAAA,CAAQe,QAAA,IAAYyP,eAAA;IACvCX,OAAA,CAAOb,IAAA,CAAK,+BAA+BhP,OAAO;IAElDkB,GAAA,GAAM6N,sBAAA,CAAuB/O,OAAO;IACpC6P,OAAA,CAAOb,IAAA,CAAK,sCAAsC9N,GAAA,CAAIJ,IAAI;IAE1DV,QAAA,GAAWkQ,eAAA,CAAgB5Q,IAAI;EACjC,OAAO;IACL,MAAM,IAAIoR,KAAA,CACR,4DAA4DpR,IAAA,EAC9D;EACF;EAEAM,OAAA,CAAQe,QAAA,GAAWf,OAAA,CAAQe,QAAA,IAAYG,GAAA,CAAIH,QAAA;EAC3Cf,OAAA,CAAQuG,MAAA,GAASvG,OAAA,CAAQuG,MAAA,IAAU;EAUnC,IAAI,CAACvG,OAAA,CAAQ+Q,aAAA,EAAe;IAC1BlB,OAAA,CAAOb,IAAA,CACL,4DACAhP,OAAA,CAAQe,QACV;IAEAf,OAAA,CAAQ+Q,aAAA,GACN/Q,OAAA,CAAQe,QAAA,KAAa,WAAW7B,MAAA,CAAA8R,WAAA,GAAmBlS,KAAA,CAAAkS,WAAA;EACvD;EAEAnB,OAAA,CAAOb,IAAA,CAAK,8BAA8B9N,GAAA,CAAIJ,IAAI;EAClD+O,OAAA,CAAOb,IAAA,CAAK,kCAAkChP,OAAO;EACrD6P,OAAA,CAAOb,IAAA,CAAK,mCAAmC5O,QAAQ;EASvD,IAAI,EAAEc,GAAA,YAAeqM,IAAA,CAAA1M,GAAM;IACzBK,GAAA,GAAOA,GAAA,CAAYC,QAAA,CAAS;EAC9B;EAEA,OAAO,CAACD,GAAA,EAAKlB,OAAA,EAASI,QAAQ;AAChC;;;APxPO,IAAM6Q,yBAAA,GAAN,cAAuCvK,gBAAiC,CAAAwK,WAAA;EAG7EnR,YAAA,EAAc;IACZ,MAAMkR,yBAAA,CAAyBE,MAAM;IAgIvC,KAAQrJ,SAAA,GAA2C,OAAO;MACxDrD,OAAA;MACAsD;IACF,MAAM;MACJ,MAAMd,SAAA,GAAY/E,OAAA,CAAQC,GAAA,CAAIsC,OAAA,EAASO,UAAU;MACjD,MAAMoM,UAAA,GAAa,KAAI,GAAAzF,gBAAkB,CAAA0F,iBAAO,EAAA5M,OAAA;MAEhD,MAAM6M,gBAAA,GAAmB,MAAM3F,gBAAc,CAAA4F,aAAA,CAAApK,IAAA;QAC3C1C,OAAA;QACAwC,SAAA;QACAmK,UAAA;QACAI,OAAA,EAAS,KAAKA,OAAA;QACd/I,UAAA,EAAa7D,QAAA,IAAa;UACxBmD,MAAA,CAAO2D,WAAA,CAAY9G,QAAQ;QAC7B;QACA6M,cAAA,EAAiB7M,QAAA,IAAa;UAC5BmD,MAAA,CAAO2D,WAAA,CAAY9G,QAAQ;QAC7B;QACA8M,OAAA,EAAUzH,KAAA,IAAU;UAClB,IAAIA,KAAA,YAAiB6G,KAAA,EAAO;YAC1B/I,MAAA,CAAO+D,SAAA,CAAU7B,KAAK;UACxB;QACF;MACF,CAAC;MAED,IAAI,CAACqH,gBAAA,EAAkB;QACrB,OAAOvJ,MAAA,CAAOF,WAAA,CAAY;MAC5B;IACF;IAEA,KAAOY,UAAA,GAA6C,OAAO;MACzDxB,SAAA;MACAxC,OAAA;MACAG,QAAA;MACA8D;IACF,MAAM;MAGJ,OAAOiD,gBAAe,CAAAgG,SAAS,CAAAxK,IAAA,MAAY,QAAAqK,OAAA;QACzCvK,SAAA;QACAxC,OAAA;QACAG,QAAA;QACA8D;MACF,CAAC;IACH;EA3KA;EAEUkJ,MAAA,EAAc;IACtB,MAAM;MACJC,aAAA,EAAeC,qBAAA;MACf3P,GAAA,EAAK4P,WAAA;MACLtN,OAAA,EAASuN;IACX,IAAIhT,MAAA,CAAAa,OAAA;IACJ,MAAM;MAAEsC,GAAA,EAAK8P,gBAAA;MAAkBxN,OAAA,EAASyN;IAAqB,IAAI/S,OAAA,CAAAU,OAAA;IAEjE,MAAMiI,SAAA,GAAY,KAAKA,SAAA,CAAUkB,IAAA,CAAK,IAAI;IAC1C,MAAMP,UAAA,GAAa,KAAKA,UAAA,CAAWO,IAAA,CAAK,IAAI;IAG5ChK,MAAK,CAAAa,OAAA,CAAAgS,aAAoB,OAAM/N,KAAK,CAAA9E,MAAA,CAAAa,OAAe,CAAAgS,aAAA;MACjD9N,SAAA,EAAWA,CAACC,MAAA,EAAQtE,IAAA,KAA0C;QAC5D,MAAM,CAACwB,GAAA,EAAKlB,OAAA,EAASI,QAAQ,IAAImQ,0BAAA,CAC/B,SACA7Q,IACF;QAGA,MAAMyS,MAAA,GAAQnS,OAAA,CAAQe,QAAA,KAAa,WAAWuM,cAAA,GAAiBJ,SAAA;QAC/D,MAAMkF,SAAA,GAAY,IAAID,MAAA,CAAM;UAC1B/E,WAAA,EAAapN,OAAA,CAAQgO,KAAA;UACrBlG,SAAA;UACAW;QACF,CAAC;QACDzI,OAAA,CAAQgO,KAAA,GAAQoE,SAAA;QAEhB,OAAOlQ,OAAA,CAAQ6B,SAAA,CAAUC,MAAA,EAAQ,CAAC9C,GAAA,EAAKlB,OAAA,EAASI,QAAQ,CAAC;MAC3D;IACF,CAAC;IAEDpB,MAAK,CAAAa,OAAA,CAAA4E,OAAc,OAAMX,KAAK,CAAA9E,MAAS,CAAAa,OAAA,CAAA4E,OAAA;MACrChE,KAAA,EAAOA,CAACuD,MAAA,EAAQQ,OAAA,EAAS9E,IAAA,KAA0C;QACjE,MAAM,CAACwB,GAAA,EAAKlB,OAAA,EAASI,QAAQ,IAAImQ,0BAAA,CAC/B,SACA7Q,IACF;QACA,MAAM0S,SAAA,GAAY,IAAIlF,SAAA,CAAU;UAC9BE,WAAA,EAAapN,OAAA,CAAQgO,KAAA;UACrBlG,SAAA;UACAW;QACF,CAAC;QACDzI,OAAA,CAAQgO,KAAA,GAAQoE,SAAA;QAEhB,OAAOlQ,OAAA,CAAQzB,KAAA,CAAMuD,MAAA,EAAQQ,OAAA,EAAS,CAACtD,GAAA,EAAKlB,OAAA,EAASI,QAAQ,CAAC;MAChE;IACF,CAAC;IAEDpB,MAAK,CAAAa,OAAM,CAAAsC,GAAI,OAAM2B,KAAK,CAAA9E,MAAK,CAAAa,OAAA,CAAAsC,GAAA;MAC7B1B,KAAA,EAAOA,CAACuD,MAAA,EAAQQ,OAAA,EAAS9E,IAAA,KAAsC;QAC7D,MAAM,CAACwB,GAAA,EAAKlB,OAAA,EAASI,QAAQ,IAAImQ,0BAAA,CAC/B,SACA7Q,IACF;QAEA,MAAM0S,SAAA,GAAY,IAAIlF,SAAA,CAAU;UAC9BE,WAAA,EAAapN,OAAA,CAAQgO,KAAA;UACrBlG,SAAA;UACAW;QACF,CAAC;QACDzI,OAAA,CAAQgO,KAAA,GAAQoE,SAAA;QAEhB,OAAOlQ,OAAA,CAAQzB,KAAA,CAAMuD,MAAA,EAAQQ,OAAA,EAAS,CAACtD,GAAA,EAAKlB,OAAA,EAASI,QAAQ,CAAC;MAChE;IACF,CAAC;IAMDjB,OAAM,CAAAU,OAAA,CAAA4E,OAAc,OAAMX,KAAM,CAAA3E,OAAS,CAAAU,OAAA,CAAA4E,OAAA;MACvChE,KAAA,EAAOA,CAACuD,MAAA,EAAQQ,OAAA,EAAS9E,IAAA,KAA2C;QAClE,MAAM,CAACwB,GAAA,EAAKlB,OAAA,EAASI,QAAQ,IAAImQ,0BAAA,CAC/B,UACA7Q,IACF;QAEA,MAAM0S,SAAA,GAAY,IAAI9E,cAAA,CAAe;UACnCF,WAAA,EAAapN,OAAA,CAAQgO,KAAA;UACrBlG,SAAA;UACAW;QACF,CAAC;QACDzI,OAAA,CAAQgO,KAAA,GAAQoE,SAAA;QAEhB,OAAOlQ,OAAA,CAAQzB,KAAA,CAAMuD,MAAA,EAAQQ,OAAA,EAAS,CAACtD,GAAA,EAAKlB,OAAA,EAASI,QAAQ,CAAC;MAChE;IACF,CAAC;IAEDjB,OAAM,CAAAU,OAAM,CAAAsC,GAAI,OAAM2B,KAAM,CAAA3E,OAAK,CAAAU,OAAA,CAAAsC,GAAA;MAC/B1B,KAAA,EAAOA,CAACuD,MAAA,EAAQQ,OAAA,EAAS9E,IAAA,KAAuC;QAC9D,MAAM,CAACwB,GAAA,EAAKlB,OAAA,EAASI,QAAQ,IAAImQ,0BAAA,CAC/B,UACA7Q,IACF;QAEA,MAAM0S,SAAA,GAAY,IAAI9E,cAAA,CAAe;UACnCF,WAAA,EAAapN,OAAA,CAAQgO,KAAA;UACrBlG,SAAA;UACAW;QACF,CAAC;QACDzI,OAAA,CAAQgO,KAAA,GAAQoE,SAAA;QAEhB,OAAOlQ,OAAA,CAAQzB,KAAA,CAAMuD,MAAA,EAAQQ,OAAA,EAAS,CAACtD,GAAA,EAAKlB,OAAA,EAASI,QAAQ,CAAC;MAChE;IACF,CAAC;IAKD2C,qBAAA,CAAsB;IAEtB,KAAKsP,aAAA,CAAc3R,IAAA,CAAK,MAAM;MAC5B1B,MAAK,CAAAa,OAAA,CAAAgS,aAAgB,GAAAC,qBAAA;MAErB9S,MAAK,CAAAa,OAAM,CAAAsC,GAAA,GAAA4P,WAAA;MACX/S,MAAK,CAAAa,OAAA,CAAA4E,OAAU,GAAAuN,eAAA;MAEf7S,OAAM,CAAAU,OAAM,CAAAsC,GAAA,GAAA8P,gBAAA;MACZ9S,OAAM,CAAAU,OAAA,CAAA4E,OAAU,GAAAyN,oBAAA;MAEhBrN,uBAAA,CAAwB;IAC1B,CAAC;EACH;AA+CF;AAjLO,IAAMyN,wBAAA,GAANrB,yBAAA;AAAMqB,wBAAA,CACJnB,MAAA,GAASxP,MAAA,CAAO,4BAA4B","ignoreList":[]}