{"version":3,"names":["bindEvent","target","event","Object","defineProperties","value","enumerable","writable","currentTarget","kCancelable","Symbol","kDefaultPrevented","CancelableMessageEvent","MessageEvent","constructor","type","init","cancelable","nextCancelable","defaultPrevented","nextDefaultPrevented","preventDefault","CloseEvent","Event","code","reason","wasClean","CancelableCloseEvent","kEmitter","kBoundListener","WebSocketClientConnectionProtocol","WebSocketClientConnection","socket","transport","id","_chunkTIPR373Rjs","createRequestId","call","url","URL","EventTarget","addEventListener","message","data","origin","dispatchEvent","listener","options","Reflect","has","boundListener","bind","defineProperty","configurable","get","removeEventListener","send","close","_outvariant","require","_deferredpromise","WEBSOCKET_CLOSE_CODE_RANGE_ERROR","kPassthroughPromise","kOnSend","kClose","WebSocketOverride","protocols","CONNECTING","OPEN","CLOSING","CLOSED","_onopen","_onmessage","_onerror","_onclose","toString","protocol","extensions","binaryType","readyState","bufferedAmount","DeferredPromise","queueMicrotask","Array","isArray","length","onopen","onmessage","onerror","onclose","DOMException","getDataSize","_a","invariant","callback","Blob","size","byteLength","kEmitter2","kBoundListener2","kSend","WebSocketServerConnectionProtocol","WebSocketServerConnection","client","createConnection","mockCloseController","AbortController","realCloseController","realWebSocket","handleIncomingMessage","connect","WebSocket","once","handleMockClose","signal","handleRealClose","errorEvent","abort","messageEvent","_event","closeEvent","WebSocketClassTransport","_WebSocketInterceptor","Interceptor","symbol","checkEnvironment","_chunk2HUMWGRDjs","hasConfigurableGlobal","setup","originalWebSocketDescriptor","getOwnPropertyDescriptor","globalThis","WebSocketProxy","Proxy","construct","args","newTarget","server","hasConnectionListeners","emitter","listenerCount","emitAsync","info","resolve","error","Error","console","subscriptions","push","WebSocketInterceptor"],"sources":["../../../../src/interceptors/WebSocket/utils/bindEvent.ts","../../../../src/interceptors/WebSocket/utils/events.ts","../../../../src/interceptors/WebSocket/WebSocketClientConnection.ts","../../../../src/interceptors/WebSocket/WebSocketServerConnection.ts","../../../../src/interceptors/WebSocket/WebSocketOverride.ts","../../../../src/interceptors/WebSocket/WebSocketClassTransport.ts","../../../../src/interceptors/WebSocket/index.ts"],"sourcesContent":["type EventWithTarget<E extends Event, T> = E & { target: T }\n\nexport function bindEvent<E extends Event, T>(\n  target: T,\n  event: E\n): EventWithTarget<E, T> {\n  Object.defineProperties(event, {\n    target: {\n      value: target,\n      enumerable: true,\n      writable: true,\n    },\n    currentTarget: {\n      value: target,\n      enumerable: true,\n      writable: true,\n    },\n  })\n\n  return event as EventWithTarget<E, T>\n}\n","const kCancelable = Symbol('kCancelable')\nconst kDefaultPrevented = Symbol('kDefaultPrevented')\n\n/**\n * A `MessageEvent` superset that supports event cancellation\n * in Node.js. It's rather non-intrusive so it can be safely\n * used in the browser as well.\n *\n * @see https://github.com/nodejs/node/issues/51767\n */\nexport class CancelableMessageEvent<T = any> extends MessageEvent<T> {\n  [kCancelable]: boolean;\n  [kDefaultPrevented]: boolean\n\n  constructor(type: string, init: MessageEventInit<T>) {\n    super(type, init)\n    this[kCancelable] = !!init.cancelable\n    this[kDefaultPrevented] = false\n  }\n\n  get cancelable() {\n    return this[kCancelable]\n  }\n\n  set cancelable(nextCancelable) {\n    this[kCancelable] = nextCancelable\n  }\n\n  get defaultPrevented() {\n    return this[kDefaultPrevented]\n  }\n\n  set defaultPrevented(nextDefaultPrevented) {\n    this[kDefaultPrevented] = nextDefaultPrevented\n  }\n\n  public preventDefault(): void {\n    if (this.cancelable && !this[kDefaultPrevented]) {\n      this[kDefaultPrevented] = true\n    }\n  }\n}\n\ninterface CloseEventInit extends EventInit {\n  code?: number\n  reason?: string\n  wasClean?: boolean\n}\n\nexport class CloseEvent extends Event {\n  public code: number\n  public reason: string\n  public wasClean: boolean\n\n  constructor(type: string, init: CloseEventInit = {}) {\n    super(type, init)\n    this.code = init.code === undefined ? 0 : init.code\n    this.reason = init.reason === undefined ? '' : init.reason\n    this.wasClean = init.wasClean === undefined ? false : init.wasClean\n  }\n}\n\nexport class CancelableCloseEvent extends CloseEvent {\n  [kCancelable]: boolean;\n  [kDefaultPrevented]: boolean\n\n  constructor(type: string, init: CloseEventInit = {}) {\n    super(type, init)\n    this[kCancelable] = !!init.cancelable\n    this[kDefaultPrevented] = false\n  }\n\n  get cancelable() {\n    return this[kCancelable]\n  }\n\n  set cancelable(nextCancelable) {\n    this[kCancelable] = nextCancelable\n  }\n\n  get defaultPrevented() {\n    return this[kDefaultPrevented]\n  }\n\n  set defaultPrevented(nextDefaultPrevented) {\n    this[kDefaultPrevented] = nextDefaultPrevented\n  }\n\n  public preventDefault(): void {\n    if (this.cancelable && !this[kDefaultPrevented]) {\n      this[kDefaultPrevented] = true\n    }\n  }\n}\n","import type { WebSocketData, WebSocketTransport } from './WebSocketTransport'\nimport type { WebSocketEventListener } from './WebSocketOverride'\nimport { bindEvent } from './utils/bindEvent'\nimport { CancelableMessageEvent, CloseEvent } from './utils/events'\nimport { createRequestId } from '../../createRequestId'\n\nconst kEmitter = Symbol('kEmitter')\nconst kBoundListener = Symbol('kBoundListener')\n\nexport interface WebSocketClientEventMap {\n  message: MessageEvent<WebSocketData>\n  close: CloseEvent\n}\n\nexport abstract class WebSocketClientConnectionProtocol {\n  abstract id: string\n  abstract url: URL\n  public abstract send(data: WebSocketData): void\n  public abstract close(code?: number, reason?: string): void\n\n  public abstract addEventListener<\n    EventType extends keyof WebSocketClientEventMap\n  >(\n    type: EventType,\n    listener: WebSocketEventListener<WebSocketClientEventMap[EventType]>,\n    options?: AddEventListenerOptions | boolean\n  ): void\n\n  public abstract removeEventListener<\n    EventType extends keyof WebSocketClientEventMap\n  >(\n    event: EventType,\n    listener: WebSocketEventListener<WebSocketClientEventMap[EventType]>,\n    options?: EventListenerOptions | boolean\n  ): void\n}\n\n/**\n * The WebSocket client instance represents an incoming\n * client connection. The user can control the connection,\n * send and receive events.\n */\nexport class WebSocketClientConnection\n  implements WebSocketClientConnectionProtocol\n{\n  public readonly id: string\n  public readonly url: URL\n\n  private [kEmitter]: EventTarget\n\n  constructor(\n    public readonly socket: WebSocket,\n    private readonly transport: WebSocketTransport\n  ) {\n    this.id = createRequestId()\n    this.url = new URL(socket.url)\n    this[kEmitter] = new EventTarget()\n\n    // Emit outgoing client data (\"ws.send()\") as \"message\"\n    // events on the \"client\" connection.\n    this.transport.addEventListener('outgoing', (event) => {\n      const message = bindEvent(\n        this.socket,\n        new CancelableMessageEvent('message', {\n          data: event.data,\n          origin: event.origin,\n          cancelable: true,\n        })\n      )\n\n      this[kEmitter].dispatchEvent(message)\n\n      // This is a bit silly but forward the cancellation state\n      // of the \"client\" message event to the \"outgoing\" transport event.\n      // This way, other agens (like \"server\" connection) can know\n      // whether the client listener has pervented the default.\n      if (message.defaultPrevented) {\n        event.preventDefault()\n      }\n    })\n\n    /**\n     * Emit the \"close\" event on the \"client\" connection\n     * whenever the underlying transport is closed.\n     * @note \"client.close()\" does NOT dispatch the \"close\"\n     * event on the WebSocket because it uses non-configurable\n     * close status code. Thus, we listen to the transport\n     * instead of the WebSocket's \"close\" event.\n     */\n    this.transport.addEventListener('close', (event) => {\n      this[kEmitter].dispatchEvent(\n        bindEvent(this.socket, new CloseEvent('close', event))\n      )\n    })\n  }\n\n  /**\n   * Listen for the outgoing events from the connected WebSocket client.\n   */\n  public addEventListener<EventType extends keyof WebSocketClientEventMap>(\n    type: EventType,\n    listener: WebSocketEventListener<WebSocketClientEventMap[EventType]>,\n    options?: AddEventListenerOptions | boolean\n  ): void {\n    if (!Reflect.has(listener, kBoundListener)) {\n      const boundListener = listener.bind(this.socket)\n\n      // Store the bound listener on the original listener\n      // so the exact bound function can be accessed in \"removeEventListener()\".\n      Object.defineProperty(listener, kBoundListener, {\n        value: boundListener,\n        enumerable: false,\n        configurable: false,\n      })\n    }\n\n    this[kEmitter].addEventListener(\n      type,\n      Reflect.get(listener, kBoundListener) as EventListener,\n      options\n    )\n  }\n\n  /**\n   * Removes the listener for the given event.\n   */\n  public removeEventListener<EventType extends keyof WebSocketClientEventMap>(\n    event: EventType,\n    listener: WebSocketEventListener<WebSocketClientEventMap[EventType]>,\n    options?: EventListenerOptions | boolean\n  ): void {\n    this[kEmitter].removeEventListener(\n      event,\n      Reflect.get(listener, kBoundListener) as EventListener,\n      options\n    )\n  }\n\n  /**\n   * Send data to the connected client.\n   */\n  public send(data: WebSocketData): void {\n    this.transport.send(data)\n  }\n\n  /**\n   * Close the WebSocket connection.\n   * @param {number} code A status code (see https://www.rfc-editor.org/rfc/rfc6455#section-7.4.1).\n   * @param {string} reason A custom connection close reason.\n   */\n  public close(code?: number, reason?: string): void {\n    this.transport.close(code, reason)\n  }\n}\n","import { invariant } from 'outvariant'\nimport {\n  kClose,\n  WebSocketEventListener,\n  WebSocketOverride,\n} from './WebSocketOverride'\nimport type { WebSocketData } from './WebSocketTransport'\nimport type { WebSocketClassTransport } from './WebSocketClassTransport'\nimport { bindEvent } from './utils/bindEvent'\nimport {\n  CancelableMessageEvent,\n  CancelableCloseEvent,\n  CloseEvent,\n} from './utils/events'\n\nconst kEmitter = Symbol('kEmitter')\nconst kBoundListener = Symbol('kBoundListener')\nconst kSend = Symbol('kSend')\n\nexport interface WebSocketServerEventMap {\n  open: Event\n  message: MessageEvent<WebSocketData>\n  error: Event\n  close: CloseEvent\n}\n\nexport abstract class WebSocketServerConnectionProtocol {\n  public abstract connect(): void\n  public abstract send(data: WebSocketData): void\n  public abstract close(): void\n\n  public abstract addEventListener<\n    EventType extends keyof WebSocketServerEventMap\n  >(\n    event: EventType,\n    listener: WebSocketEventListener<WebSocketServerEventMap[EventType]>,\n    options?: AddEventListenerOptions | boolean\n  ): void\n\n  public abstract removeEventListener<\n    EventType extends keyof WebSocketServerEventMap\n  >(\n    event: EventType,\n    listener: WebSocketEventListener<WebSocketServerEventMap[EventType]>,\n    options?: EventListenerOptions | boolean\n  ): void\n}\n\n/**\n * The WebSocket server instance represents the actual production\n * WebSocket server connection. It's idle by default but you can\n * establish it by calling `server.connect()`.\n */\nexport class WebSocketServerConnection\n  implements WebSocketServerConnectionProtocol\n{\n  /**\n   * A WebSocket instance connected to the original server.\n   */\n  private realWebSocket?: WebSocket\n  private mockCloseController: AbortController\n  private realCloseController: AbortController\n  private [kEmitter]: EventTarget\n\n  constructor(\n    private readonly client: WebSocketOverride,\n    private readonly transport: WebSocketClassTransport,\n    private readonly createConnection: () => WebSocket\n  ) {\n    this[kEmitter] = new EventTarget()\n    this.mockCloseController = new AbortController()\n    this.realCloseController = new AbortController()\n\n    // Automatically forward outgoing client events\n    // to the actual server unless the outgoing message event\n    // has been prevented. The \"outgoing\" transport event it\n    // dispatched by the \"client\" connection.\n    this.transport.addEventListener('outgoing', (event) => {\n      // Ignore client messages if the server connection\n      // hasn't been established yet. Nowhere to forward.\n      if (typeof this.realWebSocket === 'undefined') {\n        return\n      }\n\n      // Every outgoing client message can prevent this forwarding\n      // by preventing the default of the outgoing message event.\n      // This listener will be added before user-defined listeners,\n      // so execute the logic on the next tick.\n      queueMicrotask(() => {\n        if (!event.defaultPrevented) {\n          /**\n           * @note Use the internal send mechanism so consumers can tell\n           * apart direct user calls to `server.send()` and internal calls.\n           * E.g. MSW has to ignore this internal call to log out messages correctly.\n           */\n          this[kSend](event.data)\n        }\n      })\n    })\n\n    this.transport.addEventListener(\n      'incoming',\n      this.handleIncomingMessage.bind(this)\n    )\n  }\n\n  /**\n   * The `WebSocket` instance connected to the original server.\n   * Accessing this before calling `server.connect()` will throw.\n   */\n  public get socket(): WebSocket {\n    invariant(\n      this.realWebSocket,\n      'Cannot access \"socket\" on the original WebSocket server object: the connection is not open. Did you forget to call `server.connect()`?'\n    )\n\n    return this.realWebSocket\n  }\n\n  /**\n   * Open connection to the original WebSocket server.\n   */\n  public connect(): void {\n    invariant(\n      !this.realWebSocket || this.realWebSocket.readyState !== WebSocket.OPEN,\n      'Failed to call \"connect()\" on the original WebSocket instance: the connection already open'\n    )\n\n    const realWebSocket = this.createConnection()\n\n    // Inherit the binary type from the mock WebSocket client.\n    realWebSocket.binaryType = this.client.binaryType\n\n    // Allow the interceptor to listen to when the server connection\n    // has been established. This isn't necessary to operate with the connection\n    // but may be beneficial in some cases (like conditionally adding logging).\n    realWebSocket.addEventListener(\n      'open',\n      (event) => {\n        this[kEmitter].dispatchEvent(\n          bindEvent(this.realWebSocket!, new Event('open', event))\n        )\n      },\n      { once: true }\n    )\n\n    realWebSocket.addEventListener('message', (event) => {\n      // Dispatch the \"incoming\" transport event instead of\n      // invoking the internal handler directly. This way,\n      // anyone can listen to the \"incoming\" event but this\n      // class is the one resulting in it.\n      this.transport.dispatchEvent(\n        bindEvent(\n          this.realWebSocket!,\n          new MessageEvent('incoming', {\n            data: event.data,\n            origin: event.origin,\n          })\n        )\n      )\n    })\n\n    // Close the original connection when the mock client closes.\n    // E.g. \"client.close()\" was called. This is never forwarded anywhere.\n    this.client.addEventListener(\n      'close',\n      (event) => {\n        this.handleMockClose(event)\n      },\n      {\n        signal: this.mockCloseController.signal,\n      }\n    )\n\n    // Forward the \"close\" event to let the interceptor handle\n    // closures initiated by the original server.\n    realWebSocket.addEventListener(\n      'close',\n      (event) => {\n        this.handleRealClose(event)\n      },\n      {\n        signal: this.realCloseController.signal,\n      }\n    )\n\n    realWebSocket.addEventListener('error', () => {\n      const errorEvent = bindEvent(\n        realWebSocket,\n        new Event('error', { cancelable: true })\n      )\n\n      // Emit the \"error\" event on the `server` connection\n      // to let the interceptor react to original server errors.\n      this[kEmitter].dispatchEvent(errorEvent)\n\n      // If the error event from the original server hasn't been prevented,\n      // forward it to the underlying client.\n      if (!errorEvent.defaultPrevented) {\n        this.client.dispatchEvent(bindEvent(this.client, new Event('error')))\n      }\n    })\n\n    this.realWebSocket = realWebSocket\n  }\n\n  /**\n   * Listen for the incoming events from the original WebSocket server.\n   */\n  public addEventListener<EventType extends keyof WebSocketServerEventMap>(\n    event: EventType,\n    listener: WebSocketEventListener<WebSocketServerEventMap[EventType]>,\n    options?: AddEventListenerOptions | boolean\n  ): void {\n    if (!Reflect.has(listener, kBoundListener)) {\n      const boundListener = listener.bind(this.client)\n\n      // Store the bound listener on the original listener\n      // so the exact bound function can be accessed in \"removeEventListener()\".\n      Object.defineProperty(listener, kBoundListener, {\n        value: boundListener,\n        enumerable: false,\n      })\n    }\n\n    this[kEmitter].addEventListener(\n      event,\n      Reflect.get(listener, kBoundListener) as EventListener,\n      options\n    )\n  }\n\n  /**\n   * Remove the listener for the given event.\n   */\n  public removeEventListener<EventType extends keyof WebSocketServerEventMap>(\n    event: EventType,\n    listener: WebSocketEventListener<WebSocketServerEventMap[EventType]>,\n    options?: EventListenerOptions | boolean\n  ): void {\n    this[kEmitter].removeEventListener(\n      event,\n      Reflect.get(listener, kBoundListener) as EventListener,\n      options\n    )\n  }\n\n  /**\n   * Send data to the original WebSocket server.\n   * @example\n   * server.send('hello')\n   * server.send(new Blob(['hello']))\n   * server.send(new TextEncoder().encode('hello'))\n   */\n  public send(data: WebSocketData): void {\n    this[kSend](data)\n  }\n\n  private [kSend](data: WebSocketData): void {\n    const { realWebSocket } = this\n\n    invariant(\n      realWebSocket,\n      'Failed to call \"server.send()\" for \"%s\": the connection is not open. Did you forget to call \"server.connect()\"?',\n      this.client.url\n    )\n\n    // Silently ignore writes on the closed original WebSocket.\n    if (\n      realWebSocket.readyState === WebSocket.CLOSING ||\n      realWebSocket.readyState === WebSocket.CLOSED\n    ) {\n      return\n    }\n\n    // Delegate the send to when the original connection is open.\n    // Unlike the mock, connecting to the original server may take time\n    // so we cannot call this on the next tick.\n    if (realWebSocket.readyState === WebSocket.CONNECTING) {\n      realWebSocket.addEventListener(\n        'open',\n        () => {\n          realWebSocket.send(data)\n        },\n        { once: true }\n      )\n      return\n    }\n\n    // Send the data to the original WebSocket server.\n    realWebSocket.send(data)\n  }\n\n  /**\n   * Close the actual server connection.\n   */\n  public close(): void {\n    const { realWebSocket } = this\n\n    invariant(\n      realWebSocket,\n      'Failed to close server connection for \"%s\": the connection is not open. Did you forget to call \"server.connect()\"?',\n      this.client.url\n    )\n\n    // Remove the \"close\" event listener from the server\n    // so it doesn't close the underlying WebSocket client\n    // when you call \"server.close()\". This also prevents the\n    // `close` event on the `server` connection from being dispatched twice.\n    this.realCloseController.abort()\n\n    if (\n      realWebSocket.readyState === WebSocket.CLOSING ||\n      realWebSocket.readyState === WebSocket.CLOSED\n    ) {\n      return\n    }\n\n    // Close the actual client connection.\n    realWebSocket.close()\n\n    // Dispatch the \"close\" event on the `server` connection.\n    queueMicrotask(() => {\n      this[kEmitter].dispatchEvent(\n        bindEvent(\n          this.realWebSocket,\n          new CancelableCloseEvent('close', {\n            /**\n             * @note `server.close()` in the interceptor\n             * always results in clean closures.\n             */\n            code: 1000,\n            cancelable: true,\n          })\n        )\n      )\n    })\n  }\n\n  private handleIncomingMessage(event: MessageEvent<WebSocketData>): void {\n    // Clone the event to dispatch it on this class\n    // once again and prevent the \"already being dispatched\"\n    // exception. Clone it here so we can observe this event\n    // being prevented in the \"server.on()\" listeners.\n    const messageEvent = bindEvent(\n      event.target,\n      new CancelableMessageEvent('message', {\n        data: event.data,\n        origin: event.origin,\n        cancelable: true,\n      })\n    )\n\n    /**\n     * @note Emit \"message\" event on the server connection\n     * instance to let the interceptor know about these\n     * incoming events from the original server. In that listener,\n     * the interceptor can modify or skip the event forwarding\n     * to the mock WebSocket instance.\n     */\n    this[kEmitter].dispatchEvent(messageEvent)\n\n    /**\n     * @note Forward the incoming server events to the client.\n     * Preventing the default on the message event stops this.\n     */\n    if (!messageEvent.defaultPrevented) {\n      this.client.dispatchEvent(\n        bindEvent(\n          /**\n           * @note Bind the forwarded original server events\n           * to the mock WebSocket instance so it would\n           * dispatch them straight away.\n           */\n          this.client,\n          // Clone the message event again to prevent\n          // the \"already being dispatched\" exception.\n          new MessageEvent('message', {\n            data: event.data,\n            origin: event.origin,\n          })\n        )\n      )\n    }\n  }\n\n  private handleMockClose(_event: Event): void {\n    // Close the original connection if the mock client closes.\n    if (this.realWebSocket) {\n      this.realWebSocket.close()\n    }\n  }\n\n  private handleRealClose(event: CloseEvent): void {\n    // For closures originating from the original server,\n    // remove the \"close\" listener from the mock client.\n    // original close -> (?) client[kClose]() --X--> \"close\" (again).\n    this.mockCloseController.abort()\n\n    const closeEvent = bindEvent(\n      this.realWebSocket,\n      new CancelableCloseEvent('close', {\n        code: event.code,\n        reason: event.reason,\n        wasClean: event.wasClean,\n        cancelable: true,\n      })\n    )\n\n    this[kEmitter].dispatchEvent(closeEvent)\n\n    // If the close event from the server hasn't been prevented,\n    // forward the closure to the mock client.\n    if (!closeEvent.defaultPrevented) {\n      // Close the intercepted client forcefully to\n      // allow non-configurable status codes from the server.\n      // If the socket has been closed by now, no harm calling\n      // this again—it will have no effect.\n      this.client[kClose](event.code, event.reason)\n    }\n  }\n}\n","import { invariant } from 'outvariant'\nimport type { WebSocketData } from './WebSocketTransport'\nimport { bindEvent } from './utils/bindEvent'\nimport { CloseEvent } from './utils/events'\nimport { DeferredPromise } from '@open-draft/deferred-promise'\n\nexport type WebSocketEventListener<\n  EventType extends WebSocketEventMap[keyof WebSocketEventMap] = Event\n> = (this: WebSocket, event: EventType) => void\n\nconst WEBSOCKET_CLOSE_CODE_RANGE_ERROR =\n  'InvalidAccessError: close code out of user configurable range'\n\nexport const kPassthroughPromise = Symbol('kPassthroughPromise')\nexport const kOnSend = Symbol('kOnSend')\nexport const kClose = Symbol('kClose')\n\nexport class WebSocketOverride extends EventTarget implements WebSocket {\n  static readonly CONNECTING = 0\n  static readonly OPEN = 1\n  static readonly CLOSING = 2\n  static readonly CLOSED = 3\n  readonly CONNECTING = 0\n  readonly OPEN = 1\n  readonly CLOSING = 2\n  readonly CLOSED = 3\n\n  public url: string\n  public protocol: string\n  public extensions: string\n  public binaryType: BinaryType\n  public readyState: number\n  public bufferedAmount: number\n\n  private _onopen: WebSocketEventListener | null = null\n  private _onmessage: WebSocketEventListener<\n    MessageEvent<WebSocketData>\n  > | null = null\n  private _onerror: WebSocketEventListener | null = null\n  private _onclose: WebSocketEventListener<CloseEvent> | null = null\n\n  private [kPassthroughPromise]: DeferredPromise<boolean>\n  private [kOnSend]?: (data: WebSocketData) => void\n\n  constructor(url: string | URL, protocols?: string | Array<string>) {\n    super()\n    this.url = url.toString()\n    this.protocol = ''\n    this.extensions = ''\n    this.binaryType = 'blob'\n    this.readyState = this.CONNECTING\n    this.bufferedAmount = 0\n\n    this[kPassthroughPromise] = new DeferredPromise<boolean>()\n\n    queueMicrotask(async () => {\n      if (await this[kPassthroughPromise]) {\n        return\n      }\n\n      this.protocol =\n        typeof protocols === 'string'\n          ? protocols\n          : Array.isArray(protocols) && protocols.length > 0\n          ? protocols[0]\n          : ''\n\n      /**\n       * @note Check that nothing has prevented this connection\n       * (e.g. called `client.close()` in the connection listener).\n       * If the connection has been prevented, never dispatch the open event,.\n       */\n      if (this.readyState === this.CONNECTING) {\n        this.readyState = this.OPEN\n        this.dispatchEvent(bindEvent(this, new Event('open')))\n      }\n    })\n  }\n\n  set onopen(listener: WebSocketEventListener | null) {\n    this.removeEventListener('open', this._onopen)\n    this._onopen = listener\n    if (listener !== null) {\n      this.addEventListener('open', listener)\n    }\n  }\n  get onopen(): WebSocketEventListener | null {\n    return this._onopen\n  }\n\n  set onmessage(\n    listener: WebSocketEventListener<MessageEvent<WebSocketData>> | null\n  ) {\n    this.removeEventListener(\n      'message',\n      this._onmessage as WebSocketEventListener\n    )\n    this._onmessage = listener\n    if (listener !== null) {\n      this.addEventListener('message', listener)\n    }\n  }\n  get onmessage(): WebSocketEventListener<MessageEvent<WebSocketData>> | null {\n    return this._onmessage\n  }\n\n  set onerror(listener: WebSocketEventListener | null) {\n    this.removeEventListener('error', this._onerror)\n    this._onerror = listener\n    if (listener !== null) {\n      this.addEventListener('error', listener)\n    }\n  }\n  get onerror(): WebSocketEventListener | null {\n    return this._onerror\n  }\n\n  set onclose(listener: WebSocketEventListener<CloseEvent> | null) {\n    this.removeEventListener('close', this._onclose as WebSocketEventListener)\n    this._onclose = listener\n    if (listener !== null) {\n      this.addEventListener('close', listener)\n    }\n  }\n  get onclose(): WebSocketEventListener<CloseEvent> | null {\n    return this._onclose\n  }\n\n  /**\n   * @see https://websockets.spec.whatwg.org/#ref-for-dom-websocket-send%E2%91%A0\n   */\n  public send(data: WebSocketData): void {\n    if (this.readyState === this.CONNECTING) {\n      this.close()\n      throw new DOMException('InvalidStateError')\n    }\n\n    // Sending when the socket is about to close\n    // discards the sent data.\n    if (this.readyState === this.CLOSING || this.readyState === this.CLOSED) {\n      return\n    }\n\n    // Buffer the data to send in this even loop\n    // but send it in the next.\n    this.bufferedAmount += getDataSize(data)\n\n    queueMicrotask(() => {\n      // This is a bit optimistic but since no actual data transfer\n      // is involved, all the data will be \"sent\" on the next tick.\n      this.bufferedAmount = 0\n\n      /**\n       * @note Notify the parent about outgoing data.\n       * This notifies the transport and the connection\n       * listens to the outgoing data to emit the \"message\" event.\n       */\n      this[kOnSend]?.(data)\n    })\n  }\n\n  public close(code: number = 1000, reason?: string): void {\n    invariant(code, WEBSOCKET_CLOSE_CODE_RANGE_ERROR)\n    invariant(\n      code === 1000 || (code >= 3000 && code <= 4999),\n      WEBSOCKET_CLOSE_CODE_RANGE_ERROR\n    )\n\n    this[kClose](code, reason)\n  }\n\n  private [kClose](\n    code: number = 1000,\n    reason?: string,\n    wasClean = true\n  ): void {\n    /**\n     * @note Move this check here so that even internal closures,\n     * like those triggered by the `server` connection, are not\n     * performed twice.\n     */\n    if (this.readyState === this.CLOSING || this.readyState === this.CLOSED) {\n      return\n    }\n\n    this.readyState = this.CLOSING\n\n    queueMicrotask(() => {\n      this.readyState = this.CLOSED\n\n      this.dispatchEvent(\n        bindEvent(\n          this,\n          new CloseEvent('close', {\n            code,\n            reason,\n            wasClean,\n          })\n        )\n      )\n\n      // Remove all event listeners once the socket is closed.\n      this._onopen = null\n      this._onmessage = null\n      this._onerror = null\n      this._onclose = null\n    })\n  }\n\n  public addEventListener<K extends keyof WebSocketEventMap>(\n    type: K,\n    listener: (this: WebSocket, event: WebSocketEventMap[K]) => void,\n    options?: boolean | AddEventListenerOptions\n  ): void\n  public addEventListener(\n    type: string,\n    listener: EventListenerOrEventListenerObject,\n    options?: boolean | AddEventListenerOptions\n  ): void\n  public addEventListener(\n    type: unknown,\n    listener: unknown,\n    options?: unknown\n  ): void {\n    return super.addEventListener(\n      type as string,\n      listener as EventListener,\n      options as AddEventListenerOptions\n    )\n  }\n\n  removeEventListener<K extends keyof WebSocketEventMap>(\n    type: K,\n    callback: EventListenerOrEventListenerObject | null,\n    options?: boolean | EventListenerOptions\n  ): void {\n    return super.removeEventListener(type, callback, options)\n  }\n}\n\nfunction getDataSize(data: WebSocketData): number {\n  if (typeof data === 'string') {\n    return data.length\n  }\n\n  if (data instanceof Blob) {\n    return data.size\n  }\n\n  return data.byteLength\n}\n","import { bindEvent } from './utils/bindEvent'\nimport {\n  StrictEventListenerOrEventListenerObject,\n  WebSocketData,\n  WebSocketTransport,\n  WebSocketTransportEventMap,\n} from './WebSocketTransport'\nimport { kOnSend, kClose, WebSocketOverride } from './WebSocketOverride'\nimport { CancelableMessageEvent, CloseEvent } from './utils/events'\n\n/**\n * Abstraction over the given mock `WebSocket` instance that allows\n * for controlling that instance (e.g. sending and receiving messages).\n */\nexport class WebSocketClassTransport\n  extends EventTarget\n  implements WebSocketTransport\n{\n  constructor(protected readonly socket: WebSocketOverride) {\n    super()\n\n    // Emit the \"close\" event on the transport if the close\n    // originates from the WebSocket client. E.g. the application\n    // calls \"ws.close()\", not the interceptor.\n    this.socket.addEventListener('close', (event) => {\n      this.dispatchEvent(bindEvent(this.socket, new CloseEvent('close', event)))\n    })\n\n    /**\n     * Emit the \"outgoing\" event on the transport\n     * whenever the WebSocket client sends data (\"ws.send()\").\n     */\n    this.socket[kOnSend] = (data) => {\n      this.dispatchEvent(\n        bindEvent(\n          this.socket,\n          // Dispatch this as cancelable because \"client\" connection\n          // re-creates this message event (cannot dispatch the same event).\n          new CancelableMessageEvent('outgoing', {\n            data,\n            origin: this.socket.url,\n            cancelable: true,\n          })\n        )\n      )\n    }\n  }\n\n  public addEventListener<EventType extends keyof WebSocketTransportEventMap>(\n    type: EventType,\n    callback: StrictEventListenerOrEventListenerObject<\n      WebSocketTransportEventMap[EventType]\n    > | null,\n    options?: boolean | AddEventListenerOptions\n  ): void {\n    return super.addEventListener(type, callback as EventListener, options)\n  }\n\n  public dispatchEvent<EventType extends keyof WebSocketTransportEventMap>(\n    event: WebSocketTransportEventMap[EventType]\n  ): boolean {\n    return super.dispatchEvent(event)\n  }\n\n  public send(data: WebSocketData): void {\n    queueMicrotask(() => {\n      if (\n        this.socket.readyState === this.socket.CLOSING ||\n        this.socket.readyState === this.socket.CLOSED\n      ) {\n        return\n      }\n\n      const dispatchEvent = () => {\n        this.socket.dispatchEvent(\n          bindEvent(\n            /**\n             * @note Setting this event's \"target\" to the\n             * WebSocket override instance is important.\n             * This way it can tell apart original incoming events\n             * (must be forwarded to the transport) from the\n             * mocked message events like the one below\n             * (must be dispatched on the client instance).\n             */\n            this.socket,\n            new MessageEvent('message', {\n              data,\n              origin: this.socket.url,\n            })\n          )\n        )\n      }\n\n      if (this.socket.readyState === this.socket.CONNECTING) {\n        this.socket.addEventListener(\n          'open',\n          () => {\n            dispatchEvent()\n          },\n          { once: true }\n        )\n      } else {\n        dispatchEvent()\n      }\n    })\n  }\n\n  public close(code: number, reason?: string): void {\n    /**\n     * @note Call the internal close method directly\n     * to allow closing the connection with the status codes\n     * that are non-configurable by the user (> 1000 <= 1015).\n     */\n    this.socket[kClose](code, reason)\n  }\n}\n","import { Interceptor } from '../../Interceptor'\nimport {\n  WebSocketClientConnectionProtocol,\n  WebSocketClientConnection,\n  type WebSocketClientEventMap,\n} from './WebSocketClientConnection'\nimport {\n  WebSocketServerConnectionProtocol,\n  WebSocketServerConnection,\n  type WebSocketServerEventMap,\n} from './WebSocketServerConnection'\nimport { WebSocketClassTransport } from './WebSocketClassTransport'\nimport {\n  kClose,\n  kPassthroughPromise,\n  WebSocketOverride,\n} from './WebSocketOverride'\nimport { bindEvent } from './utils/bindEvent'\nimport { hasConfigurableGlobal } from '../../utils/hasConfigurableGlobal'\nimport { emitAsync } from '../../utils/emitAsync'\n\nexport { type WebSocketData, WebSocketTransport } from './WebSocketTransport'\nexport {\n  WebSocketClientEventMap,\n  WebSocketClientConnectionProtocol,\n  WebSocketClientConnection,\n  WebSocketServerEventMap,\n  WebSocketServerConnectionProtocol,\n  WebSocketServerConnection,\n}\n\nexport {\n  CloseEvent,\n  CancelableCloseEvent,\n  CancelableMessageEvent,\n} from './utils/events'\n\nexport type WebSocketEventMap = {\n  connection: [args: WebSocketConnectionData]\n}\n\nexport type WebSocketConnectionData = {\n  /**\n   * The incoming WebSocket client connection.\n   */\n  client: WebSocketClientConnection\n\n  /**\n   * The original WebSocket server connection.\n   */\n  server: WebSocketServerConnection\n\n  /**\n   * The connection information.\n   */\n  info: {\n    /**\n     * The protocols supported by the WebSocket client.\n     */\n    protocols: string | Array<string> | undefined\n  }\n}\n\n/**\n * Intercept the outgoing WebSocket connections created using\n * the global `WebSocket` class.\n */\nexport class WebSocketInterceptor extends Interceptor<WebSocketEventMap> {\n  static symbol = Symbol('websocket')\n\n  constructor() {\n    super(WebSocketInterceptor.symbol)\n  }\n\n  protected checkEnvironment(): boolean {\n    return hasConfigurableGlobal('WebSocket')\n  }\n\n  protected setup(): void {\n    const originalWebSocketDescriptor = Object.getOwnPropertyDescriptor(\n      globalThis,\n      'WebSocket'\n    )\n\n    const WebSocketProxy = new Proxy(globalThis.WebSocket, {\n      construct: (\n        target,\n        args: ConstructorParameters<typeof globalThis.WebSocket>,\n        newTarget\n      ) => {\n        const [url, protocols] = args\n\n        const createConnection = (): WebSocket => {\n          return Reflect.construct(target, args, newTarget)\n        }\n\n        // All WebSocket instances are mocked and don't forward\n        // any events to the original server (no connection established).\n        // To forward the events, the user must use the \"server.send()\" API.\n        const socket = new WebSocketOverride(url, protocols)\n        const transport = new WebSocketClassTransport(socket)\n\n        // Emit the \"connection\" event to the interceptor on the next tick\n        // so the client can modify WebSocket options, like \"binaryType\"\n        // while the connection is already pending.\n        queueMicrotask(async () => {\n          try {\n            const server = new WebSocketServerConnection(\n              socket,\n              transport,\n              createConnection\n            )\n\n            const hasConnectionListeners =\n              this.emitter.listenerCount('connection') > 0\n\n            // The \"globalThis.WebSocket\" class stands for\n            // the client-side connection. Assume it's established\n            // as soon as the WebSocket instance is constructed.\n            await emitAsync(this.emitter, 'connection', {\n              client: new WebSocketClientConnection(socket, transport),\n              server,\n              info: {\n                protocols,\n              },\n            })\n\n            if (hasConnectionListeners) {\n              socket[kPassthroughPromise].resolve(false)\n            } else {\n              socket[kPassthroughPromise].resolve(true)\n\n              server.connect()\n\n              // Forward the \"open\" event from the original server\n              // to the mock WebSocket client in the case of a passthrough connection.\n              server.addEventListener('open', () => {\n                socket.dispatchEvent(bindEvent(socket, new Event('open')))\n\n                // Forward the original connection protocol to the\n                // mock WebSocket client.\n                if (server['realWebSocket']) {\n                  socket.protocol = server['realWebSocket'].protocol\n                }\n              })\n            }\n          } catch (error) {\n            /**\n             * @note Translate unhandled exceptions during the connection\n             * handling (i.e. interceptor exceptions) as WebSocket connection\n             * closures with error. This prevents from the exceptions occurring\n             * in `queueMicrotask` from being process-wide and uncatchable.\n             */\n            if (error instanceof Error) {\n              socket.dispatchEvent(new Event('error'))\n\n              // No need to close the connection if it's already being closed.\n              // E.g. the interceptor called `client.close()` and then threw an error.\n              if (\n                socket.readyState !== WebSocket.CLOSING &&\n                socket.readyState !== WebSocket.CLOSED\n              ) {\n                socket[kClose](1011, error.message, false)\n              }\n\n              console.error(error)\n            }\n          }\n        })\n\n        return socket\n      },\n    })\n\n    Object.defineProperty(globalThis, 'WebSocket', {\n      value: WebSocketProxy,\n      configurable: true,\n    })\n\n    this.subscriptions.push(() => {\n      Object.defineProperty(\n        globalThis,\n        'WebSocket',\n        originalWebSocketDescriptor!\n      )\n    })\n  }\n}\n"],"mappings":"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","ignoreList":[]}