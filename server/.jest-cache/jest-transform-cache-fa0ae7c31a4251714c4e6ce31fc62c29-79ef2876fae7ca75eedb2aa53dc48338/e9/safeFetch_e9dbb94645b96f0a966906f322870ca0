4c9fd2789c7590d4f3cd42d172b6f60b
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _nodeFetch = _interopRequireDefault(require("node-fetch"));
var _fs = _interopRequireDefault(require("fs"));
var _path = _interopRequireDefault(require("path"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
// Minimal safeFetch helper: timeout, retries, JSON parse guard

// Prefer a global fetch (jest mock) when available so tests that set global.mockFetch
// or global.fetch will be effective. Otherwise fall back to imported node-fetch.
const defaultFetch = typeof global.fetch !== 'undefined' ? global.fetch : _nodeFetch.default;
const USER_AGENTS = ['Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36', 'Praevisio/1.0 (+https://praevisio.local)'];
async function safeFetch(url, opts = {}, {
  timeout = 8000,
  retries = 2
} = {}) {
  for (let attempt = 0; attempt <= retries; attempt++) {
    const controller = new AbortController();
    const id = setTimeout(() => controller.abort(), timeout);
    try {
      const headers = {
        ...(opts.headers || {}),
        'Accept': 'application/json, text/plain, */*',
        'User-Agent': USER_AGENTS[attempt % USER_AGENTS.length]
      };
      const fetchImpl = typeof defaultFetch === 'function' ? defaultFetch : _nodeFetch.default;
      const res = await fetchImpl(url, {
        ...opts,
        headers,
        signal: controller.signal
      });
      clearTimeout(id);
      if (!res.ok) {
        // Try to safely read body/text for error reporting. Some test mocks may not
        // implement res.text(), so guard against that.
        let errText = '';
        if (res && typeof res.text === 'function') {
          errText = await res.text().catch(() => '');
        } else if (res && typeof res.json === 'function') {
          try {
            const j = await res.json();
            errText = typeof j === 'string' ? j : JSON.stringify(j);
          } catch (_e) {
            errText = '';
          }
        }
        // Log raw error response for debugging
        try {
          const logPath = _path.default.resolve(process.cwd(), 'tmp', 'integration_errors.log');
          _fs.default.mkdirSync(_path.default.dirname(logPath), {
            recursive: true
          });
          const entry = `[${new Date().toISOString()}] HTTP ${res.status} GET ${url} \n${errText.slice(0, 200)}\n\n`;
          _fs.default.appendFileSync(logPath, entry);
        } catch (e) {
          // ignore logging errors
        }
        throw new Error(`HTTP ${res.status}: ${errText}`);
      }
      // Detect content-type in a defensive way: test mocks may supply headers as a
      // simple object without a .get() method. Prefer headers.get if available.
      let ct = '';
      try {
        if (res && res.headers) {
          if (typeof res.headers.get === 'function') {
            ct = res.headers.get('content-type') || '';
          } else if (res.headers['content-type']) {
            ct = res.headers['content-type'];
          }
        }
      } catch (e) {
        ct = '';
      }

      // Some mocks simply provide a json() method but no headers â€” assume JSON
      if (!ct && res && typeof res.json === 'function') {
        ct = 'application/json';
      }
      if (ct && ct.toLowerCase().includes('application/json')) {
        try {
          return await (typeof res.json === 'function' ? res.json() : Promise.resolve(null));
        } catch (parseErr) {
          // Log invalid JSON parse for debugging
          try {
            const logPath = _path.default.resolve(process.cwd(), 'tmp', 'integration_errors.log');
            _fs.default.mkdirSync(_path.default.dirname(logPath), {
              recursive: true
            });
            const entry = `[${new Date().toISOString()}] Invalid JSON GET ${url} \nparseError: ${parseErr && parseErr.message ? parseErr.message : String(parseErr)}\n\n`;
            _fs.default.appendFileSync(logPath, entry);
          } catch (e) {}
          throw new Error(`Invalid JSON response: ${parseErr && parseErr.message ? parseErr.message : String(parseErr)}`);
        }
      }

      // If we received a non-JSON body (likely HTML blocking page), try to read text()
      let bodyText = '';
      if (res && typeof res.text === 'function') {
        bodyText = await res.text().catch(() => '');
      } else if (res && typeof res.json === 'function') {
        try {
          const j = await res.json();
          bodyText = typeof j === 'string' ? j : JSON.stringify(j);
        } catch (_e) {
          bodyText = '';
        }
      }
      // Log non-JSON body for debugging (first 2000 chars)
      try {
        const logPath = _path.default.resolve(process.cwd(), 'tmp', 'integration_errors.log');
        _fs.default.mkdirSync(_path.default.dirname(logPath), {
          recursive: true
        });
        const entry = `[${new Date().toISOString()}] Non-JSON GET ${url} \ncontent-type: ${ct} \nbody: ${bodyText.slice(0, 2000)}\n\n`;
        _fs.default.appendFileSync(logPath, entry);
      } catch (e) {}
      throw new Error(`Non-JSON response (content-type: ${ct}): ${bodyText.slice(0, 200)}`);
    } catch (err) {
      clearTimeout(id);
      if (attempt === retries) throw err;
      // exponential-ish backoff with jitter
      const delay = 300 + attempt * 500 + Math.floor(Math.random() * 200);
      await new Promise(r => setTimeout(r, delay));
    }
  }
}
var _default = exports.default = safeFetch;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfbm9kZUZldGNoIiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsInJlcXVpcmUiLCJfZnMiLCJfcGF0aCIsImUiLCJfX2VzTW9kdWxlIiwiZGVmYXVsdCIsImRlZmF1bHRGZXRjaCIsImdsb2JhbCIsImZldGNoIiwiVVNFUl9BR0VOVFMiLCJzYWZlRmV0Y2giLCJ1cmwiLCJvcHRzIiwidGltZW91dCIsInJldHJpZXMiLCJhdHRlbXB0IiwiY29udHJvbGxlciIsIkFib3J0Q29udHJvbGxlciIsImlkIiwic2V0VGltZW91dCIsImFib3J0IiwiaGVhZGVycyIsImxlbmd0aCIsImZldGNoSW1wbCIsInJlcyIsInNpZ25hbCIsImNsZWFyVGltZW91dCIsIm9rIiwiZXJyVGV4dCIsInRleHQiLCJjYXRjaCIsImpzb24iLCJqIiwiSlNPTiIsInN0cmluZ2lmeSIsIl9lIiwibG9nUGF0aCIsInBhdGgiLCJyZXNvbHZlIiwicHJvY2VzcyIsImN3ZCIsImZzIiwibWtkaXJTeW5jIiwiZGlybmFtZSIsInJlY3Vyc2l2ZSIsImVudHJ5IiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwic3RhdHVzIiwic2xpY2UiLCJhcHBlbmRGaWxlU3luYyIsIkVycm9yIiwiY3QiLCJnZXQiLCJ0b0xvd2VyQ2FzZSIsImluY2x1ZGVzIiwiUHJvbWlzZSIsInBhcnNlRXJyIiwibWVzc2FnZSIsIlN0cmluZyIsImJvZHlUZXh0IiwiZXJyIiwiZGVsYXkiLCJNYXRoIiwiZmxvb3IiLCJyYW5kb20iLCJyIiwiX2RlZmF1bHQiLCJleHBvcnRzIl0sInNvdXJjZXMiOlsic2FmZUZldGNoLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIE1pbmltYWwgc2FmZUZldGNoIGhlbHBlcjogdGltZW91dCwgcmV0cmllcywgSlNPTiBwYXJzZSBndWFyZFxuaW1wb3J0IGZldGNoIGZyb20gJ25vZGUtZmV0Y2gnO1xuLy8gUHJlZmVyIGEgZ2xvYmFsIGZldGNoIChqZXN0IG1vY2spIHdoZW4gYXZhaWxhYmxlIHNvIHRlc3RzIHRoYXQgc2V0IGdsb2JhbC5tb2NrRmV0Y2hcbi8vIG9yIGdsb2JhbC5mZXRjaCB3aWxsIGJlIGVmZmVjdGl2ZS4gT3RoZXJ3aXNlIGZhbGwgYmFjayB0byBpbXBvcnRlZCBub2RlLWZldGNoLlxuY29uc3QgZGVmYXVsdEZldGNoID0gdHlwZW9mIGdsb2JhbC5mZXRjaCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwuZmV0Y2ggOiBmZXRjaDtcbmltcG9ydCBmcyBmcm9tICdmcyc7XG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcblxuY29uc3QgVVNFUl9BR0VOVFMgPSBbXG4gICdNb3ppbGxhLzUuMCAoWDExOyBMaW51eCB4ODZfNjQpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIENocm9tZS8xMjAuMC4wLjAgU2FmYXJpLzUzNy4zNicsXG4gICdQcmFldmlzaW8vMS4wICgraHR0cHM6Ly9wcmFldmlzaW8ubG9jYWwpJ1xuXTtcblxuYXN5bmMgZnVuY3Rpb24gc2FmZUZldGNoKHVybCwgb3B0cyA9IHt9LCB7IHRpbWVvdXQgPSA4MDAwLCByZXRyaWVzID0gMiB9ID0ge30pIHtcbiAgZm9yIChsZXQgYXR0ZW1wdCA9IDA7IGF0dGVtcHQgPD0gcmV0cmllczsgYXR0ZW1wdCsrKSB7XG4gICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCBpZCA9IHNldFRpbWVvdXQoKCkgPT4gY29udHJvbGxlci5hYm9ydCgpLCB0aW1lb3V0KTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgaGVhZGVycyA9IHsgLi4uKG9wdHMuaGVhZGVycyB8fCB7fSksICdBY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbiwgdGV4dC9wbGFpbiwgKi8qJywgJ1VzZXItQWdlbnQnOiBVU0VSX0FHRU5UU1thdHRlbXB0ICUgVVNFUl9BR0VOVFMubGVuZ3RoXSB9O1xuICAgICAgY29uc3QgZmV0Y2hJbXBsID0gdHlwZW9mIGRlZmF1bHRGZXRjaCA9PT0gJ2Z1bmN0aW9uJyA/IGRlZmF1bHRGZXRjaCA6IGZldGNoO1xuICAgICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2hJbXBsKHVybCwgeyAuLi5vcHRzLCBoZWFkZXJzLCBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsIH0pO1xuICAgICAgY2xlYXJUaW1lb3V0KGlkKTtcbiAgICAgIGlmICghcmVzLm9rKSB7XG4gICAgICAgICAgLy8gVHJ5IHRvIHNhZmVseSByZWFkIGJvZHkvdGV4dCBmb3IgZXJyb3IgcmVwb3J0aW5nLiBTb21lIHRlc3QgbW9ja3MgbWF5IG5vdFxuICAgICAgICAgIC8vIGltcGxlbWVudCByZXMudGV4dCgpLCBzbyBndWFyZCBhZ2FpbnN0IHRoYXQuXG4gICAgICAgICAgbGV0IGVyclRleHQgPSAnJztcbiAgICAgICAgICBpZiAocmVzICYmIHR5cGVvZiByZXMudGV4dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgZXJyVGV4dCA9IGF3YWl0IHJlcy50ZXh0KCkuY2F0Y2goKCkgPT4gJycpO1xuICAgICAgICAgIH0gZWxzZSBpZiAocmVzICYmIHR5cGVvZiByZXMuanNvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3QgaiA9IGF3YWl0IHJlcy5qc29uKCk7XG4gICAgICAgICAgICAgIGVyclRleHQgPSB0eXBlb2YgaiA9PT0gJ3N0cmluZycgPyBqIDogSlNPTi5zdHJpbmdpZnkoaik7XG4gICAgICAgICAgICB9IGNhdGNoIChfZSkge1xuICAgICAgICAgICAgICBlcnJUZXh0ID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIExvZyByYXcgZXJyb3IgcmVzcG9uc2UgZm9yIGRlYnVnZ2luZ1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBsb2dQYXRoID0gcGF0aC5yZXNvbHZlKHByb2Nlc3MuY3dkKCksICd0bXAnLCAnaW50ZWdyYXRpb25fZXJyb3JzLmxvZycpO1xuICAgICAgICAgICAgZnMubWtkaXJTeW5jKHBhdGguZGlybmFtZShsb2dQYXRoKSwgeyByZWN1cnNpdmU6IHRydWUgfSk7XG4gICAgICAgICAgICBjb25zdCBlbnRyeSA9IGBbJHtuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCl9XSBIVFRQICR7cmVzLnN0YXR1c30gR0VUICR7dXJsfSBcXG4ke2VyclRleHQuc2xpY2UoMCwyMDApfVxcblxcbmA7XG4gICAgICAgICAgICBmcy5hcHBlbmRGaWxlU3luYyhsb2dQYXRoLCBlbnRyeSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gaWdub3JlIGxvZ2dpbmcgZXJyb3JzXG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCAke3Jlcy5zdGF0dXN9OiAke2VyclRleHR9YCk7XG4gICAgICB9XG4gICAgICAgIC8vIERldGVjdCBjb250ZW50LXR5cGUgaW4gYSBkZWZlbnNpdmUgd2F5OiB0ZXN0IG1vY2tzIG1heSBzdXBwbHkgaGVhZGVycyBhcyBhXG4gICAgICAgIC8vIHNpbXBsZSBvYmplY3Qgd2l0aG91dCBhIC5nZXQoKSBtZXRob2QuIFByZWZlciBoZWFkZXJzLmdldCBpZiBhdmFpbGFibGUuXG4gICAgICAgIGxldCBjdCA9ICcnO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChyZXMgJiYgcmVzLmhlYWRlcnMpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzLmhlYWRlcnMuZ2V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIGN0ID0gcmVzLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKSB8fCAnJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzLmhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddKSB7XG4gICAgICAgICAgICAgIGN0ID0gcmVzLmhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGN0ID0gJyc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTb21lIG1vY2tzIHNpbXBseSBwcm92aWRlIGEganNvbigpIG1ldGhvZCBidXQgbm8gaGVhZGVycyDigJQgYXNzdW1lIEpTT05cbiAgICAgICAgaWYgKCFjdCAmJiByZXMgJiYgdHlwZW9mIHJlcy5qc29uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgY3QgPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3QgJiYgY3QudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygnYXBwbGljYXRpb24vanNvbicpKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCAodHlwZW9mIHJlcy5qc29uID09PSAnZnVuY3Rpb24nID8gcmVzLmpzb24oKSA6IFByb21pc2UucmVzb2x2ZShudWxsKSk7XG4gICAgICAgICAgfSBjYXRjaCAocGFyc2VFcnIpIHtcbiAgICAgICAgICAgIC8vIExvZyBpbnZhbGlkIEpTT04gcGFyc2UgZm9yIGRlYnVnZ2luZ1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3QgbG9nUGF0aCA9IHBhdGgucmVzb2x2ZShwcm9jZXNzLmN3ZCgpLCAndG1wJywgJ2ludGVncmF0aW9uX2Vycm9ycy5sb2cnKTtcbiAgICAgICAgICAgICAgZnMubWtkaXJTeW5jKHBhdGguZGlybmFtZShsb2dQYXRoKSwgeyByZWN1cnNpdmU6IHRydWUgfSk7XG4gICAgICAgICAgICAgIGNvbnN0IGVudHJ5ID0gYFske25ldyBEYXRlKCkudG9JU09TdHJpbmcoKX1dIEludmFsaWQgSlNPTiBHRVQgJHt1cmx9IFxcbnBhcnNlRXJyb3I6ICR7cGFyc2VFcnIgJiYgcGFyc2VFcnIubWVzc2FnZSA/IHBhcnNlRXJyLm1lc3NhZ2UgOiBTdHJpbmcocGFyc2VFcnIpfVxcblxcbmA7XG4gICAgICAgICAgICAgIGZzLmFwcGVuZEZpbGVTeW5jKGxvZ1BhdGgsIGVudHJ5KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgSlNPTiByZXNwb25zZTogJHtwYXJzZUVyciAmJiBwYXJzZUVyci5tZXNzYWdlID8gcGFyc2VFcnIubWVzc2FnZSA6IFN0cmluZyhwYXJzZUVycil9YCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgd2UgcmVjZWl2ZWQgYSBub24tSlNPTiBib2R5IChsaWtlbHkgSFRNTCBibG9ja2luZyBwYWdlKSwgdHJ5IHRvIHJlYWQgdGV4dCgpXG4gICAgICAgIGxldCBib2R5VGV4dCA9ICcnO1xuICAgICAgICBpZiAocmVzICYmIHR5cGVvZiByZXMudGV4dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGJvZHlUZXh0ID0gYXdhaXQgcmVzLnRleHQoKS5jYXRjaCgoKSA9PiAnJyk7XG4gICAgICAgIH0gZWxzZSBpZiAocmVzICYmIHR5cGVvZiByZXMuanNvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBqID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICAgICAgICAgIGJvZHlUZXh0ID0gdHlwZW9mIGogPT09ICdzdHJpbmcnID8gaiA6IEpTT04uc3RyaW5naWZ5KGopO1xuICAgICAgICAgIH0gY2F0Y2ggKF9lKSB7XG4gICAgICAgICAgICBib2R5VGV4dCA9ICcnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBMb2cgbm9uLUpTT04gYm9keSBmb3IgZGVidWdnaW5nIChmaXJzdCAyMDAwIGNoYXJzKVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGxvZ1BhdGggPSBwYXRoLnJlc29sdmUocHJvY2Vzcy5jd2QoKSwgJ3RtcCcsICdpbnRlZ3JhdGlvbl9lcnJvcnMubG9nJyk7XG4gICAgICAgICAgZnMubWtkaXJTeW5jKHBhdGguZGlybmFtZShsb2dQYXRoKSwgeyByZWN1cnNpdmU6IHRydWUgfSk7XG4gICAgICAgICAgY29uc3QgZW50cnkgPSBgWyR7bmV3IERhdGUoKS50b0lTT1N0cmluZygpfV0gTm9uLUpTT04gR0VUICR7dXJsfSBcXG5jb250ZW50LXR5cGU6ICR7Y3R9IFxcbmJvZHk6ICR7Ym9keVRleHQuc2xpY2UoMCwyMDAwKX1cXG5cXG5gO1xuICAgICAgICAgIGZzLmFwcGVuZEZpbGVTeW5jKGxvZ1BhdGgsIGVudHJ5KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBOb24tSlNPTiByZXNwb25zZSAoY29udGVudC10eXBlOiAke2N0fSk6ICR7Ym9keVRleHQuc2xpY2UoMCwgMjAwKX1gKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNsZWFyVGltZW91dChpZCk7XG4gICAgICBpZiAoYXR0ZW1wdCA9PT0gcmV0cmllcykgdGhyb3cgZXJyO1xuICAgICAgLy8gZXhwb25lbnRpYWwtaXNoIGJhY2tvZmYgd2l0aCBqaXR0ZXJcbiAgICAgIGNvbnN0IGRlbGF5ID0gMzAwICsgYXR0ZW1wdCAqIDUwMCArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDIwMCk7XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyID0+IHNldFRpbWVvdXQociwgZGVsYXkpKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgc2FmZUZldGNoO1xuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFDQSxJQUFBQSxVQUFBLEdBQUFDLHNCQUFBLENBQUFDLE9BQUE7QUFJQSxJQUFBQyxHQUFBLEdBQUFGLHNCQUFBLENBQUFDLE9BQUE7QUFDQSxJQUFBRSxLQUFBLEdBQUFILHNCQUFBLENBQUFDLE9BQUE7QUFBd0IsU0FBQUQsdUJBQUFJLENBQUEsV0FBQUEsQ0FBQSxJQUFBQSxDQUFBLENBQUFDLFVBQUEsR0FBQUQsQ0FBQSxLQUFBRSxPQUFBLEVBQUFGLENBQUE7QUFOeEI7O0FBRUE7QUFDQTtBQUNBLE1BQU1HLFlBQVks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