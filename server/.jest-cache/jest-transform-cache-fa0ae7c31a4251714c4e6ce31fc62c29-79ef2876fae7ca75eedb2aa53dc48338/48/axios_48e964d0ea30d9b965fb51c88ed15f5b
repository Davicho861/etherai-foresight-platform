ebd96a228f750e920f663de046418188
/*! Axios v1.12.2 Copyright (c) 2025 Matt Zabriskie and contributors */
'use strict';

const FormData$1 = require('form-data');
const crypto = require('crypto');
const url = require('url');
const proxyFromEnv = require('proxy-from-env');
const http = require('http');
const https = require('https');
const util = require('util');
const followRedirects = require('follow-redirects');
const zlib = require('zlib');
const stream = require('stream');
const events = require('events');
function _interopDefaultLegacy(e) {
  return e && typeof e === 'object' && 'default' in e ? e : {
    'default': e
  };
}
const FormData__default = /*#__PURE__*/_interopDefaultLegacy(FormData$1);
const crypto__default = /*#__PURE__*/_interopDefaultLegacy(crypto);
const url__default = /*#__PURE__*/_interopDefaultLegacy(url);
const proxyFromEnv__default = /*#__PURE__*/_interopDefaultLegacy(proxyFromEnv);
const http__default = /*#__PURE__*/_interopDefaultLegacy(http);
const https__default = /*#__PURE__*/_interopDefaultLegacy(https);
const util__default = /*#__PURE__*/_interopDefaultLegacy(util);
const followRedirects__default = /*#__PURE__*/_interopDefaultLegacy(followRedirects);
const zlib__default = /*#__PURE__*/_interopDefaultLegacy(zlib);
const stream__default = /*#__PURE__*/_interopDefaultLegacy(stream);
function bind(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}

// utils is a library of generic helper functions non-specific to axios

const {
  toString
} = Object.prototype;
const {
  getPrototypeOf
} = Object;
const {
  iterator,
  toStringTag
} = Symbol;
const kindOf = (cache => thing => {
  const str = toString.call(thing);
  return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(Object.create(null));
const kindOfTest = type => {
  type = type.toLowerCase();
  return thing => kindOf(thing) === type;
};
const typeOfTest = type => thing => typeof thing === type;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 *
 * @returns {boolean} True if value is an Array, otherwise false
 */
const {
  isArray
} = Array;

/**
 * Determine if a value is undefined
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if the value is undefined, otherwise false
 */
const isUndefined = typeOfTest('undefined');

/**
 * Determine if a value is a Buffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction$1(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
const isArrayBuffer = kindOfTest('ArrayBuffer');

/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a String, otherwise false
 */
const isString = typeOfTest('string');

/**
 * Determine if a value is a Function
 *
 * @param {*} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
const isFunction$1 = typeOfTest('function');

/**
 * Determine if a value is a Number
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Number, otherwise false
 */
const isNumber = typeOfTest('number');

/**
 * Determine if a value is an Object
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an Object, otherwise false
 */
const isObject = thing => thing !== null && typeof thing === 'object';

/**
 * Determine if a value is a Boolean
 *
 * @param {*} thing The value to test
 * @returns {boolean} True if value is a Boolean, otherwise false
 */
const isBoolean = thing => thing === true || thing === false;

/**
 * Determine if a value is a plain Object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a plain Object, otherwise false
 */
const isPlainObject = val => {
  if (kindOf(val) !== 'object') {
    return false;
  }
  const prototype = getPrototypeOf(val);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(toStringTag in val) && !(iterator in val);
};

/**
 * Determine if a value is an empty object (safely handles Buffers)
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is an empty object, otherwise false
 */
const isEmptyObject = val => {
  // Early return for non-objects or Buffers to prevent RangeError
  if (!isObject(val) || isBuffer(val)) {
    return false;
  }
  try {
    return Object.keys(val).length === 0 && Object.getPrototypeOf(val) === Object.prototype;
  } catch (e) {
    // Fallback for any other objects that might cause RangeError with Object.keys()
    return false;
  }
};

/**
 * Determine if a value is a Date
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Date, otherwise false
 */
const isDate = kindOfTest('Date');

/**
 * Determine if a value is a File
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */
const isFile = kindOfTest('File');

/**
 * Determine if a value is a Blob
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Blob, otherwise false
 */
const isBlob = kindOfTest('Blob');

/**
 * Determine if a value is a FileList
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */
const isFileList = kindOfTest('FileList');

/**
 * Determine if a value is a Stream
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Stream, otherwise false
 */
const isStream = val => isObject(val) && isFunction$1(val.pipe);

/**
 * Determine if a value is a FormData
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an FormData, otherwise false
 */
const isFormData = thing => {
  let kind;
  return thing && (typeof FormData === 'function' && thing instanceof FormData || isFunction$1(thing.append) && ((kind = kindOf(thing)) === 'formdata' ||
  // detect form-data instance
  kind === 'object' && isFunction$1(thing.toString) && thing.toString() === '[object FormData]'));
};

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
const isURLSearchParams = kindOfTest('URLSearchParams');
const [isReadableStream, isRequest, isResponse, isHeaders] = ['ReadableStream', 'Request', 'Response', 'Headers'].map(kindOfTest);

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 *
 * @returns {String} The String freed of excess whitespace
 */
const trim = str => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 *
 * @param {Boolean} [allOwnKeys = false]
 * @returns {any}
 */
function forEach(obj, fn, {
  allOwnKeys = false
} = {}) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }
  let i;
  let l;

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }
  if (isArray(obj)) {
    // Iterate over array values
    for (i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Buffer check
    if (isBuffer(obj)) {
      return;
    }

    // Iterate over object keys
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;
    for (i = 0; i < len; i++) {
      key = keys[i];
      fn.call(null, obj[key], key, obj);
    }
  }
}
function findKey(obj, key) {
  if (isBuffer(obj)) {
    return null;
  }
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i = keys.length;
  let _key;
  while (i-- > 0) {
    _key = keys[i];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
const _global = (() => {
  /*eslint no-undef:0*/
  if (typeof globalThis !== "undefined") return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== 'undefined' ? window : global;
})();
const isContextDefined = context => !isUndefined(context) && context !== _global;

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 *
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */
) {
  const {
    caseless,
    skipUndefined
  } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else if (!skipUndefined || !isUndefined(val)) {
      result[targetKey] = val;
    }
  };
  for (let i = 0, l = arguments.length; i < l; i++) {
    arguments[i] && forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 *
 * @param {Boolean} [allOwnKeys]
 * @returns {Object} The resulting value of object a
 */
const extend = (a, b, thisArg, {
  allOwnKeys
} = {}) => {
  forEach(b, (val, key) => {
    if (thisArg && isFunction$1(val)) {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  }, {
    allOwnKeys
  });
  return a;
};

/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 *
 * @returns {string} content value without BOM
 */
const stripBOM = content => {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }
  return content;
};

/**
 * Inherit the prototype methods from one constructor into another
 * @param {function} constructor
 * @param {function} superConstructor
 * @param {object} [props]
 * @param {object} [descriptors]
 *
 * @returns {void}
 */
const inherits = (constructor, superConstructor, props, descriptors) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, 'super', {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};

/**
 * Resolve object with deep prototype chain to a flat object
 * @param {Object} sourceObj source object
 * @param {Object} [destObj]
 * @param {Function|Boolean} [filter]
 * @param {Function} [propFilter]
 *
 * @returns {Object}
 */
const toFlatObject = (sourceObj, destObj, filter, propFilter) => {
  let props;
  let i;
  let prop;
  const merged = {};
  destObj = destObj || {};
  // eslint-disable-next-line no-eq-null,eqeqeq
  if (sourceObj == null) return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};

/**
 * Determines whether a string ends with the characters of a specified string
 *
 * @param {String} str
 * @param {String} searchString
 * @param {Number} [position= 0]
 *
 * @returns {boolean}
 */
const endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === undefined || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};

/**
 * Returns new array from array like object or null if failed
 *
 * @param {*} [thing]
 *
 * @returns {?Array}
 */
const toArray = thing => {
  if (!thing) return null;
  if (isArray(thing)) return thing;
  let i = thing.length;
  if (!isNumber(i)) return null;
  const arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
};

/**
 * Checking if the Uint8Array exists and if it does, it returns a function that checks if the
 * thing passed in is an instance of Uint8Array
 *
 * @param {TypedArray}
 *
 * @returns {Array}
 */
// eslint-disable-next-line func-names
const isTypedArray = (TypedArray => {
  // eslint-disable-next-line func-names
  return thing => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== 'undefined' && getPrototypeOf(Uint8Array));

/**
 * For each entry in the object, call the function with the key and value.
 *
 * @param {Object<any, any>} obj - The object to iterate over.
 * @param {Function} fn - The function to call for each entry.
 *
 * @returns {void}
 */
const forEachEntry = (obj, fn) => {
  const generator = obj && obj[iterator];
  const _iterator = generator.call(obj);
  let result;
  while ((result = _iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};

/**
 * It takes a regular expression and a string, and returns an array of all the matches
 *
 * @param {string} regExp - The regular expression to match against.
 * @param {string} str - The string to search.
 *
 * @returns {Array<boolean>}
 */
const matchAll = (regExp, str) => {
  let matches;
  const arr = [];
  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }
  return arr;
};

/* Checking if the kindOfTest function returns true when passed an HTMLFormElement. */
const isHTMLForm = kindOfTest('HTMLFormElement');
const toCamelCase = str => {
  return str.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function replacer(m, p1, p2) {
    return p1.toUpperCase() + p2;
  });
};

/* Creating a function that will check if an object has a property. */
const hasOwnProperty = (({
  hasOwnProperty
}) => (obj, prop) => hasOwnProperty.call(obj, prop))(Object.prototype);

/**
 * Determine if a value is a RegExp object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a RegExp object, otherwise false
 */
const isRegExp = kindOfTest('RegExp');
const reduceDescriptors = (obj, reducer) => {
  const descriptors = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors, (descriptor, name) => {
    let ret;
    if ((ret = reducer(descriptor, name, obj)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};

/**
 * Makes all methods read-only
 * @param {Object} obj
 */

const freezeMethods = obj => {
  reduceDescriptors(obj, (descriptor, name) => {
    // skip restricted props in strict mode
    if (isFunction$1(obj) && ['arguments', 'caller', 'callee'].indexOf(name) !== -1) {
      return false;
    }
    const value = obj[name];
    if (!isFunction$1(value)) return;
    descriptor.enumerable = false;
    if ('writable' in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error('Can not rewrite read-only method \'' + name + '\'');
      };
    }
  });
};
const toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};
  const define = arr => {
    arr.forEach(value => {
      obj[value] = true;
    });
  };
  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
  return obj;
};
const noop = () => {};
const toFiniteNumber = (value, defaultValue) => {
  return value != null && Number.isFinite(value = +value) ? value : defaultValue;
};

/**
 * If the thing is a FormData object, return true, otherwise return false.
 *
 * @param {unknown} thing - The thing to check.
 *
 * @returns {boolean}
 */
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction$1(thing.append) && thing[toStringTag] === 'FormData' && thing[iterator]);
}
const toJSONObject = obj => {
  const stack = new Array(10);
  const visit = (source, i) => {
    if (isObject(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }

      //Buffer check
      if (isBuffer(source)) {
        return source;
      }
      if (!('toJSON' in source)) {
        stack[i] = source;
        const target = isArray(source) ? [] : {};
        forEach(source, (value, key) => {
          const reducedValue = visit(value, i + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });
        stack[i] = undefined;
        return target;
      }
    }
    return source;
  };
  return visit(obj, 0);
};
const isAsyncFn = kindOfTest('AsyncFunction');
const isThenable = thing => thing && (isObject(thing) || isFunction$1(thing)) && isFunction$1(thing.then) && isFunction$1(thing.catch);

// original code
// https://github.com/DigitalBrainJS/AxiosPromise/blob/16deab13710ec09779922131f3fa5954320f83ab/lib/utils.js#L11-L34

const _setImmediate = ((setImmediateSupported, postMessageSupported) => {
  if (setImmediateSupported) {
    return setImmediate;
  }
  return postMessageSupported ? ((token, callbacks) => {
    _global.addEventListener("message", ({
      source,
      data
    }) => {
      if (source === _global && data === token) {
        callbacks.length && callbacks.shift()();
      }
    }, false);
    return cb => {
      callbacks.push(cb);
      _global.postMessage(token, "*");
    };
  })(`axios@${Math.random()}`, []) : cb => setTimeout(cb);
})(typeof setImmediate === 'function', isFunction$1(_global.postMessage));
const asap = typeof queueMicrotask !== 'undefined' ? queueMicrotask.bind(_global) : typeof process !== 'undefined' && process.nextTick || _setImmediate;

// *********************

const isIterable = thing => thing != null && isFunction$1(thing[iterator]);
const utils$1 = {
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject,
  isEmptyObject,
  isReadableStream,
  isRequest,
  isResponse,
  isHeaders,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction: isFunction$1,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable,
  setImmediate: _setImmediate,
  asap,
  isIterable
};

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [config] The config.
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 *
 * @returns {Error} The created error.
 */
function AxiosError(message, code, config, request, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = 'AxiosError';
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  if (response) {
    this.response = response;
    this.status = response.status ? response.status : null;
  }
}
utils$1.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils$1.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
const prototype$1 = AxiosError.prototype;
const descriptors = {};
['ERR_BAD_OPTION_VALUE', 'ERR_BAD_OPTION', 'ECONNABORTED', 'ETIMEDOUT', 'ERR_NETWORK', 'ERR_FR_TOO_MANY_REDIRECTS', 'ERR_DEPRECATED', 'ERR_BAD_RESPONSE', 'ERR_BAD_REQUEST', 'ERR_CANCELED', 'ERR_NOT_SUPPORT', 'ERR_INVALID_URL'
// eslint-disable-next-line func-names
].forEach(code => {
  descriptors[code] = {
    value: code
  };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype$1, 'isAxiosError', {
  value: true
});

// eslint-disable-next-line func-names
AxiosError.from = (error, code, config, request, response, customProps) => {
  const axiosError = Object.create(prototype$1);
  utils$1.toFlatObject(error, axiosError, function filter(obj) {
    return obj !== Error.prototype;
  }, prop => {
    return prop !== 'isAxiosError';
  });
  const msg = error && error.message ? error.message : 'Error';

  // Prefer explicit code; otherwise copy the low-level error's code (e.g. ECONNREFUSED)
  const errCode = code == null && error ? error.code : code;
  AxiosError.call(axiosError, msg, errCode, config, request, response);

  // Chain the original error on the standard field; non-enumerable to avoid JSON noise
  if (error && axiosError.cause == null) {
    Object.defineProperty(axiosError, 'cause', {
      value: error,
      configurable: true
    });
  }
  axiosError.name = error && error.name || 'Error';
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};

/**
 * Determines if the given thing is a array or js object.
 *
 * @param {string} thing - The object or array to be visited.
 *
 * @returns {boolean}
 */
function isVisitable(thing) {
  return utils$1.isPlainObject(thing) || utils$1.isArray(thing);
}

/**
 * It removes the brackets from the end of a string
 *
 * @param {string} key - The key of the parameter.
 *
 * @returns {string} the key without the brackets.
 */
function removeBrackets(key) {
  return utils$1.endsWith(key, '[]') ? key.slice(0, -2) : key;
}

/**
 * It takes a path, a key, and a boolean, and returns a string
 *
 * @param {string} path - The path to the current key.
 * @param {string} key - The key of the current object being iterated over.
 * @param {string} dots - If true, the key will be rendered with dots instead of brackets.
 *
 * @returns {string} The path to the current key.
 */
function renderKey(path, key, dots) {
  if (!path) return key;
  return path.concat(key).map(function each(token, i) {
    // eslint-disable-next-line no-param-reassign
    token = removeBrackets(token);
    return !dots && i ? '[' + token + ']' : token;
  }).join(dots ? '.' : '');
}

/**
 * If the array is an array and none of its elements are visitable, then it's a flat array.
 *
 * @param {Array<any>} arr - The array to check
 *
 * @returns {boolean}
 */
function isFlatArray(arr) {
  return utils$1.isArray(arr) && !arr.some(isVisitable);
}
const predicates = utils$1.toFlatObject(utils$1, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});

/**
 * Convert a data object to FormData
 *
 * @param {Object} obj
 * @param {?Object} [formData]
 * @param {?Object} [options]
 * @param {Function} [options.visitor]
 * @param {Boolean} [options.metaTokens = true]
 * @param {Boolean} [options.dots = false]
 * @param {?Boolean} [options.indexes = false]
 *
 * @returns {Object}
 **/

/**
 * It converts an object into a FormData object
 *
 * @param {Object<any, any>} obj - The object to convert to form data.
 * @param {string} formData - The FormData object to append to.
 * @param {Object<string, any>} options
 *
 * @returns
 */
function toFormData(obj, formData, options) {
  if (!utils$1.isObject(obj)) {
    throw new TypeError('target must be an object');
  }

  // eslint-disable-next-line no-param-reassign
  formData = formData || new (FormData__default["default"] || FormData)();

  // eslint-disable-next-line no-param-reassign
  options = utils$1.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    // eslint-disable-next-line no-eq-null,eqeqeq
    return !utils$1.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  // eslint-disable-next-line no-use-before-define
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== 'undefined' && Blob;
  const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);
  if (!utils$1.isFunction(visitor)) {
    throw new TypeError('visitor must be a function');
  }
  function convertValue(value) {
    if (value === null) return '';
    if (utils$1.isDate(value)) {
      return value.toISOString();
    }
    if (utils$1.isBoolean(value)) {
      return value.toString();
    }
    if (!useBlob && utils$1.isBlob(value)) {
      throw new AxiosError('Blob is not supported. Use a Buffer instead.');
    }
    if (utils$1.isArrayBuffer(value) || utils$1.isTypedArray(value)) {
      return useBlob && typeof Blob === 'function' ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }

  /**
   * Default visitor.
   *
   * @param {*} value
   * @param {String|Number} key
   * @param {Array<String|Number>} path
   * @this {FormData}
   *
   * @returns {boolean} return true to visit the each prop of the value recursively
   */
  function defaultVisitor(value, key, path) {
    let arr = value;
    if (value && !path && typeof value === 'object') {
      if (utils$1.endsWith(key, '{}')) {
        // eslint-disable-next-line no-param-reassign
        key = metaTokens ? key : key.slice(0, -2);
        // eslint-disable-next-line no-param-reassign
        value = JSON.stringify(value);
      } else if (utils$1.isArray(value) && isFlatArray(value) || (utils$1.isFileList(value) || utils$1.endsWith(key, '[]')) && (arr = utils$1.toArray(value))) {
        // eslint-disable-next-line no-param-reassign
        key = removeBrackets(key);
        arr.forEach(function each(el, index) {
          !(utils$1.isUndefined(el) || el === null) && formData.append(
          // eslint-disable-next-line no-nested-ternary
          indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + '[]', convertValue(el));
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path, key, dots), convertValue(value));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value, path) {
    if (utils$1.isUndefined(value)) return;
    if (stack.indexOf(value) !== -1) {
      throw Error('Circular reference detected in ' + path.join('.'));
    }
    stack.push(value);
    utils$1.forEach(value, function each(el, key) {
      const result = !(utils$1.isUndefined(el) || el === null) && visitor.call(formData, el, utils$1.isString(key) ? key.trim() : key, path, exposedHelpers);
      if (result === true) {
        build(el, path ? path.concat(key) : [key]);
      }
    });
    stack.pop();
  }
  if (!utils$1.isObject(obj)) {
    throw new TypeError('data must be an object');
  }
  build(obj);
  return formData;
}

/**
 * It encodes a string by replacing all characters that are not in the unreserved set with
 * their percent-encoded equivalents
 *
 * @param {string} str - The string to encode.
 *
 * @returns {string} The encoded string.
 */
function encode$1(str) {
  const charMap = {
    '!': '%21',
    "'": '%27',
    '(': '%28',
    ')': '%29',
    '~': '%7E',
    '%20': '+',
    '%00': '\x00'
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}

/**
 * It takes a params object and converts it to a FormData object
 *
 * @param {Object<string, any>} params - The parameters to be converted to a FormData object.
 * @param {Object<string, any>} options - The options object passed to the Axios constructor.
 *
 * @returns {void}
 */
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData(params, this, options);
}
const prototype = AxiosURLSearchParams.prototype;
prototype.append = function append(name, value) {
  this._pairs.push([name, value]);
};
prototype.toString = function toString(encoder) {
  const _encode = encoder ? function (value) {
    return encoder.call(this, value, encode$1);
  } : encode$1;
  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + '=' + _encode(pair[1]);
  }, '').join('&');
};

/**
 * It replaces all instances of the characters `:`, `$`, `,`, `+`, `[`, and `]` with their
 * URI encoded counterparts
 *
 * @param {string} val The value to be encoded.
 *
 * @returns {string} The encoded value.
 */
function encode(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%20/g, '+');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @param {?(object|Function)} options
 *
 * @returns {string} The formatted url
 */
function buildURL(url, params, options) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }
  const _encode = options && options.encode || encode;
  if (utils$1.isFunction(options)) {
    options = {
      serialize: options
    };
  }
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils$1.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }
  return url;
}
class InterceptorManager {
  constructor() {
    this.handlers = [];
  }

  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }

  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }

  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }

  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils$1.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  }
}
const InterceptorManager$1 = InterceptorManager;
const transitionalDefaults = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};
const URLSearchParams = url__default["default"].URLSearchParams;
const ALPHA = 'abcdefghijklmnopqrstuvwxyz';
const DIGIT = '0123456789';
const ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};
const generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
  let str = '';
  const {
    length
  } = alphabet;
  const randomValues = new Uint32Array(size);
  crypto__default["default"].randomFillSync(randomValues);
  for (let i = 0; i < size; i++) {
    str += alphabet[randomValues[i] % length];
  }
  return str;
};
const platform$1 = {
  isNode: true,
  classes: {
    URLSearchParams,
    FormData: FormData__default["default"],
    Blob: typeof Blob !== 'undefined' && Blob || null
  },
  ALPHABET,
  generateString,
  protocols: ['http', 'https', 'file', 'data']
};
const hasBrowserEnv = typeof window !== 'undefined' && typeof document !== 'undefined';
const _navigator = typeof navigator === 'object' && navigator || undefined;

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 *
 * @returns {boolean}
 */
const hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ['ReactNative', 'NativeScript', 'NS'].indexOf(_navigator.product) < 0);

/**
 * Determine if we're running in a standard browser webWorker environment
 *
 * Although the `isStandardBrowserEnv` method indicates that
 * `allows axios to run in a web worker`, the WebWorker will still be
 * filtered out due to its judgment standard
 * `typeof window !== 'undefined' && typeof document !== 'undefined'`.
 * This leads to a problem when axios post `FormData` in webWorker
 */
const hasStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== 'undefined' &&
  // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts === 'function';
})();
const origin = hasBrowserEnv && window.location.href || 'http://localhost';
const utils = /*#__PURE__*/Object.freeze({
  __proto__: null,
  hasBrowserEnv: hasBrowserEnv,
  hasStandardBrowserWebWorkerEnv: hasStandardBrowserWebWorkerEnv,
  hasStandardBrowserEnv: hasStandardBrowserEnv,
  navigator: _navigator,
  origin: origin
});
const platform = {
  ...utils,
  ...platform$1
};
function toURLEncodedForm(data, options) {
  return toFormData(data, new platform.classes.URLSearchParams(), {
    visitor: function (value, key, path, helpers) {
      if (platform.isNode && utils$1.isBuffer(value)) {
        this.append(key, value.toString('base64'));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    },
    ...options
  });
}

/**
 * It takes a string like `foo[x][y][z]` and returns an array like `['foo', 'x', 'y', 'z']
 *
 * @param {string} name - The name of the property to get.
 *
 * @returns An array of strings.
 */
function parsePropPath(name) {
  // foo[x][y][z]
  // foo.x.y.z
  // foo-x-y-z
  // foo x y z
  return utils$1.matchAll(/\w+|\[(\w*)]/g, name).map(match => {
    return match[0] === '[]' ? '' : match[1] || match[0];
  });
}

/**
 * Convert an array to an object.
 *
 * @param {Array<any>} arr - The array to convert to an object.
 *
 * @returns An object with the same keys and values as the array.
 */
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i;
  const len = keys.length;
  let key;
  for (i = 0; i < len; i++) {
    key = keys[i];
    obj[key] = arr[key];
  }
  return obj;
}

/**
 * It takes a FormData object and returns a JavaScript object
 *
 * @param {string} formData The FormData object to convert to JSON.
 *
 * @returns {Object<string, any> | null} The converted object.
 */
function formDataToJSON(formData) {
  function buildPath(path, value, target, index) {
    let name = path[index++];
    if (name === '__proto__') return true;
    const isNumericKey = Number.isFinite(+name);
    const isLast = index >= path.length;
    name = !name && utils$1.isArray(target) ? target.length : name;
    if (isLast) {
      if (utils$1.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }
      return !isNumericKey;
    }
    if (!target[name] || !utils$1.isObject(target[name])) {
      target[name] = [];
    }
    const result = buildPath(path, value, target[name], index);
    if (result && utils$1.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }
    return !isNumericKey;
  }
  if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {
    const obj = {};
    utils$1.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });
    return obj;
  }
  return null;
}

/**
 * It takes a string, tries to parse it, and if it fails, it returns the stringified version
 * of the input
 *
 * @param {any} rawValue - The value to be stringified.
 * @param {Function} parser - A function that parses a string into a JavaScript object.
 * @param {Function} encoder - A function that takes a value and returns a string.
 *
 * @returns {string} A stringified version of the rawValue.
 */
function stringifySafely(rawValue, parser, encoder) {
  if (utils$1.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils$1.trim(rawValue);
    } catch (e) {
      if (e.name !== 'SyntaxError') {
        throw e;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
const defaults = {
  transitional: transitionalDefaults,
  adapter: ['xhr', 'http', 'fetch'],
  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || '';
    const hasJSONContentType = contentType.indexOf('application/json') > -1;
    const isObjectPayload = utils$1.isObject(data);
    if (isObjectPayload && utils$1.isHTMLForm(data)) {
      data = new FormData(data);
    }
    const isFormData = utils$1.isFormData(data);
    if (isFormData) {
      return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
    }
    if (utils$1.isArrayBuffer(data) || utils$1.isBuffer(data) || utils$1.isStream(data) || utils$1.isFile(data) || utils$1.isBlob(data) || utils$1.isReadableStream(data)) {
      return data;
    }
    if (utils$1.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils$1.isURLSearchParams(data)) {
      headers.setContentType('application/x-www-form-urlencoded;charset=utf-8', false);
      return data.toString();
    }
    let isFileList;
    if (isObjectPayload) {
      if (contentType.indexOf('application/x-www-form-urlencoded') > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }
      if ((isFileList = utils$1.isFileList(data)) || contentType.indexOf('multipart/form-data') > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData(isFileList ? {
          'files[]': data
        } : data, _FormData && new _FormData(), this.formSerializer);
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType('application/json', false);
      return stringifySafely(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    const transitional = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
    const JSONRequested = this.responseType === 'json';
    if (utils$1.isResponse(data) || utils$1.isReadableStream(data)) {
      return data;
    }
    if (data && utils$1.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional && transitional.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data, this.parseReviver);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === 'SyntaxError') {
            throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }
    return data;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform.classes.FormData,
    Blob: platform.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      'Accept': 'application/json, text/plain, */*',
      'Content-Type': undefined
    }
  }
};
utils$1.forEach(['delete', 'get', 'head', 'post', 'put', 'patch'], method => {
  defaults.headers[method] = {};
});
const defaults$1 = defaults;

// RawAxiosHeaders whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
const ignoreDuplicateOf = utils$1.toObjectSet(['age', 'authorization', 'content-length', 'content-type', 'etag', 'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since', 'last-modified', 'location', 'max-forwards', 'proxy-authorization', 'referer', 'retry-after', 'user-agent']);

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} rawHeaders Headers needing to be parsed
 *
 * @returns {Object} Headers parsed into an object
 */
const parseHeaders = rawHeaders => {
  const parsed = {};
  let key;
  let val;
  let i;
  rawHeaders && rawHeaders.split('\n').forEach(function parser(line) {
    i = line.indexOf(':');
    key = line.substring(0, i).trim().toLowerCase();
    val = line.substring(i + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === 'set-cookie') {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
    }
  });
  return parsed;
};
const $internals = Symbol('internals');
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils$1.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
  const tokens = Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;
  while (match = tokensRE.exec(str)) {
    tokens[match[1]] = match[2];
  }
  return tokens;
}
const isValidHeaderName = str => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
  if (utils$1.isFunction(filter)) {
    return filter.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils$1.isString(value)) return;
  if (utils$1.isString(filter)) {
    return value.indexOf(filter) !== -1;
  }
  if (utils$1.isRegExp(filter)) {
    return filter.test(value);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
    return char.toUpperCase() + str;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils$1.toCamelCase(' ' + header);
  ['get', 'set', 'has'].forEach(methodName => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function (arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
class AxiosHeaders {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error('header name must be a non-empty string');
      }
      const key = utils$1.findKey(self, lHeader);
      if (!key || self[key] === undefined || _rewrite === true || _rewrite === undefined && self[key] !== false) {
        self[key || _header] = normalizeValue(_value);
      }
    }
    const setHeaders = (headers, _rewrite) => utils$1.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils$1.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils$1.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders(header), valueOrRewrite);
    } else if (utils$1.isObject(header) && utils$1.isIterable(header)) {
      let obj = {},
        dest,
        key;
      for (const entry of header) {
        if (!utils$1.isArray(entry)) {
          throw TypeError('Object iterator must return a key-value pair');
        }
        obj[key = entry[0]] = (dest = obj[key]) ? utils$1.isArray(dest) ? [...dest, entry[1]] : [dest, entry[1]] : entry[1];
      }
      setHeaders(obj, valueOrRewrite);
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils$1.findKey(this, header);
      if (key) {
        const value = this[key];
        if (!parser) {
          return value;
        }
        if (parser === true) {
          return parseTokens(value);
        }
        if (utils$1.isFunction(parser)) {
          return parser.call(this, value, key);
        }
        if (utils$1.isRegExp(parser)) {
          return parser.exec(value);
        }
        throw new TypeError('parser must be boolean|regexp|function');
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils$1.findKey(this, header);
      return !!(key && this[key] !== undefined && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils$1.findKey(self, _header);
        if (key && (!matcher || matchHeaderValue(self, self[key], key, matcher))) {
          delete self[key];
          deleted = true;
        }
      }
    }
    if (utils$1.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher) {
    const keys = Object.keys(this);
    let i = keys.length;
    let deleted = false;
    while (i--) {
      const key = keys[i];
      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format) {
    const self = this;
    const headers = {};
    utils$1.forEach(this, (value, header) => {
      const key = utils$1.findKey(headers, header);
      if (key) {
        self[key] = normalizeValue(value);
        delete self[header];
        return;
      }
      const normalized = format ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self[header];
      }
      self[normalized] = normalizeValue(value);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = Object.create(null);
    utils$1.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils$1.isArray(value) ? value.join(', ') : value);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ': ' + value).join('\n');
  }
  getSetCookie() {
    return this.get("set-cookie") || [];
  }
  get [Symbol.toStringTag]() {
    return 'AxiosHeaders';
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed = new this(first);
    targets.forEach(target => computed.set(target));
    return computed;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype, _header);
        accessors[lHeader] = true;
      }
    }
    utils$1.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
}
AxiosHeaders.accessor(['Content-Type', 'Content-Length', 'Accept', 'Accept-Encoding', 'User-Agent', 'Authorization']);

// reserved names hotfix
utils$1.reduceDescriptors(AxiosHeaders.prototype, ({
  value
}, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1); // map `set` => `Set`
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  };
});
utils$1.freezeMethods(AxiosHeaders);
const AxiosHeaders$1 = AxiosHeaders;

/**
 * Transform the data for a request or a response
 *
 * @param {Array|Function} fns A single function or Array of functions
 * @param {?Object} response The response object
 *
 * @returns {*} The resulting transformed data
 */
function transformData(fns, response) {
  const config = this || defaults$1;
  const context = response || config;
  const headers = AxiosHeaders$1.from(context.headers);
  let data = context.data;
  utils$1.forEach(fns, function transform(fn) {
    data = fn.call(config, data, headers.normalize(), response ? response.status : undefined);
  });
  headers.normalize();
  return data;
}
function isCancel(value) {
  return !!(value && value.__CANCEL__);
}

/**
 * A `CanceledError` is an object that is thrown when an operation is canceled.
 *
 * @param {string=} message The message.
 * @param {Object=} config The config.
 * @param {Object=} request The request.
 *
 * @returns {CanceledError} The created error.
 */
function CanceledError(message, config, request) {
  // eslint-disable-next-line no-eq-null,eqeqeq
  AxiosError.call(this, message == null ? 'canceled' : message, AxiosError.ERR_CANCELED, config, request);
  this.name = 'CanceledError';
}
utils$1.inherits(CanceledError, AxiosError, {
  __CANCEL__: true
});

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 *
 * @returns {object} The response.
 */
function settle(resolve, reject, response) {
  const validateStatus = response.config.validateStatus;
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError('Request failed with status code ' + response.status, [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4], response.config, response.request, response));
  }
}

/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 *
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}

/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 *
 * @returns {string} The combined URL
 */
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/?\/$/, '') + '/' + relativeURL.replace(/^\/+/, '') : baseURL;
}

/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 *
 * @returns {string} The combined full path
 */
function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
  let isRelativeUrl = !isAbsoluteURL(requestedURL);
  if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}
const VERSION = "1.12.2";
function parseProtocol(url) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || '';
}
const DATA_URL_PATTERN = /^(?:([^;]+);)?(?:[^;]+;)?(base64|),([\s\S]*)$/;

/**
 * Parse data uri to a Buffer or Blob
 *
 * @param {String} uri
 * @param {?Boolean} asBlob
 * @param {?Object} options
 * @param {?Function} options.Blob
 *
 * @returns {Buffer|Blob}
 */
function fromDataURI(uri, asBlob, options) {
  const _Blob = options && options.Blob || platform.classes.Blob;
  const protocol = parseProtocol(uri);
  if (asBlob === undefined && _Blob) {
    asBlob = true;
  }
  if (protocol === 'data') {
    uri = protocol.length ? uri.slice(protocol.length + 1) : uri;
    const match = DATA_URL_PATTERN.exec(uri);
    if (!match) {
      throw new AxiosError('Invalid URL', AxiosError.ERR_INVALID_URL);
    }
    const mime = match[1];
    const isBase64 = match[2];
    const body = match[3];
    const buffer = Buffer.from(decodeURIComponent(body), isBase64 ? 'base64' : 'utf8');
    if (asBlob) {
      if (!_Blob) {
        throw new AxiosError('Blob is not supported', AxiosError.ERR_NOT_SUPPORT);
      }
      return new _Blob([buffer], {
        type: mime
      });
    }
    return buffer;
  }
  throw new AxiosError('Unsupported protocol ' + protocol, AxiosError.ERR_NOT_SUPPORT);
}
const kInternals = Symbol('internals');
class AxiosTransformStream extends stream__default["default"].Transform {
  constructor(options) {
    options = utils$1.toFlatObject(options, {
      maxRate: 0,
      chunkSize: 64 * 1024,
      minChunkSize: 100,
      timeWindow: 500,
      ticksRate: 2,
      samplesCount: 15
    }, null, (prop, source) => {
      return !utils$1.isUndefined(source[prop]);
    });
    super({
      readableHighWaterMark: options.chunkSize
    });
    const internals = this[kInternals] = {
      timeWindow: options.timeWindow,
      chunkSize: options.chunkSize,
      maxRate: options.maxRate,
      minChunkSize: options.minChunkSize,
      bytesSeen: 0,
      isCaptured: false,
      notifiedBytesLoaded: 0,
      ts: Date.now(),
      bytes: 0,
      onReadCallback: null
    };
    this.on('newListener', event => {
      if (event === 'progress') {
        if (!internals.isCaptured) {
          internals.isCaptured = true;
        }
      }
    });
  }
  _read(size) {
    const internals = this[kInternals];
    if (internals.onReadCallback) {
      internals.onReadCallback();
    }
    return super._read(size);
  }
  _transform(chunk, encoding, callback) {
    const internals = this[kInternals];
    const maxRate = internals.maxRate;
    const readableHighWaterMark = this.readableHighWaterMark;
    const timeWindow = internals.timeWindow;
    const divider = 1000 / timeWindow;
    const bytesThreshold = maxRate / divider;
    const minChunkSize = internals.minChunkSize !== false ? Math.max(internals.minChunkSize, bytesThreshold * 0.01) : 0;
    const pushChunk = (_chunk, _callback) => {
      const bytes = Buffer.byteLength(_chunk);
      internals.bytesSeen += bytes;
      internals.bytes += bytes;
      internals.isCaptured && this.emit('progress', internals.bytesSeen);
      if (this.push(_chunk)) {
        process.nextTick(_callback);
      } else {
        internals.onReadCallback = () => {
          internals.onReadCallback = null;
          process.nextTick(_callback);
        };
      }
    };
    const transformChunk = (_chunk, _callback) => {
      const chunkSize = Buffer.byteLength(_chunk);
      let chunkRemainder = null;
      let maxChunkSize = readableHighWaterMark;
      let bytesLeft;
      let passed = 0;
      if (maxRate) {
        const now = Date.now();
        if (!internals.ts || (passed = now - internals.ts) >= timeWindow) {
          internals.ts = now;
          bytesLeft = bytesThreshold - internals.bytes;
          internals.bytes = bytesLeft < 0 ? -bytesLeft : 0;
          passed = 0;
        }
        bytesLeft = bytesThreshold - internals.bytes;
      }
      if (maxRate) {
        if (bytesLeft <= 0) {
          // next time window
          return setTimeout(() => {
            _callback(null, _chunk);
          }, timeWindow - passed);
        }
        if (bytesLeft < maxChunkSize) {
          maxChunkSize = bytesLeft;
        }
      }
      if (maxChunkSize && chunkSize > maxChunkSize && chunkSize - maxChunkSize > minChunkSize) {
        chunkRemainder = _chunk.subarray(maxChunkSize);
        _chunk = _chunk.subarray(0, maxChunkSize);
      }
      pushChunk(_chunk, chunkRemainder ? () => {
        process.nextTick(_callback, null, chunkRemainder);
      } : _callback);
    };
    transformChunk(chunk, function transformNextChunk(err, _chunk) {
      if (err) {
        return callback(err);
      }
      if (_chunk) {
        transformChunk(_chunk, transformNextChunk);
      } else {
        callback(null);
      }
    });
  }
}
const AxiosTransformStream$1 = AxiosTransformStream;
const {
  asyncIterator
} = Symbol;
const readBlob = async function* (blob) {
  if (blob.stream) {
    yield* blob.stream();
  } else if (blob.arrayBuffer) {
    yield await blob.arrayBuffer();
  } else if (blob[asyncIterator]) {
    yield* blob[asyncIterator]();
  } else {
    yield blob;
  }
};
const readBlob$1 = readBlob;
const BOUNDARY_ALPHABET = platform.ALPHABET.ALPHA_DIGIT + '-_';
const textEncoder = typeof TextEncoder === 'function' ? new TextEncoder() : new util__default["default"].TextEncoder();
const CRLF = '\r\n';
const CRLF_BYTES = textEncoder.encode(CRLF);
const CRLF_BYTES_COUNT = 2;
class FormDataPart {
  constructor(name, value) {
    const {
      escapeName
    } = this.constructor;
    const isStringValue = utils$1.isString(value);
    let headers = `Content-Disposition: form-data; name="${escapeName(name)}"${!isStringValue && value.name ? `; filename="${escapeName(value.name)}"` : ''}${CRLF}`;
    if (isStringValue) {
      value = textEncoder.encode(String(value).replace(/\r?\n|\r\n?/g, CRLF));
    } else {
      headers += `Content-Type: ${value.type || "application/octet-stream"}${CRLF}`;
    }
    this.headers = textEncoder.encode(headers + CRLF);
    this.contentLength = isStringValue ? value.byteLength : value.size;
    this.size = this.headers.byteLength + this.contentLength + CRLF_BYTES_COUNT;
    this.name = name;
    this.value = value;
  }
  async *encode() {
    yield this.headers;
    const {
      value
    } = this;
    if (utils$1.isTypedArray(value)) {
      yield value;
    } else {
      yield* readBlob$1(value);
    }
    yield CRLF_BYTES;
  }
  static escapeName(name) {
    return String(name).replace(/[\r\n"]/g, match => ({
      '\r': '%0D',
      '\n': '%0A',
      '"': '%22'
    })[match]);
  }
}
const formDataToStream = (form, headersHandler, options) => {
  const {
    tag = 'form-data-boundary',
    size = 25,
    boundary = tag + '-' + platform.generateString(size, BOUNDARY_ALPHABET)
  } = options || {};
  if (!utils$1.isFormData(form)) {
    throw TypeError('FormData instance required');
  }
  if (boundary.length < 1 || boundary.length > 70) {
    throw Error('boundary must be 10-70 characters long');
  }
  const boundaryBytes = textEncoder.encode('--' + boundary + CRLF);
  const footerBytes = textEncoder.encode('--' + boundary + '--' + CRLF);
  let contentLength = footerBytes.byteLength;
  const parts = Array.from(form.entries()).map(([name, value]) => {
    const part = new FormDataPart(name, value);
    contentLength += part.size;
    return part;
  });
  contentLength += boundaryBytes.byteLength * parts.length;
  contentLength = utils$1.toFiniteNumber(contentLength);
  const computedHeaders = {
    'Content-Type': `multipart/form-data; boundary=${boundary}`
  };
  if (Number.isFinite(contentLength)) {
    computedHeaders['Content-Length'] = contentLength;
  }
  headersHandler && headersHandler(computedHeaders);
  return stream.Readable.from(async function* () {
    for (const part of parts) {
      yield boundaryBytes;
      yield* part.encode();
    }
    yield footerBytes;
  }());
};
const formDataToStream$1 = formDataToStream;
class ZlibHeaderTransformStream extends stream__default["default"].Transform {
  __transform(chunk, encoding, callback) {
    this.push(chunk);
    callback();
  }
  _transform(chunk, encoding, callback) {
    if (chunk.length !== 0) {
      this._transform = this.__transform;

      // Add Default Compression headers if no zlib headers are present
      if (chunk[0] !== 120) {
        // Hex: 78
        const header = Buffer.alloc(2);
        header[0] = 120; // Hex: 78
        header[1] = 156; // Hex: 9C 
        this.push(header, encoding);
      }
    }
    this.__transform(chunk, encoding, callback);
  }
}
const ZlibHeaderTransformStream$1 = ZlibHeaderTransformStream;
const callbackify = (fn, reducer) => {
  return utils$1.isAsyncFn(fn) ? function (...args) {
    const cb = args.pop();
    fn.apply(this, args).then(value => {
      try {
        reducer ? cb(null, ...reducer(value)) : cb(null, value);
      } catch (err) {
        cb(err);
      }
    }, cb);
  } : fn;
};
const callbackify$1 = callbackify;

/**
 * Calculate data maxRate
 * @param {Number} [samplesCount= 10]
 * @param {Number} [min= 1000]
 * @returns {Function}
 */
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min = min !== undefined ? min : 1000;
  return function push(chunkLength) {
    const now = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now;
    }
    bytes[head] = chunkLength;
    timestamps[head] = now;
    let i = tail;
    let bytesCount = 0;
    while (i !== head) {
      bytesCount += bytes[i++];
      i = i % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now - firstSampleTS < min) {
      return;
    }
    const passed = startedAt && now - startedAt;
    return passed ? Math.round(bytesCount * 1000 / passed) : undefined;
  };
}

/**
 * Throttle decorator
 * @param {Function} fn
 * @param {Number} freq
 * @return {Function}
 */
function throttle(fn, freq) {
  let timestamp = 0;
  let threshold = 1000 / freq;
  let lastArgs;
  let timer;
  const invoke = (args, now = Date.now()) => {
    timestamp = now;
    lastArgs = null;
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
    fn(...args);
  };
  const throttled = (...args) => {
    const now = Date.now();
    const passed = now - timestamp;
    if (passed >= threshold) {
      invoke(args, now);
    } else {
      lastArgs = args;
      if (!timer) {
        timer = setTimeout(() => {
          timer = null;
          invoke(lastArgs);
        }, threshold - passed);
      }
    }
  };
  const flush = () => lastArgs && invoke(lastArgs);
  return [throttled, flush];
}
const progressEventReducer = (listener, isDownloadStream, freq = 3) => {
  let bytesNotified = 0;
  const _speedometer = speedometer(50, 250);
  return throttle(e => {
    const loaded = e.loaded;
    const total = e.lengthComputable ? e.total : undefined;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : undefined,
      bytes: progressBytes,
      rate: rate ? rate : undefined,
      estimated: rate && total && inRange ? (total - loaded) / rate : undefined,
      event: e,
      lengthComputable: total != null,
      [isDownloadStream ? 'download' : 'upload']: true
    };
    listener(data);
  }, freq);
};
const progressEventDecorator = (total, throttled) => {
  const lengthComputable = total != null;
  return [loaded => throttled[0]({
    lengthComputable,
    total,
    loaded
  }), throttled[1]];
};
const asyncDecorator = fn => (...args) => utils$1.asap(() => fn(...args));

/**
 * Estimate decoded byte length of a data:// URL *without* allocating large buffers.
 * - For base64: compute exact decoded size using length and padding;
 *               handle %XX at the character-count level (no string allocation).
 * - For non-base64: use UTF-8 byteLength of the encoded body as a safe upper bound.
 *
 * @param {string} url
 * @returns {number}
 */
function estimateDataURLDecodedBytes(url) {
  if (!url || typeof url !== 'string') return 0;
  if (!url.startsWith('data:')) return 0;
  const comma = url.indexOf(',');
  if (comma < 0) return 0;
  const meta = url.slice(5, comma);
  const body = url.slice(comma + 1);
  const isBase64 = /;base64/i.test(meta);
  if (isBase64) {
    let effectiveLen = body.length;
    const len = body.length; // cache length

    for (let i = 0; i < len; i++) {
      if (body.charCodeAt(i) === 37 /* '%' */ && i + 2 < len) {
        const a = body.charCodeAt(i + 1);
        const b = body.charCodeAt(i + 2);
        const isHex = (a >= 48 && a <= 57 || a >= 65 && a <= 70 || a >= 97 && a <= 102) && (b >= 48 && b <= 57 || b >= 65 && b <= 70 || b >= 97 && b <= 102);
        if (isHex) {
          effectiveLen -= 2;
          i += 2;
        }
      }
    }
    let pad = 0;
    let idx = len - 1;
    const tailIsPct3D = j => j >= 2 && body.charCodeAt(j - 2) === 37 &&
    // '%'
    body.charCodeAt(j - 1) === 51 && (
    // '3'
    body.charCodeAt(j) === 68 || body.charCodeAt(j) === 100); // 'D' or 'd'

    if (idx >= 0) {
      if (body.charCodeAt(idx) === 61 /* '=' */) {
        pad++;
        idx--;
      } else if (tailIsPct3D(idx)) {
        pad++;
        idx -= 3;
      }
    }
    if (pad === 1 && idx >= 0) {
      if (body.charCodeAt(idx) === 61 /* '=' */) {
        pad++;
      } else if (tailIsPct3D(idx)) {
        pad++;
      }
    }
    const groups = Math.floor(effectiveLen / 4);
    const bytes = groups * 3 - (pad || 0);
    return bytes > 0 ? bytes : 0;
  }
  return Buffer.byteLength(body, 'utf8');
}
const zlibOptions = {
  flush: zlib__default["default"].constants.Z_SYNC_FLUSH,
  finishFlush: zlib__default["default"].constants.Z_SYNC_FLUSH
};
const brotliOptions = {
  flush: zlib__default["default"].constants.BROTLI_OPERATION_FLUSH,
  finishFlush: zlib__default["default"].constants.BROTLI_OPERATION_FLUSH
};
const isBrotliSupported = utils$1.isFunction(zlib__default["default"].createBrotliDecompress);
const {
  http: httpFollow,
  https: httpsFollow
} = followRedirects__default["default"];
const isHttps = /https:?/;
const supportedProtocols = platform.protocols.map(protocol => {
  return protocol + ':';
});
const flushOnFinish = (stream, [throttled, flush]) => {
  stream.on('end', flush).on('error', flush);
  return throttled;
};

/**
 * If the proxy or config beforeRedirects functions are defined, call them with the options
 * object.
 *
 * @param {Object<string, any>} options - The options object that was passed to the request.
 *
 * @returns {Object<string, any>}
 */
function dispatchBeforeRedirect(options, responseDetails) {
  if (options.beforeRedirects.proxy) {
    options.beforeRedirects.proxy(options);
  }
  if (options.beforeRedirects.config) {
    options.beforeRedirects.config(options, responseDetails);
  }
}

/**
 * If the proxy or config afterRedirects functions are defined, call them with the options
 *
 * @param {http.ClientRequestArgs} options
 * @param {AxiosProxyConfig} configProxy configuration from Axios options object
 * @param {string} location
 *
 * @returns {http.ClientRequestArgs}
 */
function setProxy(options, configProxy, location) {
  let proxy = configProxy;
  if (!proxy && proxy !== false) {
    const proxyUrl = proxyFromEnv__default["default"].getProxyForUrl(location);
    if (proxyUrl) {
      proxy = new URL(proxyUrl);
    }
  }
  if (proxy) {
    // Basic proxy authorization
    if (proxy.username) {
      proxy.auth = (proxy.username || '') + ':' + (proxy.password || '');
    }
    if (proxy.auth) {
      // Support proxy auth object form
      if (proxy.auth.username || proxy.auth.password) {
        proxy.auth = (proxy.auth.username || '') + ':' + (proxy.auth.password || '');
      }
      const base64 = Buffer.from(proxy.auth, 'utf8').toString('base64');
      options.headers['Proxy-Authorization'] = 'Basic ' + base64;
    }
    options.headers.host = options.hostname + (options.port ? ':' + options.port : '');
    const proxyHost = proxy.hostname || proxy.host;
    options.hostname = proxyHost;
    // Replace 'host' since options is not a URL object
    options.host = proxyHost;
    options.port = proxy.port;
    options.path = location;
    if (proxy.protocol) {
      options.protocol = proxy.protocol.includes(':') ? proxy.protocol : `${proxy.protocol}:`;
    }
  }
  options.beforeRedirects.proxy = function beforeRedirect(redirectOptions) {
    // Configure proxy for redirected request, passing the original config proxy to apply
    // the exact same logic as if the redirected request was performed by axios directly.
    setProxy(redirectOptions, configProxy, redirectOptions.href);
  };
}
const isHttpAdapterSupported = typeof process !== 'undefined' && utils$1.kindOf(process) === 'process';

// temporary hotfix

const wrapAsync = asyncExecutor => {
  return new Promise((resolve, reject) => {
    let onDone;
    let isDone;
    const done = (value, isRejected) => {
      if (isDone) return;
      isDone = true;
      onDone && onDone(value, isRejected);
    };
    const _resolve = value => {
      done(value);
      resolve(value);
    };
    const _reject = reason => {
      done(reason, true);
      reject(reason);
    };
    asyncExecutor(_resolve, _reject, onDoneHandler => onDone = onDoneHandler).catch(_reject);
  });
};
const resolveFamily = ({
  address,
  family
}) => {
  if (!utils$1.isString(address)) {
    throw TypeError('address must be a string');
  }
  return {
    address,
    family: family || (address.indexOf('.') < 0 ? 6 : 4)
  };
};
const buildAddressEntry = (address, family) => resolveFamily(utils$1.isObject(address) ? address : {
  address,
  family
});

/*eslint consistent-return:0*/
const httpAdapter = isHttpAdapterSupported && function httpAdapter(config) {
  return wrapAsync(async function dispatchHttpRequest(resolve, reject, onDone) {
    let {
      data,
      lookup,
      family
    } = config;
    const {
      responseType,
      responseEncoding
    } = config;
    const method = config.method.toUpperCase();
    let isDone;
    let rejected = false;
    let req;
    if (lookup) {
      const _lookup = callbackify$1(lookup, value => utils$1.isArray(value) ? value : [value]);
      // hotfix to support opt.all option which is required for node 20.x
      lookup = (hostname, opt, cb) => {
        _lookup(hostname, opt, (err, arg0, arg1) => {
          if (err) {
            return cb(err);
          }
          const addresses = utils$1.isArray(arg0) ? arg0.map(addr => buildAddressEntry(addr)) : [buildAddressEntry(arg0, arg1)];
          opt.all ? cb(err, addresses) : cb(err, addresses[0].address, addresses[0].family);
        });
      };
    }

    // temporary internal emitter until the AxiosRequest class will be implemented
    const emitter = new events.EventEmitter();
    const onFinished = () => {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(abort);
      }
      if (config.signal) {
        config.signal.removeEventListener('abort', abort);
      }
      emitter.removeAllListeners();
    };
    onDone((value, isRejected) => {
      isDone = true;
      if (isRejected) {
        rejected = true;
        onFinished();
      }
    });
    function abort(reason) {
      emitter.emit('abort', !reason || reason.type ? new CanceledError(null, config, req) : reason);
    }
    emitter.once('abort', reject);
    if (config.cancelToken || config.signal) {
      config.cancelToken && config.cancelToken.subscribe(abort);
      if (config.signal) {
        config.signal.aborted ? abort() : config.signal.addEventListener('abort', abort);
      }
    }

    // Parse url
    const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);
    const parsed = new URL(fullPath, platform.hasBrowserEnv ? platform.origin : undefined);
    const protocol = parsed.protocol || supportedProtocols[0];
    if (protocol === 'data:') {
      // Apply the same semantics as HTTP: only enforce if a finite, non-negative cap is set.
      if (config.maxContentLength > -1) {
        // Use the exact string passed to fromDataURI (config.url); fall back to fullPath if needed.
        const dataUrl = String(config.url || fullPath || '');
        const estimated = estimateDataURLDecodedBytes(dataUrl);
        if (estimated > config.maxContentLength) {
          return reject(new AxiosError('maxContentLength size of ' + config.maxContentLength + ' exceeded', AxiosError.ERR_BAD_RESPONSE, config));
        }
      }
      let convertedData;
      if (method !== 'GET') {
        return settle(resolve, reject, {
          status: 405,
          statusText: 'method not allowed',
          headers: {},
          config
        });
      }
      try {
        convertedData = fromDataURI(config.url, responseType === 'blob', {
          Blob: config.env && config.env.Blob
        });
      } catch (err) {
        throw AxiosError.from(err, AxiosError.ERR_BAD_REQUEST, config);
      }
      if (responseType === 'text') {
        convertedData = convertedData.toString(responseEncoding);
        if (!responseEncoding || responseEncoding === 'utf8') {
          convertedData = utils$1.stripBOM(convertedData);
        }
      } else if (responseType === 'stream') {
        convertedData = stream__default["default"].Readable.from(convertedData);
      }
      return settle(resolve, reject, {
        data: convertedData,
        status: 200,
        statusText: 'OK',
        headers: new AxiosHeaders$1(),
        config
      });
    }
    if (supportedProtocols.indexOf(protocol) === -1) {
      return reject(new AxiosError('Unsupported protocol ' + protocol, AxiosError.ERR_BAD_REQUEST, config));
    }
    const headers = AxiosHeaders$1.from(config.headers).normalize();

    // Set User-Agent (required by some servers)
    // See https://github.com/axios/axios/issues/69
    // User-Agent is specified; handle case where no UA header is desired
    // Only set header if it hasn't been set in config
    headers.set('User-Agent', 'axios/' + VERSION, false);
    const {
      onUploadProgress,
      onDownloadProgress
    } = config;
    const maxRate = config.maxRate;
    let maxUploadRate = undefined;
    let maxDownloadRate = undefined;

    // support for spec compliant FormData objects
    if (utils$1.isSpecCompliantForm(data)) {
      const userBoundary = headers.getContentType(/boundary=([-_\w\d]{10,70})/i);
      data = formDataToStream$1(data, formHeaders => {
        headers.set(formHeaders);
      }, {
        tag: `axios-${VERSION}-boundary`,
        boundary: userBoundary && userBoundary[1] || undefined
      });
      // support for https://www.npmjs.com/package/form-data api
    } else if (utils$1.isFormData(data) && utils$1.isFunction(data.getHeaders)) {
      headers.set(data.getHeaders());
      if (!headers.hasContentLength()) {
        try {
          const knownLength = await util__default["default"].promisify(data.getLength).call(data);
          Number.isFinite(knownLength) && knownLength >= 0 && headers.setContentLength(knownLength);
          /*eslint no-empty:0*/
        } catch (e) {}
      }
    } else if (utils$1.isBlob(data) || utils$1.isFile(data)) {
      data.size && headers.setContentType(data.type || 'application/octet-stream');
      headers.setContentLength(data.size || 0);
      data = stream__default["default"].Readable.from(readBlob$1(data));
    } else if (data && !utils$1.isStream(data)) {
      if (Buffer.isBuffer(data)) ;else if (utils$1.isArrayBuffer(data)) {
        data = Buffer.from(new Uint8Array(data));
      } else if (utils$1.isString(data)) {
        data = Buffer.from(data, 'utf-8');
      } else {
        return reject(new AxiosError('Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream', AxiosError.ERR_BAD_REQUEST, config));
      }

      // Add Content-Length header if data exists
      headers.setContentLength(data.length, false);
      if (config.maxBodyLength > -1 && data.length > config.maxBodyLength) {
        return reject(new AxiosError('Request body larger than maxBodyLength limit', AxiosError.ERR_BAD_REQUEST, config));
      }
    }
    const contentLength = utils$1.toFiniteNumber(headers.getContentLength());
    if (utils$1.isArray(maxRate)) {
      maxUploadRate = maxRate[0];
      maxDownloadRate = maxRate[1];
    } else {
      maxUploadRate = maxDownloadRate = maxRate;
    }
    if (data && (onUploadProgress || maxUploadRate)) {
      if (!utils$1.isStream(data)) {
        data = stream__default["default"].Readable.from(data, {
          objectMode: false
        });
      }
      data = stream__default["default"].pipeline([data, new AxiosTransformStream$1({
        maxRate: utils$1.toFiniteNumber(maxUploadRate)
      })], utils$1.noop);
      onUploadProgress && data.on('progress', flushOnFinish(data, progressEventDecorator(contentLength, progressEventReducer(asyncDecorator(onUploadProgress), false, 3))));
    }

    // HTTP basic authentication
    let auth = undefined;
    if (config.auth) {
      const username = config.auth.username || '';
      const password = config.auth.password || '';
      auth = username + ':' + password;
    }
    if (!auth && parsed.username) {
      const urlUsername = parsed.username;
      const urlPassword = parsed.password;
      auth = urlUsername + ':' + urlPassword;
    }
    auth && headers.delete('authorization');
    let path;
    try {
      path = buildURL(parsed.pathname + parsed.search, config.params, config.paramsSerializer).replace(/^\?/, '');
    } catch (err) {
      const customErr = new Error(err.message);
      customErr.config = config;
      customErr.url = config.url;
      customErr.exists = true;
      return reject(customErr);
    }
    headers.set('Accept-Encoding', 'gzip, compress, deflate' + (isBrotliSupported ? ', br' : ''), false);
    const options = {
      path,
      method: method,
      headers: headers.toJSON(),
      agents: {
        http: config.httpAgent,
        https: config.httpsAgent
      },
      auth,
      protocol,
      family,
      beforeRedirect: dispatchBeforeRedirect,
      beforeRedirects: {}
    };

    // cacheable-lookup integration hotfix
    !utils$1.isUndefined(lookup) && (options.lookup = lookup);
    if (config.socketPath) {
      options.socketPath = config.socketPath;
    } else {
      options.hostname = parsed.hostname.startsWith("[") ? parsed.hostname.slice(1, -1) : parsed.hostname;
      options.port = parsed.port;
      setProxy(options, config.proxy, protocol + '//' + parsed.hostname + (parsed.port ? ':' + parsed.port : '') + options.path);
    }
    let transport;
    const isHttpsRequest = isHttps.test(options.protocol);
    options.agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;
    if (config.transport) {
      transport = config.transport;
    } else if (config.maxRedirects === 0) {
      transport = isHttpsRequest ? https__default["default"] : http__default["default"];
    } else {
      if (config.maxRedirects) {
        options.maxRedirects = config.maxRedirects;
      }
      if (config.beforeRedirect) {
        options.beforeRedirects.config = config.beforeRedirect;
      }
      transport = isHttpsRequest ? httpsFollow : httpFollow;
    }
    if (config.maxBodyLength > -1) {
      options.maxBodyLength = config.maxBodyLength;
    } else {
      // follow-redirects does not skip comparison, so it should always succeed for axios -1 unlimited
      options.maxBodyLength = Infinity;
    }
    if (config.insecureHTTPParser) {
      options.insecureHTTPParser = config.insecureHTTPParser;
    }

    // Create the request
    req = transport.request(options, function handleResponse(res) {
      if (req.destroyed) return;
      const streams = [res];
      const responseLength = +res.headers['content-length'];
      if (onDownloadProgress || maxDownloadRate) {
        const transformStream = new AxiosTransformStream$1({
          maxRate: utils$1.toFiniteNumber(maxDownloadRate)
        });
        onDownloadProgress && transformStream.on('progress', flushOnFinish(transformStream, progressEventDecorator(responseLength, progressEventReducer(asyncDecorator(onDownloadProgress), true, 3))));
        streams.push(transformStream);
      }

      // decompress the response body transparently if required
      let responseStream = res;

      // return the last request in case of redirects
      const lastRequest = res.req || req;

      // if decompress disabled we should not decompress
      if (config.decompress !== false && res.headers['content-encoding']) {
        // if no content, but headers still say that it is encoded,
        // remove the header not confuse downstream operations
        if (method === 'HEAD' || res.statusCode === 204) {
          delete res.headers['content-encoding'];
        }
        switch ((res.headers['content-encoding'] || '').toLowerCase()) {
          /*eslint default-case:0*/
          case 'gzip':
          case 'x-gzip':
          case 'compress':
          case 'x-compress':
            // add the unzipper to the body stream processing pipeline
            streams.push(zlib__default["default"].createUnzip(zlibOptions));

            // remove the content-encoding in order to not confuse downstream operations
            delete res.headers['content-encoding'];
            break;
          case 'deflate':
            streams.push(new ZlibHeaderTransformStream$1());

            // add the unzipper to the body stream processing pipeline
            streams.push(zlib__default["default"].createUnzip(zlibOptions));

            // remove the content-encoding in order to not confuse downstream operations
            delete res.headers['content-encoding'];
            break;
          case 'br':
            if (isBrotliSupported) {
              streams.push(zlib__default["default"].createBrotliDecompress(brotliOptions));
              delete res.headers['content-encoding'];
            }
        }
      }
      responseStream = streams.length > 1 ? stream__default["default"].pipeline(streams, utils$1.noop) : streams[0];
      const offListeners = stream__default["default"].finished(responseStream, () => {
        offListeners();
        onFinished();
      });
      const response = {
        status: res.statusCode,
        statusText: res.statusMessage,
        headers: new AxiosHeaders$1(res.headers),
        config,
        request: lastRequest
      };
      if (responseType === 'stream') {
        response.data = responseStream;
        settle(resolve, reject, response);
      } else {
        const responseBuffer = [];
        let totalResponseBytes = 0;
        responseStream.on('data', function handleStreamData(chunk) {
          responseBuffer.push(chunk);
          totalResponseBytes += chunk.length;

          // make sure the content length is not over the maxContentLength if specified
          if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {
            // stream.destroy() emit aborted event before calling reject() on Node.js v16
            rejected = true;
            responseStream.destroy();
            reject(new AxiosError('maxContentLength size of ' + config.maxContentLength + ' exceeded', AxiosError.ERR_BAD_RESPONSE, config, lastRequest));
          }
        });
        responseStream.on('aborted', function handlerStreamAborted() {
          if (rejected) {
            return;
          }
          const err = new AxiosError('stream has been aborted', AxiosError.ERR_BAD_RESPONSE, config, lastRequest);
          responseStream.destroy(err);
          reject(err);
        });
        responseStream.on('error', function handleStreamError(err) {
          if (req.destroyed) return;
          reject(AxiosError.from(err, null, config, lastRequest));
        });
        responseStream.on('end', function handleStreamEnd() {
          try {
            let responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);
            if (responseType !== 'arraybuffer') {
              responseData = responseData.toString(responseEncoding);
              if (!responseEncoding || responseEncoding === 'utf8') {
                responseData = utils$1.stripBOM(responseData);
              }
            }
            response.data = responseData;
          } catch (err) {
            return reject(AxiosError.from(err, null, config, response.request, response));
          }
          settle(resolve, reject, response);
        });
      }
      emitter.once('abort', err => {
        if (!responseStream.destroyed) {
          responseStream.emit('error', err);
          responseStream.destroy();
        }
      });
    });
    emitter.once('abort', err => {
      reject(err);
      req.destroy(err);
    });

    // Handle errors
    req.on('error', function handleRequestError(err) {
      // @todo remove
      // if (req.aborted && err.code !== AxiosError.ERR_FR_TOO_MANY_REDIRECTS) return;
      reject(AxiosError.from(err, null, config, req));
    });

    // set tcp keep alive to prevent drop connection by peer
    req.on('socket', function handleRequestSocket(socket) {
      // default interval of sending ack packet is 1 minute
      socket.setKeepAlive(true, 1000 * 60);
    });

    // Handle request timeout
    if (config.timeout) {
      // This is forcing a int timeout to avoid problems if the `req` interface doesn't handle other types.
      const timeout = parseInt(config.timeout, 10);
      if (Number.isNaN(timeout)) {
        reject(new AxiosError('error trying to parse `config.timeout` to int', AxiosError.ERR_BAD_OPTION_VALUE, config, req));
        return;
      }

      // Sometime, the response will be very slow, and does not respond, the connect event will be block by event loop system.
      // And timer callback will be fired, and abort() will be invoked before connection, then get "socket hang up" and code ECONNRESET.
      // At this time, if we have a large number of request, nodejs will hang up some socket on background. and the number will up and up.
      // And then these socket which be hang up will devouring CPU little by little.
      // ClientRequest.setTimeout will be fired on the specify milliseconds, and can make sure that abort() will be fired after connect.
      req.setTimeout(timeout, function handleRequestTimeout() {
        if (isDone) return;
        let timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';
        const transitional = config.transitional || transitionalDefaults;
        if (config.timeoutErrorMessage) {
          timeoutErrorMessage = config.timeoutErrorMessage;
        }
        reject(new AxiosError(timeoutErrorMessage, transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED, config, req));
        abort();
      });
    }

    // Send the request
    if (utils$1.isStream(data)) {
      let ended = false;
      let errored = false;
      data.on('end', () => {
        ended = true;
      });
      data.once('error', err => {
        errored = true;
        req.destroy(err);
      });
      data.on('close', () => {
        if (!ended && !errored) {
          abort(new CanceledError('Request stream has been aborted', config, req));
        }
      });
      data.pipe(req);
    } else {
      req.end(data);
    }
  });
};
const isURLSameOrigin = platform.hasStandardBrowserEnv ? ((origin, isMSIE) => url => {
  url = new URL(url, platform.origin);
  return origin.protocol === url.protocol && origin.host === url.host && (isMSIE || origin.port === url.port);
})(new URL(platform.origin), platform.navigator && /(msie|trident)/i.test(platform.navigator.userAgent)) : () => true;
const cookies = platform.hasStandardBrowserEnv ?
// Standard browser envs support document.cookie
{
  write(name, value, expires, path, domain, secure) {
    const cookie = [name + '=' + encodeURIComponent(value)];
    utils$1.isNumber(expires) && cookie.push('expires=' + new Date(expires).toGMTString());
    utils$1.isString(path) && cookie.push('path=' + path);
    utils$1.isString(domain) && cookie.push('domain=' + domain);
    secure === true && cookie.push('secure');
    document.cookie = cookie.join('; ');
  },
  read(name) {
    const match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
    return match ? decodeURIComponent(match[3]) : null;
  },
  remove(name) {
    this.write(name, '', Date.now() - 86400000);
  }
} :
// Non-standard browser env (web workers, react-native) lack needed support.
{
  write() {},
  read() {
    return null;
  },
  remove() {}
};
const headersToObject = thing => thing instanceof AxiosHeaders$1 ? {
  ...thing
} : thing;

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 *
 * @returns {Object} New object resulting from merging config2 to config1
 */
function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  const config = {};
  function getMergedValue(target, source, prop, caseless) {
    if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source)) {
      return utils$1.merge.call({
        caseless
      }, target, source);
    } else if (utils$1.isPlainObject(source)) {
      return utils$1.merge({}, source);
    } else if (utils$1.isArray(source)) {
      return source.slice();
    }
    return source;
  }

  // eslint-disable-next-line consistent-return
  function mergeDeepProperties(a, b, prop, caseless) {
    if (!utils$1.isUndefined(b)) {
      return getMergedValue(a, b, prop, caseless);
    } else if (!utils$1.isUndefined(a)) {
      return getMergedValue(undefined, a, prop, caseless);
    }
  }

  // eslint-disable-next-line consistent-return
  function valueFromConfig2(a, b) {
    if (!utils$1.isUndefined(b)) {
      return getMergedValue(undefined, b);
    }
  }

  // eslint-disable-next-line consistent-return
  function defaultToConfig2(a, b) {
    if (!utils$1.isUndefined(b)) {
      return getMergedValue(undefined, b);
    } else if (!utils$1.isUndefined(a)) {
      return getMergedValue(undefined, a);
    }
  }

  // eslint-disable-next-line consistent-return
  function mergeDirectKeys(a, b, prop) {
    if (prop in config2) {
      return getMergedValue(a, b);
    } else if (prop in config1) {
      return getMergedValue(undefined, a);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b, prop) => mergeDeepProperties(headersToObject(a), headersToObject(b), prop, true)
  };
  utils$1.forEach(Object.keys({
    ...config1,
    ...config2
  }), function computeConfigValue(prop) {
    const merge = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge(config1[prop], config2[prop], prop);
    utils$1.isUndefined(configValue) && merge !== mergeDirectKeys || (config[prop] = configValue);
  });
  return config;
}
const resolveConfig = config => {
  const newConfig = mergeConfig({}, config);
  let {
    data,
    withXSRFToken,
    xsrfHeaderName,
    xsrfCookieName,
    headers,
    auth
  } = newConfig;
  newConfig.headers = headers = AxiosHeaders$1.from(headers);
  newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config.params, config.paramsSerializer);

  // HTTP basic authentication
  if (auth) {
    headers.set('Authorization', 'Basic ' + btoa((auth.username || '') + ':' + (auth.password ? unescape(encodeURIComponent(auth.password)) : '')));
  }
  if (utils$1.isFormData(data)) {
    if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
      headers.setContentType(undefined); // browser handles it
    } else if (utils$1.isFunction(data.getHeaders)) {
      // Node.js FormData (like form-data package)
      const formHeaders = data.getHeaders();
      // Only set safe headers to avoid overwriting security headers
      const allowedHeaders = ['content-type', 'content-length'];
      Object.entries(formHeaders).forEach(([key, val]) => {
        if (allowedHeaders.includes(key.toLowerCase())) {
          headers.set(key, val);
        }
      });
    }
  }

  // Add xsrf header
  // This is only done if running in a standard browser environment.
  // Specifically not if we're in a web worker, or react-native.

  if (platform.hasStandardBrowserEnv) {
    withXSRFToken && utils$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
    if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(newConfig.url)) {
      // Add xsrf header
      const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);
      if (xsrfValue) {
        headers.set(xsrfHeaderName, xsrfValue);
      }
    }
  }
  return newConfig;
};
const isXHRAdapterSupported = typeof XMLHttpRequest !== 'undefined';
const xhrAdapter = isXHRAdapterSupported && function (config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    const _config = resolveConfig(config);
    let requestData = _config.data;
    const requestHeaders = AxiosHeaders$1.from(_config.headers).normalize();
    let {
      responseType,
      onUploadProgress,
      onDownloadProgress
    } = _config;
    let onCanceled;
    let uploadThrottled, downloadThrottled;
    let flushUpload, flushDownload;
    function done() {
      flushUpload && flushUpload(); // flush events
      flushDownload && flushDownload(); // flush events

      _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
      _config.signal && _config.signal.removeEventListener('abort', onCanceled);
    }
    let request = new XMLHttpRequest();
    request.open(_config.method.toUpperCase(), _config.url, true);

    // Set the request timeout in MS
    request.timeout = _config.timeout;
    function onloadend() {
      if (!request) {
        return;
      }
      // Prepare the response
      const responseHeaders = AxiosHeaders$1.from('getAllResponseHeaders' in request && request.getAllResponseHeaders());
      const responseData = !responseType || responseType === 'text' || responseType === 'json' ? request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };
      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);

      // Clean up request
      request = null;
    }
    if ('onloadend' in request) {
      // Use onloadend if available
      request.onloadend = onloadend;
    } else {
      // Listen for ready state to emulate onloadend
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }

        // The request errored out and we didn't get a response, this will be
        // handled by onerror instead
        // With one exception: request that using file: protocol, most browsers
        // will return status as 0 even though it's a successful request
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
          return;
        }
        // readystate handler is calling before onerror or ontimeout handlers,
        // so we should call onloadend on the next 'tick'
        setTimeout(onloadend);
      };
    }

    // Handle browser request cancellation (as opposed to a manual cancellation)
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }
      reject(new AxiosError('Request aborted', AxiosError.ECONNABORTED, config, request));

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError(event) {
      // Browsers deliver a ProgressEvent in XHR onerror
      // (message may be empty; when present, surface it)
      // See https://developer.mozilla.org/docs/Web/API/XMLHttpRequest/error_event
      const msg = event && event.message ? event.message : 'Network Error';
      const err = new AxiosError(msg, AxiosError.ERR_NETWORK, config, request);
      // attach the underlying event for consumers who want details
      err.event = event || null;
      reject(err);
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = _config.timeout ? 'timeout of ' + _config.timeout + 'ms exceeded' : 'timeout exceeded';
      const transitional = _config.transitional || transitionalDefaults;
      if (_config.timeoutErrorMessage) {
        timeoutErrorMessage = _config.timeoutErrorMessage;
      }
      reject(new AxiosError(timeoutErrorMessage, transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED, config, request));

      // Clean up request
      request = null;
    };

    // Remove Content-Type if data is undefined
    requestData === undefined && requestHeaders.setContentType(null);

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }

    // Add withCredentials to request if needed
    if (!utils$1.isUndefined(_config.withCredentials)) {
      request.withCredentials = !!_config.withCredentials;
    }

    // Add responseType to request if needed
    if (responseType && responseType !== 'json') {
      request.responseType = _config.responseType;
    }

    // Handle progress if needed
    if (onDownloadProgress) {
      [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
      request.addEventListener('progress', downloadThrottled);
    }

    // Not all browsers support upload events
    if (onUploadProgress && request.upload) {
      [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
      request.upload.addEventListener('progress', uploadThrottled);
      request.upload.addEventListener('loadend', flushUpload);
    }
    if (_config.cancelToken || _config.signal) {
      // Handle cancellation
      // eslint-disable-next-line func-names
      onCanceled = cancel => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);
        request.abort();
        request = null;
      };
      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
      if (_config.signal) {
        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener('abort', onCanceled);
      }
    }
    const protocol = parseProtocol(_config.url);
    if (protocol && platform.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError('Unsupported protocol ' + protocol + ':', AxiosError.ERR_BAD_REQUEST, config));
      return;
    }

    // Send the request
    request.send(requestData || null);
  });
};
const composeSignals = (signals, timeout) => {
  const {
    length
  } = signals = signals ? signals.filter(Boolean) : [];
  if (timeout || length) {
    let controller = new AbortController();
    let aborted;
    const onabort = function (reason) {
      if (!aborted) {
        aborted = true;
        unsubscribe();
        const err = reason instanceof Error ? reason : this.reason;
        controller.abort(err instanceof AxiosError ? err : new CanceledError(err instanceof Error ? err.message : err));
      }
    };
    let timer = timeout && setTimeout(() => {
      timer = null;
      onabort(new AxiosError(`timeout ${timeout} of ms exceeded`, AxiosError.ETIMEDOUT));
    }, timeout);
    const unsubscribe = () => {
      if (signals) {
        timer && clearTimeout(timer);
        timer = null;
        signals.forEach(signal => {
          signal.unsubscribe ? signal.unsubscribe(onabort) : signal.removeEventListener('abort', onabort);
        });
        signals = null;
      }
    };
    signals.forEach(signal => signal.addEventListener('abort', onabort));
    const {
      signal
    } = controller;
    signal.unsubscribe = () => utils$1.asap(unsubscribe);
    return signal;
  }
};
const composeSignals$1 = composeSignals;
const streamChunk = function* (chunk, chunkSize) {
  let len = chunk.byteLength;
  if (!chunkSize || len < chunkSize) {
    yield chunk;
    return;
  }
  let pos = 0;
  let end;
  while (pos < len) {
    end = pos + chunkSize;
    yield chunk.slice(pos, end);
    pos = end;
  }
};
const readBytes = async function* (iterable, chunkSize) {
  for await (const chunk of readStream(iterable)) {
    yield* streamChunk(chunk, chunkSize);
  }
};
const readStream = async function* (stream) {
  if (stream[Symbol.asyncIterator]) {
    yield* stream;
    return;
  }
  const reader = stream.getReader();
  try {
    for (;;) {
      const {
        done,
        value
      } = await reader.read();
      if (done) {
        break;
      }
      yield value;
    }
  } finally {
    await reader.cancel();
  }
};
const trackStream = (stream, chunkSize, onProgress, onFinish) => {
  const iterator = readBytes(stream, chunkSize);
  let bytes = 0;
  let done;
  let _onFinish = e => {
    if (!done) {
      done = true;
      onFinish && onFinish(e);
    }
  };
  return new ReadableStream({
    async pull(controller) {
      try {
        const {
          done,
          value
        } = await iterator.next();
        if (done) {
          _onFinish();
          controller.close();
          return;
        }
        let len = value.byteLength;
        if (onProgress) {
          let loadedBytes = bytes += len;
          onProgress(loadedBytes);
        }
        controller.enqueue(new Uint8Array(value));
      } catch (err) {
        _onFinish(err);
        throw err;
      }
    },
    cancel(reason) {
      _onFinish(reason);
      return iterator.return();
    }
  }, {
    highWaterMark: 2
  });
};
const DEFAULT_CHUNK_SIZE = 64 * 1024;
const {
  isFunction
} = utils$1;
const globalFetchAPI = (({
  Request,
  Response
}) => ({
  Request,
  Response
}))(utils$1.global);
const {
  ReadableStream: ReadableStream$1,
  TextEncoder: TextEncoder$1
} = utils$1.global;
const test = (fn, ...args) => {
  try {
    return !!fn(...args);
  } catch (e) {
    return false;
  }
};
const factory = env => {
  env = utils$1.merge.call({
    skipUndefined: true
  }, globalFetchAPI, env);
  const {
    fetch: envFetch,
    Request,
    Response
  } = env;
  const isFetchSupported = envFetch ? isFunction(envFetch) : typeof fetch === 'function';
  const isRequestSupported = isFunction(Request);
  const isResponseSupported = isFunction(Response);
  if (!isFetchSupported) {
    return false;
  }
  const isReadableStreamSupported = isFetchSupported && isFunction(ReadableStream$1);
  const encodeText = isFetchSupported && (typeof TextEncoder$1 === 'function' ? (encoder => str => encoder.encode(str))(new TextEncoder$1()) : async str => new Uint8Array(await new Request(str).arrayBuffer()));
  const supportsRequestStream = isRequestSupported && isReadableStreamSupported && test(() => {
    let duplexAccessed = false;
    const hasContentType = new Request(platform.origin, {
      body: new ReadableStream$1(),
      method: 'POST',
      get duplex() {
        duplexAccessed = true;
        return 'half';
      }
    }).headers.has('Content-Type');
    return duplexAccessed && !hasContentType;
  });
  const supportsResponseStream = isResponseSupported && isReadableStreamSupported && test(() => utils$1.isReadableStream(new Response('').body));
  const resolvers = {
    stream: supportsResponseStream && (res => res.body)
  };
  isFetchSupported && (() => {
    ['text', 'arrayBuffer', 'blob', 'formData', 'stream'].forEach(type => {
      !resolvers[type] && (resolvers[type] = (res, config) => {
        let method = res && res[type];
        if (method) {
          return method.call(res);
        }
        throw new AxiosError(`Response type '${type}' is not supported`, AxiosError.ERR_NOT_SUPPORT, config);
      });
    });
  })();
  const getBodyLength = async body => {
    if (body == null) {
      return 0;
    }
    if (utils$1.isBlob(body)) {
      return body.size;
    }
    if (utils$1.isSpecCompliantForm(body)) {
      const _request = new Request(platform.origin, {
        method: 'POST',
        body
      });
      return (await _request.arrayBuffer()).byteLength;
    }
    if (utils$1.isArrayBufferView(body) || utils$1.isArrayBuffer(body)) {
      return body.byteLength;
    }
    if (utils$1.isURLSearchParams(body)) {
      body = body + '';
    }
    if (utils$1.isString(body)) {
      return (await encodeText(body)).byteLength;
    }
  };
  const resolveBodyLength = async (headers, body) => {
    const length = utils$1.toFiniteNumber(headers.getContentLength());
    return length == null ? getBodyLength(body) : length;
  };
  return async config => {
    let {
      url,
      method,
      data,
      signal,
      cancelToken,
      timeout,
      onDownloadProgress,
      onUploadProgress,
      responseType,
      headers,
      withCredentials = 'same-origin',
      fetchOptions
    } = resolveConfig(config);
    let _fetch = envFetch || fetch;
    responseType = responseType ? (responseType + '').toLowerCase() : 'text';
    let composedSignal = composeSignals$1([signal, cancelToken && cancelToken.toAbortSignal()], timeout);
    let request = null;
    const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
      composedSignal.unsubscribe();
    });
    let requestContentLength;
    try {
      if (onUploadProgress && supportsRequestStream && method !== 'get' && method !== 'head' && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {
        let _request = new Request(url, {
          method: 'POST',
          body: data,
          duplex: "half"
        });
        let contentTypeHeader;
        if (utils$1.isFormData(data) && (contentTypeHeader = _request.headers.get('content-type'))) {
          headers.setContentType(contentTypeHeader);
        }
        if (_request.body) {
          const [onProgress, flush] = progressEventDecorator(requestContentLength, progressEventReducer(asyncDecorator(onUploadProgress)));
          data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
        }
      }
      if (!utils$1.isString(withCredentials)) {
        withCredentials = withCredentials ? 'include' : 'omit';
      }

      // Cloudflare Workers throws when credentials are defined
      // see https://github.com/cloudflare/workerd/issues/902
      const isCredentialsSupported = isRequestSupported && "credentials" in Request.prototype;
      const resolvedOptions = {
        ...fetchOptions,
        signal: composedSignal,
        method: method.toUpperCase(),
        headers: headers.normalize().toJSON(),
        body: data,
        duplex: "half",
        credentials: isCredentialsSupported ? withCredentials : undefined
      };
      request = isRequestSupported && new Request(url, resolvedOptions);
      let response = await (isRequestSupported ? _fetch(request, fetchOptions) : _fetch(url, resolvedOptions));
      const isStreamResponse = supportsResponseStream && (responseType === 'stream' || responseType === 'response');
      if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {
        const options = {};
        ['status', 'statusText', 'headers'].forEach(prop => {
          options[prop] = response[prop];
        });
        const responseContentLength = utils$1.toFiniteNumber(response.headers.get('content-length'));
        const [onProgress, flush] = onDownloadProgress && progressEventDecorator(responseContentLength, progressEventReducer(asyncDecorator(onDownloadProgress), true)) || [];
        response = new Response(trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
          flush && flush();
          unsubscribe && unsubscribe();
        }), options);
      }
      responseType = responseType || 'text';
      let responseData = await resolvers[utils$1.findKey(resolvers, responseType) || 'text'](response, config);
      !isStreamResponse && unsubscribe && unsubscribe();
      return await new Promise((resolve, reject) => {
        settle(resolve, reject, {
          data: responseData,
          headers: AxiosHeaders$1.from(response.headers),
          status: response.status,
          statusText: response.statusText,
          config,
          request
        });
      });
    } catch (err) {
      unsubscribe && unsubscribe();
      if (err && err.name === 'TypeError' && /Load failed|fetch/i.test(err.message)) {
        throw Object.assign(new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request), {
          cause: err.cause || err
        });
      }
      throw AxiosError.from(err, err && err.code, config, request);
    }
  };
};
const seedCache = new Map();
const getFetch = config => {
  let env = config ? config.env : {};
  const {
    fetch,
    Request,
    Response
  } = env;
  const seeds = [Request, Response, fetch];
  let len = seeds.length,
    i = len,
    seed,
    target,
    map = seedCache;
  while (i--) {
    seed = seeds[i];
    target = map.get(seed);
    target === undefined && map.set(seed, target = i ? new Map() : factory(env));
    map = target;
  }
  return target;
};
getFetch();
const knownAdapters = {
  http: httpAdapter,
  xhr: xhrAdapter,
  fetch: {
    get: getFetch
  }
};
utils$1.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, 'name', {
        value
      });
    } catch (e) {
      // eslint-disable-next-line no-empty
    }
    Object.defineProperty(fn, 'adapterName', {
      value
    });
  }
});
const renderReason = reason => `- ${reason}`;
const isResolvedHandle = adapter => utils$1.isFunction(adapter) || adapter === null || adapter === false;
const adapters = {
  getAdapter: (adapters, config) => {
    adapters = utils$1.isArray(adapters) ? adapters : [adapters];
    const {
      length
    } = adapters;
    let nameOrAdapter;
    let adapter;
    const rejectedReasons = {};
    for (let i = 0; i < length; i++) {
      nameOrAdapter = adapters[i];
      let id;
      adapter = nameOrAdapter;
      if (!isResolvedHandle(nameOrAdapter)) {
        adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
        if (adapter === undefined) {
          throw new AxiosError(`Unknown adapter '${id}'`);
        }
      }
      if (adapter && (utils$1.isFunction(adapter) || (adapter = adapter.get(config)))) {
        break;
      }
      rejectedReasons[id || '#' + i] = adapter;
    }
    if (!adapter) {
      const reasons = Object.entries(rejectedReasons).map(([id, state]) => `adapter ${id} ` + (state === false ? 'is not supported by the environment' : 'is not available in the build'));
      let s = length ? reasons.length > 1 ? 'since :\n' + reasons.map(renderReason).join('\n') : ' ' + renderReason(reasons[0]) : 'as no adapter specified';
      throw new AxiosError(`There is no suitable adapter to dispatch the request ` + s, 'ERR_NOT_SUPPORT');
    }
    return adapter;
  },
  adapters: knownAdapters
};

/**
 * Throws a `CanceledError` if cancellation has been requested.
 *
 * @param {Object} config The config that is to be used for the request
 *
 * @returns {void}
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
  if (config.signal && config.signal.aborted) {
    throw new CanceledError(null, config);
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 *
 * @returns {Promise} The Promise to be fulfilled
 */
function dispatchRequest(config) {
  throwIfCancellationRequested(config);
  config.headers = AxiosHeaders$1.from(config.headers);

  // Transform request data
  config.data = transformData.call(config, config.transformRequest);
  if (['post', 'put', 'patch'].indexOf(config.method) !== -1) {
    config.headers.setContentType('application/x-www-form-urlencoded', false);
  }
  const adapter = adapters.getAdapter(config.adapter || defaults$1.adapter, config);
  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData.call(config, config.transformResponse, response);
    response.headers = AxiosHeaders$1.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData.call(config, config.transformResponse, reason.response);
        reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}
const validators$1 = {};

// eslint-disable-next-line func-names
['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach((type, i) => {
  validators$1[type] = function validator(thing) {
    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
  };
});
const deprecatedWarnings = {};

/**
 * Transitional option validator
 *
 * @param {function|boolean?} validator - set to false if the transitional option has been removed
 * @param {string?} version - deprecated version / removed since version
 * @param {string?} message - some message with additional info
 *
 * @returns {function}
 */
validators$1.transitional = function transitional(validator, version, message) {
  function formatMessage(opt, desc) {
    return '[Axios v' + VERSION + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
  }

  // eslint-disable-next-line func-names
  return (value, opt, opts) => {
    if (validator === false) {
      throw new AxiosError(formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')), AxiosError.ERR_DEPRECATED);
    }
    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      // eslint-disable-next-line no-console
      console.warn(formatMessage(opt, ' has been deprecated since v' + version + ' and will be removed in the near future'));
    }
    return validator ? validator(value, opt, opts) : true;
  };
};
validators$1.spelling = function spelling(correctSpelling) {
  return (value, opt) => {
    // eslint-disable-next-line no-console
    console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
    return true;
  };
};

/**
 * Assert object's properties type
 *
 * @param {object} options
 * @param {object} schema
 * @param {boolean?} allowUnknown
 *
 * @returns {object}
 */

function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== 'object') {
    throw new AxiosError('options must be an object', AxiosError.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i = keys.length;
  while (i-- > 0) {
    const opt = keys[i];
    const validator = schema[opt];
    if (validator) {
      const value = options[opt];
      const result = value === undefined || validator(value, opt, options);
      if (result !== true) {
        throw new AxiosError('option ' + opt + ' must be ' + result, AxiosError.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError('Unknown option ' + opt, AxiosError.ERR_BAD_OPTION);
    }
  }
}
const validator = {
  assertOptions,
  validators: validators$1
};
const validators = validator.validators;

/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 *
 * @return {Axios} A new instance of Axios
 */
class Axios {
  constructor(instanceConfig) {
    this.defaults = instanceConfig || {};
    this.interceptors = {
      request: new InterceptorManager$1(),
      response: new InterceptorManager$1()
    };
  }

  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(configOrUrl, config) {
    try {
      return await this._request(configOrUrl, config);
    } catch (err) {
      if (err instanceof Error) {
        let dummy = {};
        Error.captureStackTrace ? Error.captureStackTrace(dummy) : dummy = new Error();

        // slice off the Error: ... line
        const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, '') : '';
        try {
          if (!err.stack) {
            err.stack = stack;
            // match without the 2 top stack lines
          } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ''))) {
            err.stack += '\n' + stack;
          }
        } catch (e) {
          // ignore the case where "stack" is an un-writable property
        }
      }
      throw err;
    }
  }
  _request(configOrUrl, config) {
    /*eslint no-param-reassign:0*/
    // Allow for axios('example/url'[, config]) a la fetch API
    if (typeof configOrUrl === 'string') {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }
    config = mergeConfig(this.defaults, config);
    const {
      transitional,
      paramsSerializer,
      headers
    } = config;
    if (transitional !== undefined) {
      validator.assertOptions(transitional, {
        silentJSONParsing: validators.transitional(validators.boolean),
        forcedJSONParsing: validators.transitional(validators.boolean),
        clarifyTimeoutError: validators.transitional(validators.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils$1.isFunction(paramsSerializer)) {
        config.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator.assertOptions(paramsSerializer, {
          encode: validators.function,
          serialize: validators.function
        }, true);
      }
    }

    // Set config.allowAbsoluteUrls
    if (config.allowAbsoluteUrls !== undefined) ;else if (this.defaults.allowAbsoluteUrls !== undefined) {
      config.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
    } else {
      config.allowAbsoluteUrls = true;
    }
    validator.assertOptions(config, {
      baseUrl: validators.spelling('baseURL'),
      withXsrfToken: validators.spelling('withXSRFToken')
    }, true);

    // Set config.method
    config.method = (config.method || this.defaults.method || 'get').toLowerCase();

    // Flatten headers
    let contextHeaders = headers && utils$1.merge(headers.common, headers[config.method]);
    headers && utils$1.forEach(['delete', 'get', 'head', 'post', 'put', 'patch', 'common'], method => {
      delete headers[method];
    });
    config.headers = AxiosHeaders$1.concat(contextHeaders, headers);

    // filter out skipped interceptors
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise;
    let i = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), undefined];
      chain.unshift(...requestInterceptorChain);
      chain.push(...responseInterceptorChain);
      len = chain.length;
      promise = Promise.resolve(config);
      while (i < len) {
        promise = promise.then(chain[i++], chain[i++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config;
    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    i = 0;
    len = responseInterceptorChain.length;
    while (i < len) {
      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }
    return promise;
  }
  getUri(config) {
    config = mergeConfig(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
}

// Provide aliases for supported request methods
utils$1.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function (url, config) {
    return this.request(mergeConfig(config || {}, {
      method,
      url,
      data: (config || {}).data
    }));
  };
});
utils$1.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/

  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        headers: isForm ? {
          'Content-Type': 'multipart/form-data'
        } : {},
        url,
        data
      }));
    };
  }
  Axios.prototype[method] = generateHTTPMethod();
  Axios.prototype[method + 'Form'] = generateHTTPMethod(true);
});
const Axios$1 = Axios;

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @param {Function} executor The executor function.
 *
 * @returns {CancelToken}
 */
class CancelToken {
  constructor(executor) {
    if (typeof executor !== 'function') {
      throw new TypeError('executor must be a function.');
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    const token = this;

    // eslint-disable-next-line func-names
    this.promise.then(cancel => {
      if (!token._listeners) return;
      let i = token._listeners.length;
      while (i-- > 0) {
        token._listeners[i](cancel);
      }
      token._listeners = null;
    });

    // eslint-disable-next-line func-names
    this.promise.then = onfulfilled => {
      let _resolve;
      // eslint-disable-next-line func-names
      const promise = new Promise(resolve => {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message, config, request) {
      if (token.reason) {
        // Cancellation has already been requested
        return;
      }
      token.reason = new CanceledError(message, config, request);
      resolvePromise(token.reason);
    });
  }

  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }

  /**
   * Subscribe to the cancel signal
   */

  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }

  /**
   * Unsubscribe from the cancel signal
   */

  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  }
  toAbortSignal() {
    const controller = new AbortController();
    const abort = err => {
      controller.abort(err);
    };
    this.subscribe(abort);
    controller.signal.unsubscribe = () => this.unsubscribe(abort);
    return controller.signal;
  }

  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token,
      cancel
    };
  }
}
const CancelToken$1 = CancelToken;

/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 *
 * @returns {Function}
 */
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}

/**
 * Determines whether the payload is an error thrown by Axios
 *
 * @param {*} payload The value to test
 *
 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
 */
function isAxiosError(payload) {
  return utils$1.isObject(payload) && payload.isAxiosError === true;
}
const HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});
const HttpStatusCode$1 = HttpStatusCode;

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 *
 * @returns {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  const context = new Axios$1(defaultConfig);
  const instance = bind(Axios$1.prototype.request, context);

  // Copy axios.prototype to instance
  utils$1.extend(instance, Axios$1.prototype, context, {
    allOwnKeys: true
  });

  // Copy context to instance
  utils$1.extend(instance, context, null, {
    allOwnKeys: true
  });

  // Factory for creating new instances
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };
  return instance;
}

// Create the default instance to be exported
const axios = createInstance(defaults$1);

// Expose Axios class to allow class inheritance
axios.Axios = Axios$1;

// Expose Cancel & CancelToken
axios.CanceledError = CanceledError;
axios.CancelToken = CancelToken$1;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData;

// Expose AxiosError class
axios.AxiosError = AxiosError;

// alias for CanceledError for backward compatibility
axios.Cancel = axios.CanceledError;

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = spread;

// Expose isAxiosError
axios.isAxiosError = isAxiosError;

// Expose mergeConfig
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders$1;
axios.formToJSON = thing => formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.getAdapter = adapters.getAdapter;
axios.HttpStatusCode = HttpStatusCode$1;
axios.default = axios;
module.exports = axios;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJiaW5kIiwiZm4iLCJ0aGlzQXJnIiwid3JhcCIsImFwcGx5IiwiYXJndW1lbnRzIiwidG9TdHJpbmciLCJPYmplY3QiLCJwcm90b3R5cGUiLCJnZXRQcm90b3R5cGVPZiIsIml0ZXJhdG9yIiwidG9TdHJpbmdUYWciLCJTeW1ib2wiLCJraW5kT2YiLCJjYWNoZSIsInRoaW5nIiwic3RyIiwiY2FsbCIsInNsaWNlIiwidG9Mb3dlckNhc2UiLCJjcmVhdGUiLCJraW5kT2ZUZXN0IiwidHlwZSIsInR5cGVPZlRlc3QiLCJpc0FycmF5IiwiQXJyYXkiLCJpc1VuZGVmaW5lZCIsImlzQnVmZmVyIiwidmFsIiwiY29uc3RydWN0b3IiLCJpc0Z1bmN0aW9uJDEiLCJpc0FycmF5QnVmZmVyIiwiaXNBcnJheUJ1ZmZlclZpZXciLCJyZXN1bHQiLCJBcnJheUJ1ZmZlciIsImlzVmlldyIsImJ1ZmZlciIsImlzU3RyaW5nIiwiaXNOdW1iZXIiLCJpc09iamVjdCIsImlzQm9vbGVhbiIsImlzUGxhaW5PYmplY3QiLCJpc0VtcHR5T2JqZWN0Iiwia2V5cyIsImxlbmd0aCIsImUiLCJpc0RhdGUiLCJpc0ZpbGUiLCJpc0Jsb2IiLCJpc0ZpbGVMaXN0IiwiaXNTdHJlYW0iLCJwaXBlIiwiaXNGb3JtRGF0YSIsImtpbmQiLCJGb3JtRGF0YSIsImFwcGVuZCIsImlzVVJMU2VhcmNoUGFyYW1zIiwiaXNSZWFkYWJsZVN0cmVhbSIsImlzUmVxdWVzdCIsImlzUmVzcG9uc2UiLCJpc0hlYWRlcnMiLCJtYXAiLCJ0cmltIiwicmVwbGFjZSIsImZvckVhY2giLCJvYmoiLCJhbGxPd25LZXlzIiwiaSIsImwiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwibGVuIiwia2V5IiwiZmluZEtleSIsIl9rZXkiLCJfZ2xvYmFsIiwiZ2xvYmFsVGhpcyIsInNlbGYiLCJ3aW5kb3ciLCJnbG9iYWwiLCJpc0NvbnRleHREZWZpbmVkIiwiY29udGV4dCIsIm1lcmdlIiwiY2FzZWxlc3MiLCJza2lwVW5kZWZpbmVkIiwiYXNzaWduVmFsdWUiLCJ0YXJnZXRLZXkiLCJleHRlbmQiLCJhIiwiYiIsInN0cmlwQk9NIiwiY29udGVudCIsImNoYXJDb2RlQXQiLCJpbmhlcml0cyIsInN1cGVyQ29uc3RydWN0b3IiLCJwcm9wcyIsImRlc2NyaXB0b3JzIiwiZGVmaW5lUHJvcGVydHkiLCJ2YWx1ZSIsImFzc2lnbiIsInRvRmxhdE9iamVjdCIsInNvdXJjZU9iaiIsImRlc3RPYmoiLCJmaWx0ZXIiLCJwcm9wRmlsdGVyIiwicHJvcCIsIm1lcmdlZCIsImVuZHNXaXRoIiwic2VhcmNoU3RyaW5nIiwicG9zaXRpb24iLCJTdHJpbmciLCJ1bmRlZmluZWQiLCJsYXN0SW5kZXgiLCJpbmRleE9mIiwidG9BcnJheSIsImFyciIsImlzVHlwZWRBcnJheSIsIlR5cGVkQXJyYXkiLCJVaW50OEFycmF5IiwiZm9yRWFjaEVudHJ5IiwiZ2VuZXJhdG9yIiwiX2l0ZXJhdG9yIiwibmV4dCIsImRvbmUiLCJwYWlyIiwibWF0Y2hBbGwiLCJyZWdFeHAiLCJtYXRjaGVzIiwiZXhlYyIsInB1c2giLCJpc0hUTUxGb3JtIiwidG9DYW1lbENhc2UiLCJyZXBsYWNlciIsIm0iLCJwMSIsInAyIiwidG9VcHBlckNhc2UiLCJoYXNPd25Qcm9wZXJ0eSIsImlzUmVnRXhwIiwicmVkdWNlRGVzY3JpcHRvcnMiLCJyZWR1Y2VyIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsInJlZHVjZWREZXNjcmlwdG9ycyIsImRlc2NyaXB0b3IiLCJuYW1lIiwicmV0IiwiZGVmaW5lUHJvcGVydGllcyIsImZyZWV6ZU1ldGhvZHMiLCJlbnVtZXJhYmxlIiwid3JpdGFibGUiLCJzZXQiLCJFcnJvciIsInRvT2JqZWN0U2V0IiwiYXJyYXlPclN0cmluZyIsImRlbGltaXRlciIsImRlZmluZSIsInNwbGl0Iiwibm9vcCIsInRvRmluaXRlTnVtYmVyIiwiZGVmYXVsdFZhbHVlIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJpc1NwZWNDb21wbGlhbnRGb3JtIiwidG9KU09OT2JqZWN0Iiwic3RhY2siLCJ2aXNpdCIsInNvdXJjZSIsInRhcmdldCIsInJlZHVjZWRWYWx1ZSIsImlzQXN5bmNGbiIsImlzVGhlbmFibGUiLCJ0aGVuIiwiY2F0Y2giLCJfc2V0SW1tZWRpYXRlIiwic2V0SW1tZWRpYXRlU3VwcG9ydGVkIiwicG9zdE1lc3NhZ2VTdXBwb3J0ZWQiLCJzZXRJbW1lZGlhdGUiLCJ0b2tlbiIsImNhbGxiYWNrcyIsImFkZEV2ZW50TGlzdGVuZXIiLCJkYXRhIiwic2hpZnQiLCJjYiIsInBvc3RNZXNzYWdlIiwiTWF0aCIsInJhbmRvbSIsInNldFRpbWVvdXQiLCJhc2FwIiwicXVldWVNaWNyb3Rhc2siLCJwcm9jZXNzIiwibmV4dFRpY2siLCJpc0l0ZXJhYmxlIiwidXRpbHMkMSIsImlzRnVuY3Rpb24iLCJoYXNPd25Qcm9wIiwiQXhpb3NFcnJvciIsIm1lc3NhZ2UiLCJjb2RlIiwiY29uZmlnIiwicmVxdWVzdCIsInJlc3BvbnNlIiwiY2FwdHVyZVN0YWNrVHJhY2UiLCJzdGF0dXMiLCJ0b0pTT04iLCJkZXNjcmlwdGlvbiIsIm51bWJlciIsImZpbGVOYW1lIiwibGluZU51bWJlciIsImNvbHVtbk51bWJlciIsInByb3RvdHlwZSQxIiwiZnJvbSIsImVycm9yIiwiY3VzdG9tUHJvcHMiLCJheGlvc0Vycm9yIiwibXNnIiwiZXJyQ29kZSIsImNhdXNlIiwiY29uZmlndXJhYmxlIiwiaXNWaXNpdGFibGUiLCJyZW1vdmVCcmFja2V0cyIsInJlbmRlcktleSIsInBhdGgiLCJkb3RzIiwiY29uY2F0IiwiZWFjaCIsImpvaW4iLCJpc0ZsYXRBcnJheSIsInNvbWUiLCJwcmVkaWNhdGVzIiwidGVzdCIsInRvRm9ybURhdGEiLCJmb3JtRGF0YSIsIm9wdGlvbnMiLCJUeXBlRXJyb3IiLCJGb3JtRGF0YV9fZGVmYXVsdCIsIm1ldGFUb2tlbnMiLCJpbmRleGVzIiwiZGVmaW5lZCIsIm9wdGlvbiIsInZpc2l0b3IiLCJkZWZhdWx0VmlzaXRvciIsIl9CbG9iIiwiQmxvYiIsInVzZUJsb2IiLCJjb252ZXJ0VmFsdWUiLCJ0b0lTT1N0cmluZyIsIkJ1ZmZlciIsIkpTT04iLCJzdHJpbmdpZnkiLCJlbCIsImluZGV4IiwiZXhwb3NlZEhlbHBlcnMiLCJidWlsZCIsInBvcCIsImVuY29kZSQxIiwiZW5jb2RlIiwiY2hhck1hcCIsImVuY29kZVVSSUNvbXBvbmVudCIsIm1hdGNoIiwiQXhpb3NVUkxTZWFyY2hQYXJhbXMiLCJwYXJhbXMiLCJfcGFpcnMiLCJlbmNvZGVyIiwiX2VuY29kZSIsImJ1aWxkVVJMIiwidXJsIiwic2VyaWFsaXplIiwic2VyaWFsaXplRm4iLCJzZXJpYWxpemVkUGFyYW1zIiwiaGFzaG1hcmtJbmRleCIsIkludGVyY2VwdG9yTWFuYWdlciIsImhhbmRsZXJzIiwidXNlIiwiZnVsZmlsbGVkIiwicmVqZWN0ZWQiLCJzeW5jaHJvbm91cyIsInJ1bldoZW4iLCJlamVjdCIsImlkIiwiY2xlYXIiLCJmb3JFYWNoSGFuZGxlciIsImgiLCJJbnRlcmNlcHRvck1hbmFnZXIkMSIsInRyYW5zaXRpb25hbERlZmF1bHRzIiwic2lsZW50SlNPTlBhcnNpbmciLCJmb3JjZWRKU09OUGFyc2luZyIsImNsYXJpZnlUaW1lb3V0RXJyb3IiLCJVUkxTZWFyY2hQYXJhbXMiLCJ1cmxfX2RlZmF1bHQiLCJBTFBIQSIsIkRJR0lUIiwiQUxQSEFCRVQiLCJBTFBIQV9ESUdJVCIsImdlbmVyYXRlU3RyaW5nIiwic2l6ZSIsImFscGhhYmV0IiwicmFuZG9tVmFsdWVzIiwiVWludDMyQXJyYXkiLCJjcnlwdG9fX2RlZmF1bHQiLCJyYW5kb21GaWxsU3luYyIsInBsYXRmb3JtJDEiLCJpc05vZGUiLCJjbGFzc2VzIiwicHJvdG9jb2xzIiwiaGFzQnJvd3NlckVudiIsImRvY3VtZW50IiwiX25hdmlnYXRvciIsIm5hdmlnYXRvciIsImhhc1N0YW5kYXJkQnJvd3NlckVudiIsInByb2R1Y3QiLCJoYXNTdGFuZGFyZEJyb3dzZXJXZWJXb3JrZXJFbnYiLCJXb3JrZXJHbG9iYWxTY29wZSIsImltcG9ydFNjcmlwdHMiLCJvcmlnaW4iLCJsb2NhdGlvbiIsImhyZWYiLCJwbGF0Zm9ybSIsInV0aWxzIiwidG9VUkxFbmNvZGVkRm9ybSIsImhlbHBlcnMiLCJwYXJzZVByb3BQYXRoIiwiYXJyYXlUb09iamVjdCIsImZvcm1EYXRhVG9KU09OIiwiYnVpbGRQYXRoIiwiaXNOdW1lcmljS2V5IiwiaXNMYXN0IiwiZW50cmllcyIsInN0cmluZ2lmeVNhZmVseSIsInJhd1ZhbHVlIiwicGFyc2VyIiwicGFyc2UiLCJkZWZhdWx0cyIsInRyYW5zaXRpb25hbCIsImFkYXB0ZXIiLCJ0cmFuc2Zvcm1SZXF1ZXN0IiwiaGVhZGVycyIsImNvbnRlbnRUeXBlIiwiZ2V0Q29udGVudFR5cGUiLCJoYXNKU09OQ29udGVudFR5cGUiLCJpc09iamVjdFBheWxvYWQiLCJzZXRDb250ZW50VHlwZSIsImZvcm1TZXJpYWxpemVyIiwiX0Zvcm1EYXRhIiwiZW52IiwidHJhbnNmb3JtUmVzcG9uc2UiLCJKU09OUmVxdWVzdGVkIiwicmVzcG9uc2VUeXBlIiwic3RyaWN0SlNPTlBhcnNpbmciLCJwYXJzZVJldml2ZXIiLCJFUlJfQkFEX1JFU1BPTlNFIiwidGltZW91dCIsInhzcmZDb29raWVOYW1lIiwieHNyZkhlYWRlck5hbWUiLCJtYXhDb250ZW50TGVuZ3RoIiwibWF4Qm9keUxlbmd0aCIsInZhbGlkYXRlU3RhdHVzIiwiY29tbW9uIiwibWV0aG9kIiwiZGVmYXVsdHMkMSIsImlnbm9yZUR1cGxpY2F0ZU9mIiwicGFyc2VIZWFkZXJzIiwicmF3SGVhZGVycyIsInBhcnNlZCIsImxpbmUiLCJzdWJzdHJpbmciLCIkaW50ZXJuYWxzIiwibm9ybWFsaXplSGVhZGVyIiwiaGVhZGVyIiwibm9ybWFsaXplVmFsdWUiLCJwYXJzZVRva2VucyIsInRva2VucyIsInRva2Vuc1JFIiwiaXNWYWxpZEhlYWRlck5hbWUiLCJtYXRjaEhlYWRlclZhbHVlIiwiaXNIZWFkZXJOYW1lRmlsdGVyIiwiZm9ybWF0SGVhZGVyIiwidyIsImNoYXIiLCJidWlsZEFjY2Vzc29ycyIsImFjY2Vzc29yTmFtZSIsIm1ldGhvZE5hbWUiLCJhcmcxIiwiYXJnMiIsImFyZzMiLCJBeGlvc0hlYWRlcnMiLCJ2YWx1ZU9yUmV3cml0ZSIsInJld3JpdGUiLCJzZXRIZWFkZXIiLCJfdmFsdWUiLCJfaGVhZGVyIiwiX3Jld3JpdGUiLCJsSGVhZGVyIiwic2V0SGVhZGVycyIsImRlc3QiLCJlbnRyeSIsImdldCIsImhhcyIsIm1hdGNoZXIiLCJkZWxldGUiLCJkZWxldGVkIiwiZGVsZXRlSGVhZGVyIiwibm9ybWFsaXplIiwiZm9ybWF0Iiwibm9ybWFsaXplZCIsInRhcmdldHMiLCJhc1N0cmluZ3MiLCJnZXRTZXRDb29raWUiLCJmaXJzdCIsImNvbXB1dGVkIiwiYWNjZXNzb3IiLCJpbnRlcm5hbHMiLCJhY2Nlc3NvcnMiLCJkZWZpbmVBY2Nlc3NvciIsIm1hcHBlZCIsImhlYWRlclZhbHVlIiwiQXhpb3NIZWFkZXJzJDEiLCJ0cmFuc2Zvcm1EYXRhIiwiZm5zIiwidHJhbnNmb3JtIiwiaXNDYW5jZWwiLCJfX0NBTkNFTF9fIiwiQ2FuY2VsZWRFcnJvciIsIkVSUl9DQU5DRUxFRCIsInNldHRsZSIsInJlc29sdmUiLCJyZWplY3QiLCJFUlJfQkFEX1JFUVVFU1QiLCJmbG9vciIsImlzQWJzb2x1dGVVUkwiLCJjb21iaW5lVVJMcyIsImJhc2VVUkwiLCJyZWxhdGl2ZVVSTCIsImJ1aWxkRnVsbFBhdGgiLCJyZXF1ZXN0ZWRVUkwiLCJhbGxvd0Fic29sdXRlVXJscyIsImlzUmVsYXRpdmVVcmwiLCJWRVJTSU9OIiwicGFyc2VQcm90b2NvbCIsIkRBVEFfVVJMX1BBVFRFUk4iLCJmcm9tRGF0YVVSSSIsInVyaSIsImFzQmxvYiIsInByb3RvY29sIiwiRVJSX0lOVkFMSURfVVJMIiwibWltZSIsImlzQmFzZTY0IiwiYm9keSIsImRlY29kZVVSSUNvbXBvbmVudCIsIkVSUl9OT1RfU1VQUE9SVCIsImtJbnRlcm5hbHMiLCJBeGlvc1RyYW5zZm9ybVN0cmVhbSIsInN0cmVhbV9fZGVmYXVsdCIsIlRyYW5zZm9ybSIsIm1heFJhdGUiLCJjaHVua1NpemUiLCJtaW5DaHVua1NpemUiLCJ0aW1lV2luZG93IiwidGlja3NSYXRlIiwic2FtcGxlc0NvdW50IiwicmVhZGFibGVIaWdoV2F0ZXJNYXJrIiwiYnl0ZXNTZWVuIiwiaXNDYXB0dXJlZCIsIm5vdGlmaWVkQnl0ZXNMb2FkZWQiLCJ0cyIsIkRhdGUiLCJub3ciLCJieXRlcyIsIm9uUmVhZENhbGxiYWNrIiwib24iLCJldmVudCIsIl9yZWFkIiwiX3RyYW5zZm9ybSIsImNodW5rIiwiZW5jb2RpbmciLCJjYWxsYmFjayIsImRpdmlkZXIiLCJieXRlc1RocmVzaG9sZCIsIm1heCIsInB1c2hDaHVuayIsIl9jaHVuayIsIl9jYWxsYmFjayIsImJ5dGVMZW5ndGgiLCJlbWl0IiwidHJhbnNmb3JtQ2h1bmsiLCJjaHVua1JlbWFpbmRlciIsIm1heENodW5rU2l6ZSIsImJ5dGVzTGVmdCIsInBhc3NlZCIsInN1YmFycmF5IiwidHJhbnNmb3JtTmV4dENodW5rIiwiZXJyIiwiQXhpb3NUcmFuc2Zvcm1TdHJlYW0kMSIsImFzeW5jSXRlcmF0b3IiLCJyZWFkQmxvYiIsImJsb2IiLCJzdHJlYW0iLCJhcnJheUJ1ZmZlciIsInJlYWRCbG9iJDEiLCJCT1VOREFSWV9BTFBIQUJFVCIsInRleHRFbmNvZGVyIiwiVGV4dEVuY29kZXIiLCJ1dGlsX19kZWZhdWx0IiwiQ1JMRiIsIkNSTEZfQllURVMiLCJDUkxGX0JZVEVTX0NPVU5UIiwiRm9ybURhdGFQYXJ0IiwiZXNjYXBlTmFtZSIsImlzU3RyaW5nVmFsdWUiLCJjb250ZW50TGVuZ3RoIiwiZm9ybURhdGFUb1N0cmVhbSIsImZvcm0iLCJoZWFkZXJzSGFuZGxlciIsInRhZyIsImJvdW5kYXJ5IiwiYm91bmRhcnlCeXRlcyIsImZvb3RlckJ5dGVzIiwicGFydHMiLCJwYXJ0IiwiY29tcHV0ZWRIZWFkZXJzIiwiUmVhZGFibGUiLCJmb3JtRGF0YVRvU3RyZWFtJDEiLCJabGliSGVhZGVyVHJhbnNmb3JtU3RyZWFtIiwiX190cmFuc2Zvcm0iLCJhbGxvYyIsIlpsaWJIZWFkZXJUcmFuc2Zvcm1TdHJlYW0kMSIsImNhbGxiYWNraWZ5IiwiYXJncyIsImNhbGxiYWNraWZ5JDEiLCJzcGVlZG9tZXRlciIsIm1pbiIsInRpbWVzdGFtcHMiLCJoZWFkIiwidGFpbCIsImZpcnN0U2FtcGxlVFMiLCJjaHVua0xlbmd0aCIsInN0YXJ0ZWRBdCIsImJ5dGVzQ291bnQiLCJyb3VuZCIsInRocm90dGxlIiwiZnJlcSIsInRpbWVzdGFtcCIsInRocmVzaG9sZCIsImxhc3RBcmdzIiwidGltZXIiLCJpbnZva2UiLCJjbGVhclRpbWVvdXQiLCJ0aHJvdHRsZWQiLCJmbHVzaCIsInByb2dyZXNzRXZlbnRSZWR1Y2VyIiwibGlzdGVuZXIiLCJpc0Rvd25sb2FkU3RyZWFtIiwiYnl0ZXNOb3RpZmllZCIsIl9zcGVlZG9tZXRlciIsImxvYWRlZCIsInRvdGFsIiwibGVuZ3RoQ29tcHV0YWJsZSIsInByb2dyZXNzQnl0ZXMiLCJyYXRlIiwiaW5SYW5nZSIsInByb2dyZXNzIiwiZXN0aW1hdGVkIiwicHJvZ3Jlc3NFdmVudERlY29yYXRvciIsImFzeW5jRGVjb3JhdG9yIiwiZXN0aW1hdGVEYXRhVVJMRGVjb2RlZEJ5dGVzIiwic3RhcnRzV2l0aCIsImNvbW1hIiwibWV0YSIsImVmZmVjdGl2ZUxlbiIsImlzSGV4IiwicGFkIiwiaWR4IiwidGFpbElzUGN0M0QiLCJqIiwiZ3JvdXBzIiwiemxpYk9wdGlvbnMiLCJ6bGliX19kZWZhdWx0IiwiY29uc3RhbnRzIiwiWl9TWU5DX0ZMVVNIIiwiZmluaXNoRmx1c2giLCJicm90bGlPcHRpb25zIiwiQlJPVExJX09QRVJBVElPTl9GTFVTSCIsImlzQnJvdGxpU3VwcG9ydGVkIiwiY3JlYXRlQnJvdGxpRGVjb21wcmVzcyIsImh0dHAiLCJodHRwRm9sbG93IiwiaHR0cHMiLCJodHRwc0ZvbGxvdyIsImZvbGxvd1JlZGlyZWN0c19fZGVmYXVsdCIsImlzSHR0cHMiLCJzdXBwb3J0ZWRQcm90b2NvbHMiLCJmbHVzaE9uRmluaXNoIiwiZGlzcGF0Y2hCZWZvcmVSZWRpcmVjdCIsInJlc3BvbnNlRGV0YWlscyIsImJlZm9yZVJlZGlyZWN0cyIsInByb3h5Iiwic2V0UHJveHkiLCJjb25maWdQcm94eSIsInByb3h5VXJsIiwicHJveHlGcm9tRW52X19kZWZhdWx0IiwiZ2V0UHJveHlGb3JVcmwiLCJVUkwiLCJ1c2VybmFtZSIsImF1dGgiLCJwYXNzd29yZCIsImJhc2U2NCIsImhvc3QiLCJob3N0bmFtZSIsInBvcnQiLCJwcm94eUhvc3QiLCJpbmNsdWRlcyIsImJlZm9yZVJlZGlyZWN0IiwicmVkaXJlY3RPcHRpb25zIiwiaXNIdHRwQWRhcHRlclN1cHBvcnRlZCIsIndyYXBBc3luYyIsImFzeW5jRXhlY3V0b3IiLCJQcm9taXNlIiwib25Eb25lIiwiaXNEb25lIiwiaXNSZWplY3RlZCIsIl9yZXNvbHZlIiwiX3JlamVjdCIsInJlYXNvbiIsIm9uRG9uZUhhbmRsZXIiLCJyZXNvbHZlRmFtaWx5IiwiYWRkcmVzcyIsImZhbWlseSIsImJ1aWxkQWRkcmVzc0VudHJ5IiwiaHR0cEFkYXB0ZXIiLCJkaXNwYXRjaEh0dHBSZXF1ZXN0IiwibG9va3VwIiwicmVzcG9uc2VFbmNvZGluZyIsInJlcSIsIl9sb29rdXAiLCJvcHQiLCJhcmcwIiwiYWRkcmVzc2VzIiwiYWRkciIsImFsbCIsImVtaXR0ZXIiLCJldmVudHMiLCJFdmVudEVtaXR0ZXIiLCJvbkZpbmlzaGVkIiwiY2FuY2VsVG9rZW4iLCJ1bnN1YnNjcmliZSIsImFib3J0Iiwic2lnbmFsIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInJlbW92ZUFsbExpc3RlbmVycyIsIm9uY2UiLCJzdWJzY3JpYmUiLCJhYm9ydGVkIiwiZnVsbFBhdGgiLCJkYXRhVXJsIiwiY29udmVydGVkRGF0YSIsInN0YXR1c1RleHQiLCJvblVwbG9hZFByb2dyZXNzIiwib25Eb3dubG9hZFByb2dyZXNzIiwibWF4VXBsb2FkUmF0ZSIsIm1heERvd25sb2FkUmF0ZSIsInVzZXJCb3VuZGFyeSIsImZvcm1IZWFkZXJzIiwiZ2V0SGVhZGVycyIsImhhc0NvbnRlbnRMZW5ndGgiLCJrbm93bkxlbmd0aCIsInByb21pc2lmeSIsImdldExlbmd0aCIsInNldENvbnRlbnRMZW5ndGgiLCJnZXRDb250ZW50TGVuZ3RoIiwib2JqZWN0TW9kZSIsInBpcGVsaW5lIiwidXJsVXNlcm5hbWUiLCJ1cmxQYXNzd29yZCIsInBhdGhuYW1lIiwic2VhcmNoIiwicGFyYW1zU2VyaWFsaXplciIsImN1c3RvbUVyciIsImV4aXN0cyIsImFnZW50cyIsImh0dHBBZ2VudCIsImh0dHBzQWdlbnQiLCJzb2NrZXRQYXRoIiwidHJhbnNwb3J0IiwiaXNIdHRwc1JlcXVlc3QiLCJhZ2VudCIsIm1heFJlZGlyZWN0cyIsImh0dHBzX19kZWZhdWx0IiwiaHR0cF9fZGVmYXVsdCIsIkluZmluaXR5IiwiaW5zZWN1cmVIVFRQUGFyc2VyIiwiaGFuZGxlUmVzcG9uc2UiLCJyZXMiLCJkZXN0cm95ZWQiLCJzdHJlYW1zIiwicmVzcG9uc2VMZW5ndGgiLCJ0cmFuc2Zvcm1TdHJlYW0iLCJyZXNwb25zZVN0cmVhbSIsImxhc3RSZXF1ZXN0IiwiZGVjb21wcmVzcyIsInN0YXR1c0NvZGUiLCJjcmVhdGVVbnppcCIsIm9mZkxpc3RlbmVycyIsImZpbmlzaGVkIiwic3RhdHVzTWVzc2FnZSIsInJlc3BvbnNlQnVmZmVyIiwidG90YWxSZXNwb25zZUJ5dGVzIiwiaGFuZGxlU3RyZWFtRGF0YSIsImRlc3Ryb3kiLCJoYW5kbGVyU3RyZWFtQWJvcnRlZCIsImhhbmRsZVN0cmVhbUVycm9yIiwiaGFuZGxlU3RyZWFtRW5kIiwicmVzcG9uc2VEYXRhIiwiaGFuZGxlUmVxdWVzdEVycm9yIiwiaGFuZGxlUmVxdWVzdFNvY2tldCIsInNvY2tldCIsInNldEtlZXBBbGl2ZSIsInBhcnNlSW50IiwiaXNOYU4iLCJFUlJfQkFEX09QVElPTl9WQUxVRSIsImhhbmRsZVJlcXVlc3RUaW1lb3V0IiwidGltZW91dEVycm9yTWVzc2FnZSIsIkVUSU1FRE9VVCIsIkVDT05OQUJPUlRFRCIsImVuZGVkIiwiZXJyb3JlZCIsImVuZCIsImlzVVJMU2FtZU9yaWdpbiIsImlzTVNJRSIsInVzZXJBZ2VudCIsImNvb2tpZXMiLCJ3cml0ZSIsImV4cGlyZXMiLCJkb21haW4iLCJzZWN1cmUiLCJjb29raWUiLCJ0b0dNVFN0cmluZyIsInJlYWQiLCJSZWdFeHAiLCJyZW1vdmUiLCJoZWFkZXJzVG9PYmplY3QiLCJtZXJnZUNvbmZpZyIsImNvbmZpZzEiLCJjb25maWcyIiwiZ2V0TWVyZ2VkVmFsdWUiLCJtZXJnZURlZXBQcm9wZXJ0aWVzIiwidmFsdWVGcm9tQ29uZmlnMiIsImRlZmF1bHRUb0NvbmZpZzIiLCJtZXJnZURpcmVjdEtleXMiLCJtZXJnZU1hcCIsInRpbWVvdXRNZXNzYWdlIiwid2l0aENyZWRlbnRpYWxzIiwid2l0aFhTUkZUb2tlbiIsImNvbXB1dGVDb25maWdWYWx1ZSIsImNvbmZpZ1ZhbHVlIiwicmVzb2x2ZUNvbmZpZyIsIm5ld0NvbmZpZyIsImJ0b2EiLCJ1bmVzY2FwZSIsImFsbG93ZWRIZWFkZXJzIiwieHNyZlZhbHVlIiwiaXNYSFJBZGFwdGVyU3VwcG9ydGVkIiwiWE1MSHR0cFJlcXVlc3QiLCJ4aHJBZGFwdGVyIiwiZGlzcGF0Y2hYaHJSZXF1ZXN0IiwiX2NvbmZpZyIsInJlcXVlc3REYXRhIiwicmVxdWVzdEhlYWRlcnMiLCJvbkNhbmNlbGVkIiwidXBsb2FkVGhyb3R0bGVkIiwiZG93bmxvYWRUaHJvdHRsZWQiLCJmbHVzaFVwbG9hZCIsImZsdXNoRG93bmxvYWQiLCJvcGVuIiwib25sb2FkZW5kIiwicmVzcG9uc2VIZWFkZXJzIiwiZ2V0QWxsUmVzcG9uc2VIZWFkZXJzIiwicmVzcG9uc2VUZXh0Iiwib25yZWFkeXN0YXRlY2hhbmdlIiwiaGFuZGxlTG9hZCIsInJlYWR5U3RhdGUiLCJyZXNwb25zZVVSTCIsIm9uYWJvcnQiLCJoYW5kbGVBYm9ydCIsIm9uZXJyb3IiLCJoYW5kbGVFcnJvciIsIkVSUl9ORVRXT1JLIiwib250aW1lb3V0IiwiaGFuZGxlVGltZW91dCIsInNldFJlcXVlc3RIZWFkZXIiLCJ1cGxvYWQiLCJjYW5jZWwiLCJzZW5kIiwiY29tcG9zZVNpZ25hbHMiLCJzaWduYWxzIiwiQm9vbGVhbiIsImNvbnRyb2xsZXIiLCJBYm9ydENvbnRyb2xsZXIiLCJjb21wb3NlU2lnbmFscyQxIiwic3RyZWFtQ2h1bmsiLCJwb3MiLCJyZWFkQnl0ZXMiLCJpdGVyYWJsZSIsInJlYWRTdHJlYW0iLCJyZWFkZXIiLCJnZXRSZWFkZXIiLCJ0cmFja1N0cmVhbSIsIm9uUHJvZ3Jlc3MiLCJvbkZpbmlzaCIsIl9vbkZpbmlzaCIsIlJlYWRhYmxlU3RyZWFtIiwicHVsbCIsImNsb3NlIiwibG9hZGVkQnl0ZXMiLCJlbnF1ZXVlIiwicmV0dXJuIiwiaGlnaFdhdGVyTWFyayIsIkRFRkFVTFRfQ0hVTktfU0laRSIsImdsb2JhbEZldGNoQVBJIiwiUmVxdWVzdCIsIlJlc3BvbnNlIiwiUmVhZGFibGVTdHJlYW0kMSIsIlRleHRFbmNvZGVyJDEiLCJmYWN0b3J5IiwiZmV0Y2giLCJlbnZGZXRjaCIsImlzRmV0Y2hTdXBwb3J0ZWQiLCJpc1JlcXVlc3RTdXBwb3J0ZWQiLCJpc1Jlc3BvbnNlU3VwcG9ydGVkIiwiaXNSZWFkYWJsZVN0cmVhbVN1cHBvcnRlZCIsImVuY29kZVRleHQiLCJzdXBwb3J0c1JlcXVlc3RTdHJlYW0iLCJkdXBsZXhBY2Nlc3NlZCIsImhhc0NvbnRlbnRUeXBlIiwiZHVwbGV4Iiwic3VwcG9ydHNSZXNwb25zZVN0cmVhbSIsInJlc29sdmVycyIsImdldEJvZHlMZW5ndGgiLCJfcmVxdWVzdCIsInJlc29sdmVCb2R5TGVuZ3RoIiwiZmV0Y2hPcHRpb25zIiwiX2ZldGNoIiwiY29tcG9zZWRTaWduYWwiLCJ0b0Fib3J0U2lnbmFsIiwicmVxdWVzdENvbnRlbnRMZW5ndGgiLCJjb250ZW50VHlwZUhlYWRlciIsImlzQ3JlZGVudGlhbHNTdXBwb3J0ZWQiLCJyZXNvbHZlZE9wdGlvbnMiLCJjcmVkZW50aWFscyIsImlzU3RyZWFtUmVzcG9uc2UiLCJyZXNwb25zZUNvbnRlbnRMZW5ndGgiLCJzZWVkQ2FjaGUiLCJNYXAiLCJnZXRGZXRjaCIsInNlZWRzIiwic2VlZCIsImtub3duQWRhcHRlcnMiLCJ4aHIiLCJyZW5kZXJSZWFzb24iLCJpc1Jlc29sdmVkSGFuZGxlIiwiYWRhcHRlcnMiLCJnZXRBZGFwdGVyIiwibmFtZU9yQWRhcHRlciIsInJlamVjdGVkUmVhc29ucyIsInJlYXNvbnMiLCJzdGF0ZSIsInMiLCJ0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkIiwidGhyb3dJZlJlcXVlc3RlZCIsImRpc3BhdGNoUmVxdWVzdCIsIm9uQWRhcHRlclJlc29sdXRpb24iLCJvbkFkYXB0ZXJSZWplY3Rpb24iLCJ2YWxpZGF0b3JzJDEiLCJ2YWxpZGF0b3IiLCJkZXByZWNhdGVkV2FybmluZ3MiLCJ2ZXJzaW9uIiwiZm9ybWF0TWVzc2FnZSIsImRlc2MiLCJvcHRzIiwiRVJSX0RFUFJFQ0FURUQiLCJjb25zb2xlIiwid2FybiIsInNwZWxsaW5nIiwiY29ycmVjdFNwZWxsaW5nIiwiYXNzZXJ0T3B0aW9ucyIsInNjaGVtYSIsImFsbG93VW5rbm93biIsIkVSUl9CQURfT1BUSU9OIiwidmFsaWRhdG9ycyIsIkF4aW9zIiwiaW5zdGFuY2VDb25maWciLCJpbnRlcmNlcHRvcnMiLCJjb25maWdPclVybCIsImR1bW15IiwiYm9vbGVhbiIsImZ1bmN0aW9uIiwiYmFzZVVybCIsIndpdGhYc3JmVG9rZW4iLCJjb250ZXh0SGVhZGVycyIsInJlcXVlc3RJbnRlcmNlcHRvckNoYWluIiwic3luY2hyb25vdXNSZXF1ZXN0SW50ZXJjZXB0b3JzIiwidW5zaGlmdFJlcXVlc3RJbnRlcmNlcHRvcnMiLCJpbnRlcmNlcHRvciIsInVuc2hpZnQiLCJyZXNwb25zZUludGVyY2VwdG9yQ2hhaW4iLCJwdXNoUmVzcG9uc2VJbnRlcmNlcHRvcnMiLCJwcm9taXNlIiwiY2hhaW4iLCJvbkZ1bGZpbGxlZCIsIm9uUmVqZWN0ZWQiLCJnZXRVcmkiLCJmb3JFYWNoTWV0aG9kTm9EYXRhIiwiZm9yRWFjaE1ldGhvZFdpdGhEYXRhIiwiZ2VuZXJhdGVIVFRQTWV0aG9kIiwiaXNGb3JtIiwiaHR0cE1ldGhvZCIsIkF4aW9zJDEiLCJDYW5jZWxUb2tlbiIsImV4ZWN1dG9yIiwicmVzb2x2ZVByb21pc2UiLCJwcm9taXNlRXhlY3V0b3IiLCJfbGlzdGVuZXJzIiwib25mdWxmaWxsZWQiLCJzcGxpY2UiLCJjIiwiQ2FuY2VsVG9rZW4kMSIsInNwcmVhZCIsImlzQXhpb3NFcnJvciIsInBheWxvYWQiLCJIdHRwU3RhdHVzQ29kZSIsIkNvbnRpbnVlIiwiU3dpdGNoaW5nUHJvdG9jb2xzIiwiUHJvY2Vzc2luZyIsIkVhcmx5SGludHMiLCJPayIsIkNyZWF0ZWQiLCJBY2NlcHRlZCIsIk5vbkF1dGhvcml0YXRpdmVJbmZvcm1hdGlvbiIsIk5vQ29udGVudCIsIlJlc2V0Q29udGVudCIsIlBhcnRpYWxDb250ZW50IiwiTXVsdGlTdGF0dXMiLCJBbHJlYWR5UmVwb3J0ZWQiLCJJbVVzZWQiLCJNdWx0aXBsZUNob2ljZXMiLCJNb3ZlZFBlcm1hbmVudGx5IiwiRm91bmQiLCJTZWVPdGhlciIsIk5vdE1vZGlmaWVkIiwiVXNlUHJveHkiLCJVbnVzZWQiLCJUZW1wb3JhcnlSZWRpcmVjdCIsIlBlcm1hbmVudFJlZGlyZWN0IiwiQmFkUmVxdWVzdCIsIlVuYXV0aG9yaXplZCIsIlBheW1lbnRSZXF1aXJlZCIsIkZvcmJpZGRlbiIsIk5vdEZvdW5kIiwiTWV0aG9kTm90QWxsb3dlZCIsIk5vdEFjY2VwdGFibGUiLCJQcm94eUF1dGhlbnRpY2F0aW9uUmVxdWlyZWQiLCJSZXF1ZXN0VGltZW91dCIsIkNvbmZsaWN0IiwiR29uZSIsIkxlbmd0aFJlcXVpcmVkIiwiUHJlY29uZGl0aW9uRmFpbGVkIiwiUGF5bG9hZFRvb0xhcmdlIiwiVXJpVG9vTG9uZyIsIlVuc3VwcG9ydGVkTWVkaWFUeXBlIiwiUmFuZ2VOb3RTYXRpc2ZpYWJsZSIsIkV4cGVjdGF0aW9uRmFpbGVkIiwiSW1BVGVhcG90IiwiTWlzZGlyZWN0ZWRSZXF1ZXN0IiwiVW5wcm9jZXNzYWJsZUVudGl0eSIsIkxvY2tlZCIsIkZhaWxlZERlcGVuZGVuY3kiLCJUb29FYXJseSIsIlVwZ3JhZGVSZXF1aXJlZCIsIlByZWNvbmRpdGlvblJlcXVpcmVkIiwiVG9vTWFueVJlcXVlc3RzIiwiUmVxdWVzdEhlYWRlckZpZWxkc1Rvb0xhcmdlIiwiVW5hdmFpbGFibGVGb3JMZWdhbFJlYXNvbnMiLCJJbnRlcm5hbFNlcnZlckVycm9yIiwiTm90SW1wbGVtZW50ZWQiLCJCYWRHYXRld2F5IiwiU2VydmljZVVuYXZhaWxhYmxlIiwiR2F0ZXdheVRpbWVvdXQiLCJIdHRwVmVyc2lvbk5vdFN1cHBvcnRlZCIsIlZhcmlhbnRBbHNvTmVnb3RpYXRlcyIsIkluc3VmZmljaWVudFN0b3JhZ2UiLCJMb29wRGV0ZWN0ZWQiLCJOb3RFeHRlbmRlZCIsIk5ldHdvcmtBdXRoZW50aWNhdGlvblJlcXVpcmVkIiwiSHR0cFN0YXR1c0NvZGUkMSIsImNyZWF0ZUluc3RhbmNlIiwiZGVmYXVsdENvbmZpZyIsImluc3RhbmNlIiwiYXhpb3MiLCJDYW5jZWwiLCJwcm9taXNlcyIsImZvcm1Ub0pTT04iLCJkZWZhdWx0Il0sInNvdXJjZXMiOlsiLi4vLi4vbGliL2hlbHBlcnMvYmluZC5qcyIsIi4uLy4uL2xpYi91dGlscy5qcyIsIi4uLy4uL2xpYi9jb3JlL0F4aW9zRXJyb3IuanMiLCIuLi8uLi9saWIvaGVscGVycy90b0Zvcm1EYXRhLmpzIiwiLi4vLi4vbGliL2hlbHBlcnMvQXhpb3NVUkxTZWFyY2hQYXJhbXMuanMiLCIuLi8uLi9saWIvaGVscGVycy9idWlsZFVSTC5qcyIsIi4uLy4uL2xpYi9jb3JlL0ludGVyY2VwdG9yTWFuYWdlci5qcyIsIi4uLy4uL2xpYi9kZWZhdWx0cy90cmFuc2l0aW9uYWwuanMiLCIuLi8uLi9saWIvcGxhdGZvcm0vbm9kZS9jbGFzc2VzL1VSTFNlYXJjaFBhcmFtcy5qcyIsIi4uLy4uL2xpYi9wbGF0Zm9ybS9ub2RlL2luZGV4LmpzIiwiLi4vLi4vbGliL3BsYXRmb3JtL2NvbW1vbi91dGlscy5qcyIsIi4uLy4uL2xpYi9wbGF0Zm9ybS9pbmRleC5qcyIsIi4uLy4uL2xpYi9oZWxwZXJzL3RvVVJMRW5jb2RlZEZvcm0uanMiLCIuLi8uLi9saWIvaGVscGVycy9mb3JtRGF0YVRvSlNPTi5qcyIsIi4uLy4uL2xpYi9kZWZhdWx0cy9pbmRleC5qcyIsIi4uLy4uL2xpYi9oZWxwZXJzL3BhcnNlSGVhZGVycy5qcyIsIi4uLy4uL2xpYi9jb3JlL0F4aW9zSGVhZGVycy5qcyIsIi4uLy4uL2xpYi9jb3JlL3RyYW5zZm9ybURhdGEuanMiLCIuLi8uLi9saWIvY2FuY2VsL2lzQ2FuY2VsLmpzIiwiLi4vLi4vbGliL2NhbmNlbC9DYW5jZWxlZEVycm9yLmpzIiwiLi4vLi4vbGliL2NvcmUvc2V0dGxlLmpzIiwiLi4vLi4vbGliL2hlbHBlcnMvaXNBYnNvbHV0ZVVSTC5qcyIsIi4uLy4uL2xpYi9oZWxwZXJzL2NvbWJpbmVVUkxzLmpzIiwiLi4vLi4vbGliL2NvcmUvYnVpbGRGdWxsUGF0aC5qcyIsIi4uLy4uL2xpYi9lbnYvZGF0YS5qcyIsIi4uLy4uL2xpYi9oZWxwZXJzL3BhcnNlUHJvdG9jb2wuanMiLCIuLi8uLi9saWIvaGVscGVycy9mcm9tRGF0YVVSSS5qcyIsIi4uLy4uL2xpYi9oZWxwZXJzL0F4aW9zVHJhbnNmb3JtU3RyZWFtLmpzIiwiLi4vLi4vbGliL2hlbHBlcnMvcmVhZEJsb2IuanMiLCIuLi8uLi9saWIvaGVscGVycy9mb3JtRGF0YVRvU3RyZWFtLmpzIiwiLi4vLi4vbGliL2hlbHBlcnMvWmxpYkhlYWRlclRyYW5zZm9ybVN0cmVhbS5qcyIsIi4uLy4uL2xpYi9oZWxwZXJzL2NhbGxiYWNraWZ5LmpzIiwiLi4vLi4vbGliL2hlbHBlcnMvc3BlZWRvbWV0ZXIuanMiLCIuLi8uLi9saWIvaGVscGVycy90aHJvdHRsZS5qcyIsIi4uLy4uL2xpYi9oZWxwZXJzL3Byb2dyZXNzRXZlbnRSZWR1Y2VyLmpzIiwiLi4vLi4vbGliL2hlbHBlcnMvZXN0aW1hdGVEYXRhVVJMRGVjb2RlZEJ5dGVzLmpzIiwiLi4vLi4vbGliL2FkYXB0ZXJzL2h0dHAuanMiLCIuLi8uLi9saWIvaGVscGVycy9pc1VSTFNhbWVPcmlnaW4uanMiLCIuLi8uLi9saWIvaGVscGVycy9jb29raWVzLmpzIiwiLi4vLi4vbGliL2NvcmUvbWVyZ2VDb25maWcuanMiLCIuLi8uLi9saWIvaGVscGVycy9yZXNvbHZlQ29uZmlnLmpzIiwiLi4vLi4vbGliL2FkYXB0ZXJzL3hoci5qcyIsIi4uLy4uL2xpYi9oZWxwZXJzL2NvbXBvc2VTaWduYWxzLmpzIiwiLi4vLi4vbGliL2hlbHBlcnMvdHJhY2tTdHJlYW0uanMiLCIuLi8uLi9saWIvYWRhcHRlcnMvZmV0Y2guanMiLCIuLi8uLi9saWIvYWRhcHRlcnMvYWRhcHRlcnMuanMiLCIuLi8uLi9saWIvY29yZS9kaXNwYXRjaFJlcXVlc3QuanMiLCIuLi8uLi9saWIvaGVscGVycy92YWxpZGF0b3IuanMiLCIuLi8uLi9saWIvY29yZS9BeGlvcy5qcyIsIi4uLy4uL2xpYi9jYW5jZWwvQ2FuY2VsVG9rZW4uanMiLCIuLi8uLi9saWIvaGVscGVycy9zcHJlYWQuanMiLCIuLi8uLi9saWIvaGVscGVycy9pc0F4aW9zRXJyb3IuanMiLCIuLi8uLi9saWIvaGVscGVycy9IdHRwU3RhdHVzQ29kZS5qcyIsIi4uLy4uL2xpYi9heGlvcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGJpbmQoZm4sIHRoaXNBcmcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHdyYXAoKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXNBcmcsIGFyZ3VtZW50cyk7XG4gIH07XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBiaW5kIGZyb20gJy4vaGVscGVycy9iaW5kLmpzJztcblxuLy8gdXRpbHMgaXMgYSBsaWJyYXJ5IG9mIGdlbmVyaWMgaGVscGVyIGZ1bmN0aW9ucyBub24tc3BlY2lmaWMgdG8gYXhpb3NcblxuY29uc3Qge3RvU3RyaW5nfSA9IE9iamVjdC5wcm90b3R5cGU7XG5jb25zdCB7Z2V0UHJvdG90eXBlT2Z9ID0gT2JqZWN0O1xuY29uc3Qge2l0ZXJhdG9yLCB0b1N0cmluZ1RhZ30gPSBTeW1ib2w7XG5cbmNvbnN0IGtpbmRPZiA9IChjYWNoZSA9PiB0aGluZyA9PiB7XG4gICAgY29uc3Qgc3RyID0gdG9TdHJpbmcuY2FsbCh0aGluZyk7XG4gICAgcmV0dXJuIGNhY2hlW3N0cl0gfHwgKGNhY2hlW3N0cl0gPSBzdHIuc2xpY2UoOCwgLTEpLnRvTG93ZXJDYXNlKCkpO1xufSkoT2JqZWN0LmNyZWF0ZShudWxsKSk7XG5cbmNvbnN0IGtpbmRPZlRlc3QgPSAodHlwZSkgPT4ge1xuICB0eXBlID0gdHlwZS50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gKHRoaW5nKSA9PiBraW5kT2YodGhpbmcpID09PSB0eXBlXG59XG5cbmNvbnN0IHR5cGVPZlRlc3QgPSB0eXBlID0+IHRoaW5nID0+IHR5cGVvZiB0aGluZyA9PT0gdHlwZTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBBcnJheVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBBcnJheSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IHtpc0FycmF5fSA9IEFycmF5O1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIHVuZGVmaW5lZFxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHZhbHVlIGlzIHVuZGVmaW5lZCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzVW5kZWZpbmVkID0gdHlwZU9mVGVzdCgndW5kZWZpbmVkJyk7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBCdWZmZXJcbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgQnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNCdWZmZXIodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IG51bGwgJiYgIWlzVW5kZWZpbmVkKHZhbCkgJiYgdmFsLmNvbnN0cnVjdG9yICE9PSBudWxsICYmICFpc1VuZGVmaW5lZCh2YWwuY29uc3RydWN0b3IpXG4gICAgJiYgaXNGdW5jdGlvbih2YWwuY29uc3RydWN0b3IuaXNCdWZmZXIpICYmIHZhbC5jb25zdHJ1Y3Rvci5pc0J1ZmZlcih2YWwpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIEFycmF5QnVmZmVyXG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBBcnJheUJ1ZmZlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzQXJyYXlCdWZmZXIgPSBraW5kT2ZUZXN0KCdBcnJheUJ1ZmZlcicpO1xuXG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSB2aWV3IG9uIGFuIEFycmF5QnVmZmVyXG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIHZpZXcgb24gYW4gQXJyYXlCdWZmZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyVmlldyh2YWwpIHtcbiAgbGV0IHJlc3VsdDtcbiAgaWYgKCh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnKSAmJiAoQXJyYXlCdWZmZXIuaXNWaWV3KSkge1xuICAgIHJlc3VsdCA9IEFycmF5QnVmZmVyLmlzVmlldyh2YWwpO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9ICh2YWwpICYmICh2YWwuYnVmZmVyKSAmJiAoaXNBcnJheUJ1ZmZlcih2YWwuYnVmZmVyKSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFN0cmluZ1xuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBTdHJpbmcsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc1N0cmluZyA9IHR5cGVPZlRlc3QoJ3N0cmluZycpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBGdW5jdGlvbiwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzRnVuY3Rpb24gPSB0eXBlT2ZUZXN0KCdmdW5jdGlvbicpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgTnVtYmVyXG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIE51bWJlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzTnVtYmVyID0gdHlwZU9mVGVzdCgnbnVtYmVyJyk7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gT2JqZWN0XG4gKlxuICogQHBhcmFtIHsqfSB0aGluZyBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIE9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzT2JqZWN0ID0gKHRoaW5nKSA9PiB0aGluZyAhPT0gbnVsbCAmJiB0eXBlb2YgdGhpbmcgPT09ICdvYmplY3QnO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgQm9vbGVhblxuICpcbiAqIEBwYXJhbSB7Kn0gdGhpbmcgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgQm9vbGVhbiwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzQm9vbGVhbiA9IHRoaW5nID0+IHRoaW5nID09PSB0cnVlIHx8IHRoaW5nID09PSBmYWxzZTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIHBsYWluIE9iamVjdFxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBwbGFpbiBPYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc1BsYWluT2JqZWN0ID0gKHZhbCkgPT4ge1xuICBpZiAoa2luZE9mKHZhbCkgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3QgcHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YodmFsKTtcbiAgcmV0dXJuIChwcm90b3R5cGUgPT09IG51bGwgfHwgcHJvdG90eXBlID09PSBPYmplY3QucHJvdG90eXBlIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90b3R5cGUpID09PSBudWxsKSAmJiAhKHRvU3RyaW5nVGFnIGluIHZhbCkgJiYgIShpdGVyYXRvciBpbiB2YWwpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIGVtcHR5IG9iamVjdCAoc2FmZWx5IGhhbmRsZXMgQnVmZmVycylcbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIGVtcHR5IG9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzRW1wdHlPYmplY3QgPSAodmFsKSA9PiB7XG4gIC8vIEVhcmx5IHJldHVybiBmb3Igbm9uLW9iamVjdHMgb3IgQnVmZmVycyB0byBwcmV2ZW50IFJhbmdlRXJyb3JcbiAgaWYgKCFpc09iamVjdCh2YWwpIHx8IGlzQnVmZmVyKHZhbCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh2YWwpLmxlbmd0aCA9PT0gMCAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsKSA9PT0gT2JqZWN0LnByb3RvdHlwZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIEZhbGxiYWNrIGZvciBhbnkgb3RoZXIgb2JqZWN0cyB0aGF0IG1pZ2h0IGNhdXNlIFJhbmdlRXJyb3Igd2l0aCBPYmplY3Qua2V5cygpXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBEYXRlXG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIERhdGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc0RhdGUgPSBraW5kT2ZUZXN0KCdEYXRlJyk7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBGaWxlXG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEZpbGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc0ZpbGUgPSBraW5kT2ZUZXN0KCdGaWxlJyk7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBCbG9iXG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEJsb2IsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc0Jsb2IgPSBraW5kT2ZUZXN0KCdCbG9iJyk7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBGaWxlTGlzdFxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBGaWxlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNGaWxlTGlzdCA9IGtpbmRPZlRlc3QoJ0ZpbGVMaXN0Jyk7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBTdHJlYW1cbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgU3RyZWFtLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNTdHJlYW0gPSAodmFsKSA9PiBpc09iamVjdCh2YWwpICYmIGlzRnVuY3Rpb24odmFsLnBpcGUpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRm9ybURhdGFcbiAqXG4gKiBAcGFyYW0geyp9IHRoaW5nIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gRm9ybURhdGEsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc0Zvcm1EYXRhID0gKHRoaW5nKSA9PiB7XG4gIGxldCBraW5kO1xuICByZXR1cm4gdGhpbmcgJiYgKFxuICAgICh0eXBlb2YgRm9ybURhdGEgPT09ICdmdW5jdGlvbicgJiYgdGhpbmcgaW5zdGFuY2VvZiBGb3JtRGF0YSkgfHwgKFxuICAgICAgaXNGdW5jdGlvbih0aGluZy5hcHBlbmQpICYmIChcbiAgICAgICAgKGtpbmQgPSBraW5kT2YodGhpbmcpKSA9PT0gJ2Zvcm1kYXRhJyB8fFxuICAgICAgICAvLyBkZXRlY3QgZm9ybS1kYXRhIGluc3RhbmNlXG4gICAgICAgIChraW5kID09PSAnb2JqZWN0JyAmJiBpc0Z1bmN0aW9uKHRoaW5nLnRvU3RyaW5nKSAmJiB0aGluZy50b1N0cmluZygpID09PSAnW29iamVjdCBGb3JtRGF0YV0nKVxuICAgICAgKVxuICAgIClcbiAgKVxufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBVUkxTZWFyY2hQYXJhbXMgb2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNVUkxTZWFyY2hQYXJhbXMgPSBraW5kT2ZUZXN0KCdVUkxTZWFyY2hQYXJhbXMnKTtcblxuY29uc3QgW2lzUmVhZGFibGVTdHJlYW0sIGlzUmVxdWVzdCwgaXNSZXNwb25zZSwgaXNIZWFkZXJzXSA9IFsnUmVhZGFibGVTdHJlYW0nLCAnUmVxdWVzdCcsICdSZXNwb25zZScsICdIZWFkZXJzJ10ubWFwKGtpbmRPZlRlc3QpO1xuXG4vKipcbiAqIFRyaW0gZXhjZXNzIHdoaXRlc3BhY2Ugb2ZmIHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiBhIHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIFN0cmluZyB0byB0cmltXG4gKlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIFN0cmluZyBmcmVlZCBvZiBleGNlc3Mgd2hpdGVzcGFjZVxuICovXG5jb25zdCB0cmltID0gKHN0cikgPT4gc3RyLnRyaW0gP1xuICBzdHIudHJpbSgpIDogc3RyLnJlcGxhY2UoL15bXFxzXFx1RkVGRlxceEEwXSt8W1xcc1xcdUZFRkZcXHhBMF0rJC9nLCAnJyk7XG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGFuIEFycmF5IG9yIGFuIE9iamVjdCBpbnZva2luZyBhIGZ1bmN0aW9uIGZvciBlYWNoIGl0ZW0uXG4gKlxuICogSWYgYG9iamAgaXMgYW4gQXJyYXkgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgcGFzc2luZ1xuICogdGhlIHZhbHVlLCBpbmRleCwgYW5kIGNvbXBsZXRlIGFycmF5IGZvciBlYWNoIGl0ZW0uXG4gKlxuICogSWYgJ29iaicgaXMgYW4gT2JqZWN0IGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHBhc3NpbmdcbiAqIHRoZSB2YWx1ZSwga2V5LCBhbmQgY29tcGxldGUgb2JqZWN0IGZvciBlYWNoIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBvYmogVGhlIG9iamVjdCB0byBpdGVyYXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgY2FsbGJhY2sgdG8gaW52b2tlIGZvciBlYWNoIGl0ZW1cbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFthbGxPd25LZXlzID0gZmFsc2VdXG4gKiBAcmV0dXJucyB7YW55fVxuICovXG5mdW5jdGlvbiBmb3JFYWNoKG9iaiwgZm4sIHthbGxPd25LZXlzID0gZmFsc2V9ID0ge30pIHtcbiAgLy8gRG9uJ3QgYm90aGVyIGlmIG5vIHZhbHVlIHByb3ZpZGVkXG4gIGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBsZXQgaTtcbiAgbGV0IGw7XG5cbiAgLy8gRm9yY2UgYW4gYXJyYXkgaWYgbm90IGFscmVhZHkgc29tZXRoaW5nIGl0ZXJhYmxlXG4gIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0Jykge1xuICAgIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAgIG9iaiA9IFtvYmpdO1xuICB9XG5cbiAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgIC8vIEl0ZXJhdGUgb3ZlciBhcnJheSB2YWx1ZXNcbiAgICBmb3IgKGkgPSAwLCBsID0gb2JqLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgZm4uY2FsbChudWxsLCBvYmpbaV0sIGksIG9iaik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIEJ1ZmZlciBjaGVja1xuICAgIGlmIChpc0J1ZmZlcihvYmopKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSXRlcmF0ZSBvdmVyIG9iamVjdCBrZXlzXG4gICAgY29uc3Qga2V5cyA9IGFsbE93bktleXMgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopIDogT2JqZWN0LmtleXMob2JqKTtcbiAgICBjb25zdCBsZW4gPSBrZXlzLmxlbmd0aDtcbiAgICBsZXQga2V5O1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgZm4uY2FsbChudWxsLCBvYmpba2V5XSwga2V5LCBvYmopO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kS2V5KG9iaiwga2V5KSB7XG4gIGlmIChpc0J1ZmZlcihvYmopKXtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGtleSA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgbGV0IGkgPSBrZXlzLmxlbmd0aDtcbiAgbGV0IF9rZXk7XG4gIHdoaWxlIChpLS0gPiAwKSB7XG4gICAgX2tleSA9IGtleXNbaV07XG4gICAgaWYgKGtleSA9PT0gX2tleS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICByZXR1cm4gX2tleTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmNvbnN0IF9nbG9iYWwgPSAoKCkgPT4ge1xuICAvKmVzbGludCBuby11bmRlZjowKi9cbiAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gZ2xvYmFsVGhpcztcbiAgcmV0dXJuIHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IGdsb2JhbClcbn0pKCk7XG5cbmNvbnN0IGlzQ29udGV4dERlZmluZWQgPSAoY29udGV4dCkgPT4gIWlzVW5kZWZpbmVkKGNvbnRleHQpICYmIGNvbnRleHQgIT09IF9nbG9iYWw7XG5cbi8qKlxuICogQWNjZXB0cyB2YXJhcmdzIGV4cGVjdGluZyBlYWNoIGFyZ3VtZW50IHRvIGJlIGFuIG9iamVjdCwgdGhlblxuICogaW1tdXRhYmx5IG1lcmdlcyB0aGUgcHJvcGVydGllcyBvZiBlYWNoIG9iamVjdCBhbmQgcmV0dXJucyByZXN1bHQuXG4gKlxuICogV2hlbiBtdWx0aXBsZSBvYmplY3RzIGNvbnRhaW4gdGhlIHNhbWUga2V5IHRoZSBsYXRlciBvYmplY3QgaW5cbiAqIHRoZSBhcmd1bWVudHMgbGlzdCB3aWxsIHRha2UgcHJlY2VkZW5jZS5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgcmVzdWx0ID0gbWVyZ2Uoe2ZvbzogMTIzfSwge2ZvbzogNDU2fSk7XG4gKiBjb25zb2xlLmxvZyhyZXN1bHQuZm9vKTsgLy8gb3V0cHV0cyA0NTZcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmoxIE9iamVjdCB0byBtZXJnZVxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9IFJlc3VsdCBvZiBhbGwgbWVyZ2UgcHJvcGVydGllc1xuICovXG5mdW5jdGlvbiBtZXJnZSgvKiBvYmoxLCBvYmoyLCBvYmozLCAuLi4gKi8pIHtcbiAgY29uc3Qge2Nhc2VsZXNzLCBza2lwVW5kZWZpbmVkfSA9IGlzQ29udGV4dERlZmluZWQodGhpcykgJiYgdGhpcyB8fCB7fTtcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIGNvbnN0IGFzc2lnblZhbHVlID0gKHZhbCwga2V5KSA9PiB7XG4gICAgY29uc3QgdGFyZ2V0S2V5ID0gY2FzZWxlc3MgJiYgZmluZEtleShyZXN1bHQsIGtleSkgfHwga2V5O1xuICAgIGlmIChpc1BsYWluT2JqZWN0KHJlc3VsdFt0YXJnZXRLZXldKSAmJiBpc1BsYWluT2JqZWN0KHZhbCkpIHtcbiAgICAgIHJlc3VsdFt0YXJnZXRLZXldID0gbWVyZ2UocmVzdWx0W3RhcmdldEtleV0sIHZhbCk7XG4gICAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHZhbCkpIHtcbiAgICAgIHJlc3VsdFt0YXJnZXRLZXldID0gbWVyZ2Uoe30sIHZhbCk7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KHZhbCkpIHtcbiAgICAgIHJlc3VsdFt0YXJnZXRLZXldID0gdmFsLnNsaWNlKCk7XG4gICAgfSBlbHNlIGlmICghc2tpcFVuZGVmaW5lZCB8fCAhaXNVbmRlZmluZWQodmFsKSkge1xuICAgICAgcmVzdWx0W3RhcmdldEtleV0gPSB2YWw7XG4gICAgfVxuICB9XG5cbiAgZm9yIChsZXQgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgYXJndW1lbnRzW2ldICYmIGZvckVhY2goYXJndW1lbnRzW2ldLCBhc3NpZ25WYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBFeHRlbmRzIG9iamVjdCBhIGJ5IG11dGFibHkgYWRkaW5nIHRvIGl0IHRoZSBwcm9wZXJ0aWVzIG9mIG9iamVjdCBiLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhIFRoZSBvYmplY3QgdG8gYmUgZXh0ZW5kZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBiIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb21cbiAqIEBwYXJhbSB7T2JqZWN0fSB0aGlzQXJnIFRoZSBvYmplY3QgdG8gYmluZCBmdW5jdGlvbiB0b1xuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2FsbE93bktleXNdXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgcmVzdWx0aW5nIHZhbHVlIG9mIG9iamVjdCBhXG4gKi9cbmNvbnN0IGV4dGVuZCA9IChhLCBiLCB0aGlzQXJnLCB7YWxsT3duS2V5c309IHt9KSA9PiB7XG4gIGZvckVhY2goYiwgKHZhbCwga2V5KSA9PiB7XG4gICAgaWYgKHRoaXNBcmcgJiYgaXNGdW5jdGlvbih2YWwpKSB7XG4gICAgICBhW2tleV0gPSBiaW5kKHZhbCwgdGhpc0FyZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFba2V5XSA9IHZhbDtcbiAgICB9XG4gIH0sIHthbGxPd25LZXlzfSk7XG4gIHJldHVybiBhO1xufVxuXG4vKipcbiAqIFJlbW92ZSBieXRlIG9yZGVyIG1hcmtlci4gVGhpcyBjYXRjaGVzIEVGIEJCIEJGICh0aGUgVVRGLTggQk9NKVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50IHdpdGggQk9NXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gY29udGVudCB2YWx1ZSB3aXRob3V0IEJPTVxuICovXG5jb25zdCBzdHJpcEJPTSA9IChjb250ZW50KSA9PiB7XG4gIGlmIChjb250ZW50LmNoYXJDb2RlQXQoMCkgPT09IDB4RkVGRikge1xuICAgIGNvbnRlbnQgPSBjb250ZW50LnNsaWNlKDEpO1xuICB9XG4gIHJldHVybiBjb250ZW50O1xufVxuXG4vKipcbiAqIEluaGVyaXQgdGhlIHByb3RvdHlwZSBtZXRob2RzIGZyb20gb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlclxuICogQHBhcmFtIHtmdW5jdGlvbn0gY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHN1cGVyQ29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBbcHJvcHNdXG4gKiBAcGFyYW0ge29iamVjdH0gW2Rlc2NyaXB0b3JzXVxuICpcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5jb25zdCBpbmhlcml0cyA9IChjb25zdHJ1Y3Rvciwgc3VwZXJDb25zdHJ1Y3RvciwgcHJvcHMsIGRlc2NyaXB0b3JzKSA9PiB7XG4gIGNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIGRlc2NyaXB0b3JzKTtcbiAgY29uc3RydWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY29uc3RydWN0b3I7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb25zdHJ1Y3RvciwgJ3N1cGVyJywge1xuICAgIHZhbHVlOiBzdXBlckNvbnN0cnVjdG9yLnByb3RvdHlwZVxuICB9KTtcbiAgcHJvcHMgJiYgT2JqZWN0LmFzc2lnbihjb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3BzKTtcbn1cblxuLyoqXG4gKiBSZXNvbHZlIG9iamVjdCB3aXRoIGRlZXAgcHJvdG90eXBlIGNoYWluIHRvIGEgZmxhdCBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2VPYmogc291cmNlIG9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IFtkZXN0T2JqXVxuICogQHBhcmFtIHtGdW5jdGlvbnxCb29sZWFufSBbZmlsdGVyXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3Byb3BGaWx0ZXJdXG4gKlxuICogQHJldHVybnMge09iamVjdH1cbiAqL1xuY29uc3QgdG9GbGF0T2JqZWN0ID0gKHNvdXJjZU9iaiwgZGVzdE9iaiwgZmlsdGVyLCBwcm9wRmlsdGVyKSA9PiB7XG4gIGxldCBwcm9wcztcbiAgbGV0IGk7XG4gIGxldCBwcm9wO1xuICBjb25zdCBtZXJnZWQgPSB7fTtcblxuICBkZXN0T2JqID0gZGVzdE9iaiB8fCB7fTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVxLW51bGwsZXFlcWVxXG4gIGlmIChzb3VyY2VPYmogPT0gbnVsbCkgcmV0dXJuIGRlc3RPYmo7XG5cbiAgZG8ge1xuICAgIHByb3BzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoc291cmNlT2JqKTtcbiAgICBpID0gcHJvcHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0gPiAwKSB7XG4gICAgICBwcm9wID0gcHJvcHNbaV07XG4gICAgICBpZiAoKCFwcm9wRmlsdGVyIHx8IHByb3BGaWx0ZXIocHJvcCwgc291cmNlT2JqLCBkZXN0T2JqKSkgJiYgIW1lcmdlZFtwcm9wXSkge1xuICAgICAgICBkZXN0T2JqW3Byb3BdID0gc291cmNlT2JqW3Byb3BdO1xuICAgICAgICBtZXJnZWRbcHJvcF0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBzb3VyY2VPYmogPSBmaWx0ZXIgIT09IGZhbHNlICYmIGdldFByb3RvdHlwZU9mKHNvdXJjZU9iaik7XG4gIH0gd2hpbGUgKHNvdXJjZU9iaiAmJiAoIWZpbHRlciB8fCBmaWx0ZXIoc291cmNlT2JqLCBkZXN0T2JqKSkgJiYgc291cmNlT2JqICE9PSBPYmplY3QucHJvdG90eXBlKTtcblxuICByZXR1cm4gZGVzdE9iajtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgYSBzdHJpbmcgZW5kcyB3aXRoIHRoZSBjaGFyYWN0ZXJzIG9mIGEgc3BlY2lmaWVkIHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzZWFyY2hTdHJpbmdcbiAqIEBwYXJhbSB7TnVtYmVyfSBbcG9zaXRpb249IDBdXG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmNvbnN0IGVuZHNXaXRoID0gKHN0ciwgc2VhcmNoU3RyaW5nLCBwb3NpdGlvbikgPT4ge1xuICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgaWYgKHBvc2l0aW9uID09PSB1bmRlZmluZWQgfHwgcG9zaXRpb24gPiBzdHIubGVuZ3RoKSB7XG4gICAgcG9zaXRpb24gPSBzdHIubGVuZ3RoO1xuICB9XG4gIHBvc2l0aW9uIC09IHNlYXJjaFN0cmluZy5sZW5ndGg7XG4gIGNvbnN0IGxhc3RJbmRleCA9IHN0ci5pbmRleE9mKHNlYXJjaFN0cmluZywgcG9zaXRpb24pO1xuICByZXR1cm4gbGFzdEluZGV4ICE9PSAtMSAmJiBsYXN0SW5kZXggPT09IHBvc2l0aW9uO1xufVxuXG5cbi8qKlxuICogUmV0dXJucyBuZXcgYXJyYXkgZnJvbSBhcnJheSBsaWtlIG9iamVjdCBvciBudWxsIGlmIGZhaWxlZFxuICpcbiAqIEBwYXJhbSB7Kn0gW3RoaW5nXVxuICpcbiAqIEByZXR1cm5zIHs/QXJyYXl9XG4gKi9cbmNvbnN0IHRvQXJyYXkgPSAodGhpbmcpID0+IHtcbiAgaWYgKCF0aGluZykgcmV0dXJuIG51bGw7XG4gIGlmIChpc0FycmF5KHRoaW5nKSkgcmV0dXJuIHRoaW5nO1xuICBsZXQgaSA9IHRoaW5nLmxlbmd0aDtcbiAgaWYgKCFpc051bWJlcihpKSkgcmV0dXJuIG51bGw7XG4gIGNvbnN0IGFyciA9IG5ldyBBcnJheShpKTtcbiAgd2hpbGUgKGktLSA+IDApIHtcbiAgICBhcnJbaV0gPSB0aGluZ1tpXTtcbiAgfVxuICByZXR1cm4gYXJyO1xufVxuXG4vKipcbiAqIENoZWNraW5nIGlmIHRoZSBVaW50OEFycmF5IGV4aXN0cyBhbmQgaWYgaXQgZG9lcywgaXQgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgY2hlY2tzIGlmIHRoZVxuICogdGhpbmcgcGFzc2VkIGluIGlzIGFuIGluc3RhbmNlIG9mIFVpbnQ4QXJyYXlcbiAqXG4gKiBAcGFyYW0ge1R5cGVkQXJyYXl9XG4gKlxuICogQHJldHVybnMge0FycmF5fVxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuY29uc3QgaXNUeXBlZEFycmF5ID0gKFR5cGVkQXJyYXkgPT4ge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuICByZXR1cm4gdGhpbmcgPT4ge1xuICAgIHJldHVybiBUeXBlZEFycmF5ICYmIHRoaW5nIGluc3RhbmNlb2YgVHlwZWRBcnJheTtcbiAgfTtcbn0pKHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyAmJiBnZXRQcm90b3R5cGVPZihVaW50OEFycmF5KSk7XG5cbi8qKlxuICogRm9yIGVhY2ggZW50cnkgaW4gdGhlIG9iamVjdCwgY2FsbCB0aGUgZnVuY3Rpb24gd2l0aCB0aGUga2V5IGFuZCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdDxhbnksIGFueT59IG9iaiAtIFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSBUaGUgZnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCBlbnRyeS5cbiAqXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuY29uc3QgZm9yRWFjaEVudHJ5ID0gKG9iaiwgZm4pID0+IHtcbiAgY29uc3QgZ2VuZXJhdG9yID0gb2JqICYmIG9ialtpdGVyYXRvcl07XG5cbiAgY29uc3QgX2l0ZXJhdG9yID0gZ2VuZXJhdG9yLmNhbGwob2JqKTtcblxuICBsZXQgcmVzdWx0O1xuXG4gIHdoaWxlICgocmVzdWx0ID0gX2l0ZXJhdG9yLm5leHQoKSkgJiYgIXJlc3VsdC5kb25lKSB7XG4gICAgY29uc3QgcGFpciA9IHJlc3VsdC52YWx1ZTtcbiAgICBmbi5jYWxsKG9iaiwgcGFpclswXSwgcGFpclsxXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBJdCB0YWtlcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBhbmQgYSBzdHJpbmcsIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIGFsbCB0aGUgbWF0Y2hlc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWdFeHAgLSBUaGUgcmVndWxhciBleHByZXNzaW9uIHRvIG1hdGNoIGFnYWluc3QuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIC0gVGhlIHN0cmluZyB0byBzZWFyY2guXG4gKlxuICogQHJldHVybnMge0FycmF5PGJvb2xlYW4+fVxuICovXG5jb25zdCBtYXRjaEFsbCA9IChyZWdFeHAsIHN0cikgPT4ge1xuICBsZXQgbWF0Y2hlcztcbiAgY29uc3QgYXJyID0gW107XG5cbiAgd2hpbGUgKChtYXRjaGVzID0gcmVnRXhwLmV4ZWMoc3RyKSkgIT09IG51bGwpIHtcbiAgICBhcnIucHVzaChtYXRjaGVzKTtcbiAgfVxuXG4gIHJldHVybiBhcnI7XG59XG5cbi8qIENoZWNraW5nIGlmIHRoZSBraW5kT2ZUZXN0IGZ1bmN0aW9uIHJldHVybnMgdHJ1ZSB3aGVuIHBhc3NlZCBhbiBIVE1MRm9ybUVsZW1lbnQuICovXG5jb25zdCBpc0hUTUxGb3JtID0ga2luZE9mVGVzdCgnSFRNTEZvcm1FbGVtZW50Jyk7XG5cbmNvbnN0IHRvQ2FtZWxDYXNlID0gc3RyID0+IHtcbiAgcmV0dXJuIHN0ci50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1stX1xcc10oW2EtelxcZF0pKFxcdyopL2csXG4gICAgZnVuY3Rpb24gcmVwbGFjZXIobSwgcDEsIHAyKSB7XG4gICAgICByZXR1cm4gcDEudG9VcHBlckNhc2UoKSArIHAyO1xuICAgIH1cbiAgKTtcbn07XG5cbi8qIENyZWF0aW5nIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGNoZWNrIGlmIGFuIG9iamVjdCBoYXMgYSBwcm9wZXJ0eS4gKi9cbmNvbnN0IGhhc093blByb3BlcnR5ID0gKCh7aGFzT3duUHJvcGVydHl9KSA9PiAob2JqLCBwcm9wKSA9PiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpKE9iamVjdC5wcm90b3R5cGUpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgUmVnRXhwIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBSZWdFeHAgb2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNSZWdFeHAgPSBraW5kT2ZUZXN0KCdSZWdFeHAnKTtcblxuY29uc3QgcmVkdWNlRGVzY3JpcHRvcnMgPSAob2JqLCByZWR1Y2VyKSA9PiB7XG4gIGNvbnN0IGRlc2NyaXB0b3JzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMob2JqKTtcbiAgY29uc3QgcmVkdWNlZERlc2NyaXB0b3JzID0ge307XG5cbiAgZm9yRWFjaChkZXNjcmlwdG9ycywgKGRlc2NyaXB0b3IsIG5hbWUpID0+IHtcbiAgICBsZXQgcmV0O1xuICAgIGlmICgocmV0ID0gcmVkdWNlcihkZXNjcmlwdG9yLCBuYW1lLCBvYmopKSAhPT0gZmFsc2UpIHtcbiAgICAgIHJlZHVjZWREZXNjcmlwdG9yc1tuYW1lXSA9IHJldCB8fCBkZXNjcmlwdG9yO1xuICAgIH1cbiAgfSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMob2JqLCByZWR1Y2VkRGVzY3JpcHRvcnMpO1xufVxuXG4vKipcbiAqIE1ha2VzIGFsbCBtZXRob2RzIHJlYWQtb25seVxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICovXG5cbmNvbnN0IGZyZWV6ZU1ldGhvZHMgPSAob2JqKSA9PiB7XG4gIHJlZHVjZURlc2NyaXB0b3JzKG9iaiwgKGRlc2NyaXB0b3IsIG5hbWUpID0+IHtcbiAgICAvLyBza2lwIHJlc3RyaWN0ZWQgcHJvcHMgaW4gc3RyaWN0IG1vZGVcbiAgICBpZiAoaXNGdW5jdGlvbihvYmopICYmIFsnYXJndW1lbnRzJywgJ2NhbGxlcicsICdjYWxsZWUnXS5pbmRleE9mKG5hbWUpICE9PSAtMSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IHZhbHVlID0gb2JqW25hbWVdO1xuXG4gICAgaWYgKCFpc0Z1bmN0aW9uKHZhbHVlKSkgcmV0dXJuO1xuXG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZmFsc2U7XG5cbiAgICBpZiAoJ3dyaXRhYmxlJyBpbiBkZXNjcmlwdG9yKSB7XG4gICAgICBkZXNjcmlwdG9yLndyaXRhYmxlID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFkZXNjcmlwdG9yLnNldCkge1xuICAgICAgZGVzY3JpcHRvci5zZXQgPSAoKSA9PiB7XG4gICAgICAgIHRocm93IEVycm9yKCdDYW4gbm90IHJld3JpdGUgcmVhZC1vbmx5IG1ldGhvZCBcXCcnICsgbmFtZSArICdcXCcnKTtcbiAgICAgIH07XG4gICAgfVxuICB9KTtcbn1cblxuY29uc3QgdG9PYmplY3RTZXQgPSAoYXJyYXlPclN0cmluZywgZGVsaW1pdGVyKSA9PiB7XG4gIGNvbnN0IG9iaiA9IHt9O1xuXG4gIGNvbnN0IGRlZmluZSA9IChhcnIpID0+IHtcbiAgICBhcnIuZm9yRWFjaCh2YWx1ZSA9PiB7XG4gICAgICBvYmpbdmFsdWVdID0gdHJ1ZTtcbiAgICB9KTtcbiAgfVxuXG4gIGlzQXJyYXkoYXJyYXlPclN0cmluZykgPyBkZWZpbmUoYXJyYXlPclN0cmluZykgOiBkZWZpbmUoU3RyaW5nKGFycmF5T3JTdHJpbmcpLnNwbGl0KGRlbGltaXRlcikpO1xuXG4gIHJldHVybiBvYmo7XG59XG5cbmNvbnN0IG5vb3AgPSAoKSA9PiB7fVxuXG5jb25zdCB0b0Zpbml0ZU51bWJlciA9ICh2YWx1ZSwgZGVmYXVsdFZhbHVlKSA9PiB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIE51bWJlci5pc0Zpbml0ZSh2YWx1ZSA9ICt2YWx1ZSkgPyB2YWx1ZSA6IGRlZmF1bHRWYWx1ZTtcbn1cblxuXG5cbi8qKlxuICogSWYgdGhlIHRoaW5nIGlzIGEgRm9ybURhdGEgb2JqZWN0LCByZXR1cm4gdHJ1ZSwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cbiAqXG4gKiBAcGFyYW0ge3Vua25vd259IHRoaW5nIC0gVGhlIHRoaW5nIHRvIGNoZWNrLlxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc1NwZWNDb21wbGlhbnRGb3JtKHRoaW5nKSB7XG4gIHJldHVybiAhISh0aGluZyAmJiBpc0Z1bmN0aW9uKHRoaW5nLmFwcGVuZCkgJiYgdGhpbmdbdG9TdHJpbmdUYWddID09PSAnRm9ybURhdGEnICYmIHRoaW5nW2l0ZXJhdG9yXSk7XG59XG5cbmNvbnN0IHRvSlNPTk9iamVjdCA9IChvYmopID0+IHtcbiAgY29uc3Qgc3RhY2sgPSBuZXcgQXJyYXkoMTApO1xuXG4gIGNvbnN0IHZpc2l0ID0gKHNvdXJjZSwgaSkgPT4ge1xuXG4gICAgaWYgKGlzT2JqZWN0KHNvdXJjZSkpIHtcbiAgICAgIGlmIChzdGFjay5pbmRleE9mKHNvdXJjZSkgPj0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vQnVmZmVyIGNoZWNrXG4gICAgICBpZiAoaXNCdWZmZXIoc291cmNlKSkge1xuICAgICAgICByZXR1cm4gc291cmNlO1xuICAgICAgfVxuXG4gICAgICBpZighKCd0b0pTT04nIGluIHNvdXJjZSkpIHtcbiAgICAgICAgc3RhY2tbaV0gPSBzb3VyY2U7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGlzQXJyYXkoc291cmNlKSA/IFtdIDoge307XG5cbiAgICAgICAgZm9yRWFjaChzb3VyY2UsICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgY29uc3QgcmVkdWNlZFZhbHVlID0gdmlzaXQodmFsdWUsIGkgKyAxKTtcbiAgICAgICAgICAhaXNVbmRlZmluZWQocmVkdWNlZFZhbHVlKSAmJiAodGFyZ2V0W2tleV0gPSByZWR1Y2VkVmFsdWUpO1xuICAgICAgICB9KTtcblxuICAgICAgICBzdGFja1tpXSA9IHVuZGVmaW5lZDtcblxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzb3VyY2U7XG4gIH1cblxuICByZXR1cm4gdmlzaXQob2JqLCAwKTtcbn1cblxuY29uc3QgaXNBc3luY0ZuID0ga2luZE9mVGVzdCgnQXN5bmNGdW5jdGlvbicpO1xuXG5jb25zdCBpc1RoZW5hYmxlID0gKHRoaW5nKSA9PlxuICB0aGluZyAmJiAoaXNPYmplY3QodGhpbmcpIHx8IGlzRnVuY3Rpb24odGhpbmcpKSAmJiBpc0Z1bmN0aW9uKHRoaW5nLnRoZW4pICYmIGlzRnVuY3Rpb24odGhpbmcuY2F0Y2gpO1xuXG4vLyBvcmlnaW5hbCBjb2RlXG4vLyBodHRwczovL2dpdGh1Yi5jb20vRGlnaXRhbEJyYWluSlMvQXhpb3NQcm9taXNlL2Jsb2IvMTZkZWFiMTM3MTBlYzA5Nzc5OTIyMTMxZjNmYTU5NTQzMjBmODNhYi9saWIvdXRpbHMuanMjTDExLUwzNFxuXG5jb25zdCBfc2V0SW1tZWRpYXRlID0gKChzZXRJbW1lZGlhdGVTdXBwb3J0ZWQsIHBvc3RNZXNzYWdlU3VwcG9ydGVkKSA9PiB7XG4gIGlmIChzZXRJbW1lZGlhdGVTdXBwb3J0ZWQpIHtcbiAgICByZXR1cm4gc2V0SW1tZWRpYXRlO1xuICB9XG5cbiAgcmV0dXJuIHBvc3RNZXNzYWdlU3VwcG9ydGVkID8gKCh0b2tlbiwgY2FsbGJhY2tzKSA9PiB7XG4gICAgX2dsb2JhbC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCAoe3NvdXJjZSwgZGF0YX0pID0+IHtcbiAgICAgIGlmIChzb3VyY2UgPT09IF9nbG9iYWwgJiYgZGF0YSA9PT0gdG9rZW4pIHtcbiAgICAgICAgY2FsbGJhY2tzLmxlbmd0aCAmJiBjYWxsYmFja3Muc2hpZnQoKSgpO1xuICAgICAgfVxuICAgIH0sIGZhbHNlKTtcblxuICAgIHJldHVybiAoY2IpID0+IHtcbiAgICAgIGNhbGxiYWNrcy5wdXNoKGNiKTtcbiAgICAgIF9nbG9iYWwucG9zdE1lc3NhZ2UodG9rZW4sIFwiKlwiKTtcbiAgICB9XG4gIH0pKGBheGlvc0Ake01hdGgucmFuZG9tKCl9YCwgW10pIDogKGNiKSA9PiBzZXRUaW1lb3V0KGNiKTtcbn0pKFxuICB0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nLFxuICBpc0Z1bmN0aW9uKF9nbG9iYWwucG9zdE1lc3NhZ2UpXG4pO1xuXG5jb25zdCBhc2FwID0gdHlwZW9mIHF1ZXVlTWljcm90YXNrICE9PSAndW5kZWZpbmVkJyA/XG4gIHF1ZXVlTWljcm90YXNrLmJpbmQoX2dsb2JhbCkgOiAoIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLm5leHRUaWNrIHx8IF9zZXRJbW1lZGlhdGUpO1xuXG4vLyAqKioqKioqKioqKioqKioqKioqKipcblxuXG5jb25zdCBpc0l0ZXJhYmxlID0gKHRoaW5nKSA9PiB0aGluZyAhPSBudWxsICYmIGlzRnVuY3Rpb24odGhpbmdbaXRlcmF0b3JdKTtcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGlzQXJyYXksXG4gIGlzQXJyYXlCdWZmZXIsXG4gIGlzQnVmZmVyLFxuICBpc0Zvcm1EYXRhLFxuICBpc0FycmF5QnVmZmVyVmlldyxcbiAgaXNTdHJpbmcsXG4gIGlzTnVtYmVyLFxuICBpc0Jvb2xlYW4sXG4gIGlzT2JqZWN0LFxuICBpc1BsYWluT2JqZWN0LFxuICBpc0VtcHR5T2JqZWN0LFxuICBpc1JlYWRhYmxlU3RyZWFtLFxuICBpc1JlcXVlc3QsXG4gIGlzUmVzcG9uc2UsXG4gIGlzSGVhZGVycyxcbiAgaXNVbmRlZmluZWQsXG4gIGlzRGF0ZSxcbiAgaXNGaWxlLFxuICBpc0Jsb2IsXG4gIGlzUmVnRXhwLFxuICBpc0Z1bmN0aW9uLFxuICBpc1N0cmVhbSxcbiAgaXNVUkxTZWFyY2hQYXJhbXMsXG4gIGlzVHlwZWRBcnJheSxcbiAgaXNGaWxlTGlzdCxcbiAgZm9yRWFjaCxcbiAgbWVyZ2UsXG4gIGV4dGVuZCxcbiAgdHJpbSxcbiAgc3RyaXBCT00sXG4gIGluaGVyaXRzLFxuICB0b0ZsYXRPYmplY3QsXG4gIGtpbmRPZixcbiAga2luZE9mVGVzdCxcbiAgZW5kc1dpdGgsXG4gIHRvQXJyYXksXG4gIGZvckVhY2hFbnRyeSxcbiAgbWF0Y2hBbGwsXG4gIGlzSFRNTEZvcm0sXG4gIGhhc093blByb3BlcnR5LFxuICBoYXNPd25Qcm9wOiBoYXNPd25Qcm9wZXJ0eSwgLy8gYW4gYWxpYXMgdG8gYXZvaWQgRVNMaW50IG5vLXByb3RvdHlwZS1idWlsdGlucyBkZXRlY3Rpb25cbiAgcmVkdWNlRGVzY3JpcHRvcnMsXG4gIGZyZWV6ZU1ldGhvZHMsXG4gIHRvT2JqZWN0U2V0LFxuICB0b0NhbWVsQ2FzZSxcbiAgbm9vcCxcbiAgdG9GaW5pdGVOdW1iZXIsXG4gIGZpbmRLZXksXG4gIGdsb2JhbDogX2dsb2JhbCxcbiAgaXNDb250ZXh0RGVmaW5lZCxcbiAgaXNTcGVjQ29tcGxpYW50Rm9ybSxcbiAgdG9KU09OT2JqZWN0LFxuICBpc0FzeW5jRm4sXG4gIGlzVGhlbmFibGUsXG4gIHNldEltbWVkaWF0ZTogX3NldEltbWVkaWF0ZSxcbiAgYXNhcCxcbiAgaXNJdGVyYWJsZVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4uL3V0aWxzLmpzJztcblxuLyoqXG4gKiBDcmVhdGUgYW4gRXJyb3Igd2l0aCB0aGUgc3BlY2lmaWVkIG1lc3NhZ2UsIGNvbmZpZywgZXJyb3IgY29kZSwgcmVxdWVzdCBhbmQgcmVzcG9uc2UuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgVGhlIGVycm9yIG1lc3NhZ2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvZGVdIFRoZSBlcnJvciBjb2RlIChmb3IgZXhhbXBsZSwgJ0VDT05OQUJPUlRFRCcpLlxuICogQHBhcmFtIHtPYmplY3R9IFtjb25maWddIFRoZSBjb25maWcuXG4gKiBAcGFyYW0ge09iamVjdH0gW3JlcXVlc3RdIFRoZSByZXF1ZXN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXNwb25zZV0gVGhlIHJlc3BvbnNlLlxuICpcbiAqIEByZXR1cm5zIHtFcnJvcn0gVGhlIGNyZWF0ZWQgZXJyb3IuXG4gKi9cbmZ1bmN0aW9uIEF4aW9zRXJyb3IobWVzc2FnZSwgY29kZSwgY29uZmlnLCByZXF1ZXN0LCByZXNwb25zZSkge1xuICBFcnJvci5jYWxsKHRoaXMpO1xuXG4gIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuc3RhY2sgPSAobmV3IEVycm9yKCkpLnN0YWNrO1xuICB9XG5cbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgdGhpcy5uYW1lID0gJ0F4aW9zRXJyb3InO1xuICBjb2RlICYmICh0aGlzLmNvZGUgPSBjb2RlKTtcbiAgY29uZmlnICYmICh0aGlzLmNvbmZpZyA9IGNvbmZpZyk7XG4gIHJlcXVlc3QgJiYgKHRoaXMucmVxdWVzdCA9IHJlcXVlc3QpO1xuICBpZiAocmVzcG9uc2UpIHtcbiAgICB0aGlzLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgdGhpcy5zdGF0dXMgPSByZXNwb25zZS5zdGF0dXMgPyByZXNwb25zZS5zdGF0dXMgOiBudWxsO1xuICB9XG59XG5cbnV0aWxzLmluaGVyaXRzKEF4aW9zRXJyb3IsIEVycm9yLCB7XG4gIHRvSlNPTjogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICAvLyBTdGFuZGFyZFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgLy8gTWljcm9zb2Z0XG4gICAgICBkZXNjcmlwdGlvbjogdGhpcy5kZXNjcmlwdGlvbixcbiAgICAgIG51bWJlcjogdGhpcy5udW1iZXIsXG4gICAgICAvLyBNb3ppbGxhXG4gICAgICBmaWxlTmFtZTogdGhpcy5maWxlTmFtZSxcbiAgICAgIGxpbmVOdW1iZXI6IHRoaXMubGluZU51bWJlcixcbiAgICAgIGNvbHVtbk51bWJlcjogdGhpcy5jb2x1bW5OdW1iZXIsXG4gICAgICBzdGFjazogdGhpcy5zdGFjayxcbiAgICAgIC8vIEF4aW9zXG4gICAgICBjb25maWc6IHV0aWxzLnRvSlNPTk9iamVjdCh0aGlzLmNvbmZpZyksXG4gICAgICBjb2RlOiB0aGlzLmNvZGUsXG4gICAgICBzdGF0dXM6IHRoaXMuc3RhdHVzXG4gICAgfTtcbiAgfVxufSk7XG5cbmNvbnN0IHByb3RvdHlwZSA9IEF4aW9zRXJyb3IucHJvdG90eXBlO1xuY29uc3QgZGVzY3JpcHRvcnMgPSB7fTtcblxuW1xuICAnRVJSX0JBRF9PUFRJT05fVkFMVUUnLFxuICAnRVJSX0JBRF9PUFRJT04nLFxuICAnRUNPTk5BQk9SVEVEJyxcbiAgJ0VUSU1FRE9VVCcsXG4gICdFUlJfTkVUV09SSycsXG4gICdFUlJfRlJfVE9PX01BTllfUkVESVJFQ1RTJyxcbiAgJ0VSUl9ERVBSRUNBVEVEJyxcbiAgJ0VSUl9CQURfUkVTUE9OU0UnLFxuICAnRVJSX0JBRF9SRVFVRVNUJyxcbiAgJ0VSUl9DQU5DRUxFRCcsXG4gICdFUlJfTk9UX1NVUFBPUlQnLFxuICAnRVJSX0lOVkFMSURfVVJMJ1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbl0uZm9yRWFjaChjb2RlID0+IHtcbiAgZGVzY3JpcHRvcnNbY29kZV0gPSB7dmFsdWU6IGNvZGV9O1xufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEF4aW9zRXJyb3IsIGRlc2NyaXB0b3JzKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90b3R5cGUsICdpc0F4aW9zRXJyb3InLCB7dmFsdWU6IHRydWV9KTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbkF4aW9zRXJyb3IuZnJvbSA9IChlcnJvciwgY29kZSwgY29uZmlnLCByZXF1ZXN0LCByZXNwb25zZSwgY3VzdG9tUHJvcHMpID0+IHtcbiAgY29uc3QgYXhpb3NFcnJvciA9IE9iamVjdC5jcmVhdGUocHJvdG90eXBlKTtcblxuICB1dGlscy50b0ZsYXRPYmplY3QoZXJyb3IsIGF4aW9zRXJyb3IsIGZ1bmN0aW9uIGZpbHRlcihvYmopIHtcbiAgICByZXR1cm4gb2JqICE9PSBFcnJvci5wcm90b3R5cGU7XG4gIH0sIHByb3AgPT4ge1xuICAgIHJldHVybiBwcm9wICE9PSAnaXNBeGlvc0Vycm9yJztcbiAgfSk7XG5cbiAgY29uc3QgbXNnID0gZXJyb3IgJiYgZXJyb3IubWVzc2FnZSA/IGVycm9yLm1lc3NhZ2UgOiAnRXJyb3InO1xuXG4gIC8vIFByZWZlciBleHBsaWNpdCBjb2RlOyBvdGhlcndpc2UgY29weSB0aGUgbG93LWxldmVsIGVycm9yJ3MgY29kZSAoZS5nLiBFQ09OTlJFRlVTRUQpXG4gIGNvbnN0IGVyckNvZGUgPSBjb2RlID09IG51bGwgJiYgZXJyb3IgPyBlcnJvci5jb2RlIDogY29kZTtcbiAgQXhpb3NFcnJvci5jYWxsKGF4aW9zRXJyb3IsIG1zZywgZXJyQ29kZSwgY29uZmlnLCByZXF1ZXN0LCByZXNwb25zZSk7XG5cbiAgLy8gQ2hhaW4gdGhlIG9yaWdpbmFsIGVycm9yIG9uIHRoZSBzdGFuZGFyZCBmaWVsZDsgbm9uLWVudW1lcmFibGUgdG8gYXZvaWQgSlNPTiBub2lzZVxuICBpZiAoZXJyb3IgJiYgYXhpb3NFcnJvci5jYXVzZSA9PSBudWxsKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGF4aW9zRXJyb3IsICdjYXVzZScsIHsgdmFsdWU6IGVycm9yLCBjb25maWd1cmFibGU6IHRydWUgfSk7XG4gIH1cblxuICBheGlvc0Vycm9yLm5hbWUgPSAoZXJyb3IgJiYgZXJyb3IubmFtZSkgfHwgJ0Vycm9yJztcblxuICBjdXN0b21Qcm9wcyAmJiBPYmplY3QuYXNzaWduKGF4aW9zRXJyb3IsIGN1c3RvbVByb3BzKTtcblxuICByZXR1cm4gYXhpb3NFcnJvcjtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEF4aW9zRXJyb3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB1dGlscyBmcm9tICcuLi91dGlscy5qcyc7XG5pbXBvcnQgQXhpb3NFcnJvciBmcm9tICcuLi9jb3JlL0F4aW9zRXJyb3IuanMnO1xuLy8gdGVtcG9yYXJ5IGhvdGZpeCB0byBhdm9pZCBjaXJjdWxhciByZWZlcmVuY2VzIHVudGlsIEF4aW9zVVJMU2VhcmNoUGFyYW1zIGlzIHJlZmFjdG9yZWRcbmltcG9ydCBQbGF0Zm9ybUZvcm1EYXRhIGZyb20gJy4uL3BsYXRmb3JtL25vZGUvY2xhc3Nlcy9Gb3JtRGF0YS5qcyc7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgZ2l2ZW4gdGhpbmcgaXMgYSBhcnJheSBvciBqcyBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRoaW5nIC0gVGhlIG9iamVjdCBvciBhcnJheSB0byBiZSB2aXNpdGVkLlxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc1Zpc2l0YWJsZSh0aGluZykge1xuICByZXR1cm4gdXRpbHMuaXNQbGFpbk9iamVjdCh0aGluZykgfHwgdXRpbHMuaXNBcnJheSh0aGluZyk7XG59XG5cbi8qKlxuICogSXQgcmVtb3ZlcyB0aGUgYnJhY2tldHMgZnJvbSB0aGUgZW5kIG9mIGEgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFRoZSBrZXkgb2YgdGhlIHBhcmFtZXRlci5cbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUga2V5IHdpdGhvdXQgdGhlIGJyYWNrZXRzLlxuICovXG5mdW5jdGlvbiByZW1vdmVCcmFja2V0cyhrZXkpIHtcbiAgcmV0dXJuIHV0aWxzLmVuZHNXaXRoKGtleSwgJ1tdJykgPyBrZXkuc2xpY2UoMCwgLTIpIDoga2V5O1xufVxuXG4vKipcbiAqIEl0IHRha2VzIGEgcGF0aCwgYSBrZXksIGFuZCBhIGJvb2xlYW4sIGFuZCByZXR1cm5zIGEgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggLSBUaGUgcGF0aCB0byB0aGUgY3VycmVudCBrZXkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gVGhlIGtleSBvZiB0aGUgY3VycmVudCBvYmplY3QgYmVpbmcgaXRlcmF0ZWQgb3Zlci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkb3RzIC0gSWYgdHJ1ZSwgdGhlIGtleSB3aWxsIGJlIHJlbmRlcmVkIHdpdGggZG90cyBpbnN0ZWFkIG9mIGJyYWNrZXRzLlxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBwYXRoIHRvIHRoZSBjdXJyZW50IGtleS5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyS2V5KHBhdGgsIGtleSwgZG90cykge1xuICBpZiAoIXBhdGgpIHJldHVybiBrZXk7XG4gIHJldHVybiBwYXRoLmNvbmNhdChrZXkpLm1hcChmdW5jdGlvbiBlYWNoKHRva2VuLCBpKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgdG9rZW4gPSByZW1vdmVCcmFja2V0cyh0b2tlbik7XG4gICAgcmV0dXJuICFkb3RzICYmIGkgPyAnWycgKyB0b2tlbiArICddJyA6IHRva2VuO1xuICB9KS5qb2luKGRvdHMgPyAnLicgOiAnJyk7XG59XG5cbi8qKlxuICogSWYgdGhlIGFycmF5IGlzIGFuIGFycmF5IGFuZCBub25lIG9mIGl0cyBlbGVtZW50cyBhcmUgdmlzaXRhYmxlLCB0aGVuIGl0J3MgYSBmbGF0IGFycmF5LlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gYXJyIC0gVGhlIGFycmF5IHRvIGNoZWNrXG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzRmxhdEFycmF5KGFycikge1xuICByZXR1cm4gdXRpbHMuaXNBcnJheShhcnIpICYmICFhcnIuc29tZShpc1Zpc2l0YWJsZSk7XG59XG5cbmNvbnN0IHByZWRpY2F0ZXMgPSB1dGlscy50b0ZsYXRPYmplY3QodXRpbHMsIHt9LCBudWxsLCBmdW5jdGlvbiBmaWx0ZXIocHJvcCkge1xuICByZXR1cm4gL15pc1tBLVpdLy50ZXN0KHByb3ApO1xufSk7XG5cbi8qKlxuICogQ29udmVydCBhIGRhdGEgb2JqZWN0IHRvIEZvcm1EYXRhXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHs/T2JqZWN0fSBbZm9ybURhdGFdXG4gKiBAcGFyYW0gez9PYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMudmlzaXRvcl1cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubWV0YVRva2VucyA9IHRydWVdXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmRvdHMgPSBmYWxzZV1cbiAqIEBwYXJhbSB7P0Jvb2xlYW59IFtvcHRpb25zLmluZGV4ZXMgPSBmYWxzZV1cbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICoqL1xuXG4vKipcbiAqIEl0IGNvbnZlcnRzIGFuIG9iamVjdCBpbnRvIGEgRm9ybURhdGEgb2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3Q8YW55LCBhbnk+fSBvYmogLSBUaGUgb2JqZWN0IHRvIGNvbnZlcnQgdG8gZm9ybSBkYXRhLlxuICogQHBhcmFtIHtzdHJpbmd9IGZvcm1EYXRhIC0gVGhlIEZvcm1EYXRhIG9iamVjdCB0byBhcHBlbmQgdG8uXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsIGFueT59IG9wdGlvbnNcbiAqXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiB0b0Zvcm1EYXRhKG9iaiwgZm9ybURhdGEsIG9wdGlvbnMpIHtcbiAgaWYgKCF1dGlscy5pc09iamVjdChvYmopKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndGFyZ2V0IG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgZm9ybURhdGEgPSBmb3JtRGF0YSB8fCBuZXcgKFBsYXRmb3JtRm9ybURhdGEgfHwgRm9ybURhdGEpKCk7XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gIG9wdGlvbnMgPSB1dGlscy50b0ZsYXRPYmplY3Qob3B0aW9ucywge1xuICAgIG1ldGFUb2tlbnM6IHRydWUsXG4gICAgZG90czogZmFsc2UsXG4gICAgaW5kZXhlczogZmFsc2VcbiAgfSwgZmFsc2UsIGZ1bmN0aW9uIGRlZmluZWQob3B0aW9uLCBzb3VyY2UpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZXEtbnVsbCxlcWVxZXFcbiAgICByZXR1cm4gIXV0aWxzLmlzVW5kZWZpbmVkKHNvdXJjZVtvcHRpb25dKTtcbiAgfSk7XG5cbiAgY29uc3QgbWV0YVRva2VucyA9IG9wdGlvbnMubWV0YVRva2VucztcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZS1iZWZvcmUtZGVmaW5lXG4gIGNvbnN0IHZpc2l0b3IgPSBvcHRpb25zLnZpc2l0b3IgfHwgZGVmYXVsdFZpc2l0b3I7XG4gIGNvbnN0IGRvdHMgPSBvcHRpb25zLmRvdHM7XG4gIGNvbnN0IGluZGV4ZXMgPSBvcHRpb25zLmluZGV4ZXM7XG4gIGNvbnN0IF9CbG9iID0gb3B0aW9ucy5CbG9iIHx8IHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJyAmJiBCbG9iO1xuICBjb25zdCB1c2VCbG9iID0gX0Jsb2IgJiYgdXRpbHMuaXNTcGVjQ29tcGxpYW50Rm9ybShmb3JtRGF0YSk7XG5cbiAgaWYgKCF1dGlscy5pc0Z1bmN0aW9uKHZpc2l0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmlzaXRvciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbnZlcnRWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkgcmV0dXJuICcnO1xuXG4gICAgaWYgKHV0aWxzLmlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZS50b0lTT1N0cmluZygpO1xuICAgIH1cblxuICAgIGlmICh1dGlscy5pc0Jvb2xlYW4odmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICB9XG5cbiAgICBpZiAoIXVzZUJsb2IgJiYgdXRpbHMuaXNCbG9iKHZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IEF4aW9zRXJyb3IoJ0Jsb2IgaXMgbm90IHN1cHBvcnRlZC4gVXNlIGEgQnVmZmVyIGluc3RlYWQuJyk7XG4gICAgfVxuXG4gICAgaWYgKHV0aWxzLmlzQXJyYXlCdWZmZXIodmFsdWUpIHx8IHV0aWxzLmlzVHlwZWRBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB1c2VCbG9iICYmIHR5cGVvZiBCbG9iID09PSAnZnVuY3Rpb24nID8gbmV3IEJsb2IoW3ZhbHVlXSkgOiBCdWZmZXIuZnJvbSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmF1bHQgdmlzaXRvci5cbiAgICpcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IGtleVxuICAgKiBAcGFyYW0ge0FycmF5PFN0cmluZ3xOdW1iZXI+fSBwYXRoXG4gICAqIEB0aGlzIHtGb3JtRGF0YX1cbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59IHJldHVybiB0cnVlIHRvIHZpc2l0IHRoZSBlYWNoIHByb3Agb2YgdGhlIHZhbHVlIHJlY3Vyc2l2ZWx5XG4gICAqL1xuICBmdW5jdGlvbiBkZWZhdWx0VmlzaXRvcih2YWx1ZSwga2V5LCBwYXRoKSB7XG4gICAgbGV0IGFyciA9IHZhbHVlO1xuXG4gICAgaWYgKHZhbHVlICYmICFwYXRoICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmICh1dGlscy5lbmRzV2l0aChrZXksICd7fScpKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICBrZXkgPSBtZXRhVG9rZW5zID8ga2V5IDoga2V5LnNsaWNlKDAsIC0yKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIHZhbHVlID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgKHV0aWxzLmlzQXJyYXkodmFsdWUpICYmIGlzRmxhdEFycmF5KHZhbHVlKSkgfHxcbiAgICAgICAgKCh1dGlscy5pc0ZpbGVMaXN0KHZhbHVlKSB8fCB1dGlscy5lbmRzV2l0aChrZXksICdbXScpKSAmJiAoYXJyID0gdXRpbHMudG9BcnJheSh2YWx1ZSkpXG4gICAgICAgICkpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIGtleSA9IHJlbW92ZUJyYWNrZXRzKGtleSk7XG5cbiAgICAgICAgYXJyLmZvckVhY2goZnVuY3Rpb24gZWFjaChlbCwgaW5kZXgpIHtcbiAgICAgICAgICAhKHV0aWxzLmlzVW5kZWZpbmVkKGVsKSB8fCBlbCA9PT0gbnVsbCkgJiYgZm9ybURhdGEuYXBwZW5kKFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5lc3RlZC10ZXJuYXJ5XG4gICAgICAgICAgICBpbmRleGVzID09PSB0cnVlID8gcmVuZGVyS2V5KFtrZXldLCBpbmRleCwgZG90cykgOiAoaW5kZXhlcyA9PT0gbnVsbCA/IGtleSA6IGtleSArICdbXScpLFxuICAgICAgICAgICAgY29udmVydFZhbHVlKGVsKVxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzVmlzaXRhYmxlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZm9ybURhdGEuYXBwZW5kKHJlbmRlcktleShwYXRoLCBrZXksIGRvdHMpLCBjb252ZXJ0VmFsdWUodmFsdWUpKTtcblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IHN0YWNrID0gW107XG5cbiAgY29uc3QgZXhwb3NlZEhlbHBlcnMgPSBPYmplY3QuYXNzaWduKHByZWRpY2F0ZXMsIHtcbiAgICBkZWZhdWx0VmlzaXRvcixcbiAgICBjb252ZXJ0VmFsdWUsXG4gICAgaXNWaXNpdGFibGVcbiAgfSk7XG5cbiAgZnVuY3Rpb24gYnVpbGQodmFsdWUsIHBhdGgpIHtcbiAgICBpZiAodXRpbHMuaXNVbmRlZmluZWQodmFsdWUpKSByZXR1cm47XG5cbiAgICBpZiAoc3RhY2suaW5kZXhPZih2YWx1ZSkgIT09IC0xKSB7XG4gICAgICB0aHJvdyBFcnJvcignQ2lyY3VsYXIgcmVmZXJlbmNlIGRldGVjdGVkIGluICcgKyBwYXRoLmpvaW4oJy4nKSk7XG4gICAgfVxuXG4gICAgc3RhY2sucHVzaCh2YWx1ZSk7XG5cbiAgICB1dGlscy5mb3JFYWNoKHZhbHVlLCBmdW5jdGlvbiBlYWNoKGVsLCBrZXkpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9ICEodXRpbHMuaXNVbmRlZmluZWQoZWwpIHx8IGVsID09PSBudWxsKSAmJiB2aXNpdG9yLmNhbGwoXG4gICAgICAgIGZvcm1EYXRhLCBlbCwgdXRpbHMuaXNTdHJpbmcoa2V5KSA/IGtleS50cmltKCkgOiBrZXksIHBhdGgsIGV4cG9zZWRIZWxwZXJzXG4gICAgICApO1xuXG4gICAgICBpZiAocmVzdWx0ID09PSB0cnVlKSB7XG4gICAgICAgIGJ1aWxkKGVsLCBwYXRoID8gcGF0aC5jb25jYXQoa2V5KSA6IFtrZXldKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHN0YWNrLnBvcCgpO1xuICB9XG5cbiAgaWYgKCF1dGlscy5pc09iamVjdChvYmopKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZGF0YSBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICB9XG5cbiAgYnVpbGQob2JqKTtcblxuICByZXR1cm4gZm9ybURhdGE7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHRvRm9ybURhdGE7XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB0b0Zvcm1EYXRhIGZyb20gJy4vdG9Gb3JtRGF0YS5qcyc7XG5cbi8qKlxuICogSXQgZW5jb2RlcyBhIHN0cmluZyBieSByZXBsYWNpbmcgYWxsIGNoYXJhY3RlcnMgdGhhdCBhcmUgbm90IGluIHRoZSB1bnJlc2VydmVkIHNldCB3aXRoXG4gKiB0aGVpciBwZXJjZW50LWVuY29kZWQgZXF1aXZhbGVudHNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIC0gVGhlIHN0cmluZyB0byBlbmNvZGUuXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGVuY29kZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBlbmNvZGUoc3RyKSB7XG4gIGNvbnN0IGNoYXJNYXAgPSB7XG4gICAgJyEnOiAnJTIxJyxcbiAgICBcIidcIjogJyUyNycsXG4gICAgJygnOiAnJTI4JyxcbiAgICAnKSc6ICclMjknLFxuICAgICd+JzogJyU3RScsXG4gICAgJyUyMCc6ICcrJyxcbiAgICAnJTAwJzogJ1xceDAwJ1xuICB9O1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cikucmVwbGFjZSgvWyEnKCl+XXwlMjB8JTAwL2csIGZ1bmN0aW9uIHJlcGxhY2VyKG1hdGNoKSB7XG4gICAgcmV0dXJuIGNoYXJNYXBbbWF0Y2hdO1xuICB9KTtcbn1cblxuLyoqXG4gKiBJdCB0YWtlcyBhIHBhcmFtcyBvYmplY3QgYW5kIGNvbnZlcnRzIGl0IHRvIGEgRm9ybURhdGEgb2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCBhbnk+fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyB0byBiZSBjb252ZXJ0ZWQgdG8gYSBGb3JtRGF0YSBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsIGFueT59IG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBvYmplY3QgcGFzc2VkIHRvIHRoZSBBeGlvcyBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gQXhpb3NVUkxTZWFyY2hQYXJhbXMocGFyYW1zLCBvcHRpb25zKSB7XG4gIHRoaXMuX3BhaXJzID0gW107XG5cbiAgcGFyYW1zICYmIHRvRm9ybURhdGEocGFyYW1zLCB0aGlzLCBvcHRpb25zKTtcbn1cblxuY29uc3QgcHJvdG90eXBlID0gQXhpb3NVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlO1xuXG5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24gYXBwZW5kKG5hbWUsIHZhbHVlKSB7XG4gIHRoaXMuX3BhaXJzLnB1c2goW25hbWUsIHZhbHVlXSk7XG59O1xuXG5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhlbmNvZGVyKSB7XG4gIGNvbnN0IF9lbmNvZGUgPSBlbmNvZGVyID8gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZW5jb2Rlci5jYWxsKHRoaXMsIHZhbHVlLCBlbmNvZGUpO1xuICB9IDogZW5jb2RlO1xuXG4gIHJldHVybiB0aGlzLl9wYWlycy5tYXAoZnVuY3Rpb24gZWFjaChwYWlyKSB7XG4gICAgcmV0dXJuIF9lbmNvZGUocGFpclswXSkgKyAnPScgKyBfZW5jb2RlKHBhaXJbMV0pO1xuICB9LCAnJykuam9pbignJicpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgQXhpb3NVUkxTZWFyY2hQYXJhbXM7XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB1dGlscyBmcm9tICcuLi91dGlscy5qcyc7XG5pbXBvcnQgQXhpb3NVUkxTZWFyY2hQYXJhbXMgZnJvbSAnLi4vaGVscGVycy9BeGlvc1VSTFNlYXJjaFBhcmFtcy5qcyc7XG5cbi8qKlxuICogSXQgcmVwbGFjZXMgYWxsIGluc3RhbmNlcyBvZiB0aGUgY2hhcmFjdGVycyBgOmAsIGAkYCwgYCxgLCBgK2AsIGBbYCwgYW5kIGBdYCB3aXRoIHRoZWlyXG4gKiBVUkkgZW5jb2RlZCBjb3VudGVycGFydHNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsIFRoZSB2YWx1ZSB0byBiZSBlbmNvZGVkLlxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBlbmNvZGVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBlbmNvZGUodmFsKSB7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQodmFsKS5cbiAgICByZXBsYWNlKC8lM0EvZ2ksICc6JykuXG4gICAgcmVwbGFjZSgvJTI0L2csICckJykuXG4gICAgcmVwbGFjZSgvJTJDL2dpLCAnLCcpLlxuICAgIHJlcGxhY2UoLyUyMC9nLCAnKycpO1xufVxuXG4vKipcbiAqIEJ1aWxkIGEgVVJMIGJ5IGFwcGVuZGluZyBwYXJhbXMgdG8gdGhlIGVuZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIGJhc2Ugb2YgdGhlIHVybCAoZS5nLiwgaHR0cDovL3d3dy5nb29nbGUuY29tKVxuICogQHBhcmFtIHtvYmplY3R9IFtwYXJhbXNdIFRoZSBwYXJhbXMgdG8gYmUgYXBwZW5kZWRcbiAqIEBwYXJhbSB7PyhvYmplY3R8RnVuY3Rpb24pfSBvcHRpb25zXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGZvcm1hdHRlZCB1cmxcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYnVpbGRVUkwodXJsLCBwYXJhbXMsIG9wdGlvbnMpIHtcbiAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gIGlmICghcGFyYW1zKSB7XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuICBcbiAgY29uc3QgX2VuY29kZSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5lbmNvZGUgfHwgZW5jb2RlO1xuXG4gIGlmICh1dGlscy5pc0Z1bmN0aW9uKG9wdGlvbnMpKSB7XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIHNlcmlhbGl6ZTogb3B0aW9uc1xuICAgIH07XG4gIH0gXG5cbiAgY29uc3Qgc2VyaWFsaXplRm4gPSBvcHRpb25zICYmIG9wdGlvbnMuc2VyaWFsaXplO1xuXG4gIGxldCBzZXJpYWxpemVkUGFyYW1zO1xuXG4gIGlmIChzZXJpYWxpemVGbikge1xuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSBzZXJpYWxpemVGbihwYXJhbXMsIG9wdGlvbnMpO1xuICB9IGVsc2Uge1xuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSB1dGlscy5pc1VSTFNlYXJjaFBhcmFtcyhwYXJhbXMpID9cbiAgICAgIHBhcmFtcy50b1N0cmluZygpIDpcbiAgICAgIG5ldyBBeGlvc1VSTFNlYXJjaFBhcmFtcyhwYXJhbXMsIG9wdGlvbnMpLnRvU3RyaW5nKF9lbmNvZGUpO1xuICB9XG5cbiAgaWYgKHNlcmlhbGl6ZWRQYXJhbXMpIHtcbiAgICBjb25zdCBoYXNobWFya0luZGV4ID0gdXJsLmluZGV4T2YoXCIjXCIpO1xuXG4gICAgaWYgKGhhc2htYXJrSW5kZXggIT09IC0xKSB7XG4gICAgICB1cmwgPSB1cmwuc2xpY2UoMCwgaGFzaG1hcmtJbmRleCk7XG4gICAgfVxuICAgIHVybCArPSAodXJsLmluZGV4T2YoJz8nKSA9PT0gLTEgPyAnPycgOiAnJicpICsgc2VyaWFsaXplZFBhcmFtcztcbiAgfVxuXG4gIHJldHVybiB1cmw7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB1dGlscyBmcm9tICcuLy4uL3V0aWxzLmpzJztcblxuY2xhc3MgSW50ZXJjZXB0b3JNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5oYW5kbGVycyA9IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIG5ldyBpbnRlcmNlcHRvciB0byB0aGUgc3RhY2tcbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVsZmlsbGVkIFRoZSBmdW5jdGlvbiB0byBoYW5kbGUgYHRoZW5gIGZvciBhIGBQcm9taXNlYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWplY3RlZCBUaGUgZnVuY3Rpb24gdG8gaGFuZGxlIGByZWplY3RgIGZvciBhIGBQcm9taXNlYFxuICAgKlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IEFuIElEIHVzZWQgdG8gcmVtb3ZlIGludGVyY2VwdG9yIGxhdGVyXG4gICAqL1xuICB1c2UoZnVsZmlsbGVkLCByZWplY3RlZCwgb3B0aW9ucykge1xuICAgIHRoaXMuaGFuZGxlcnMucHVzaCh7XG4gICAgICBmdWxmaWxsZWQsXG4gICAgICByZWplY3RlZCxcbiAgICAgIHN5bmNocm9ub3VzOiBvcHRpb25zID8gb3B0aW9ucy5zeW5jaHJvbm91cyA6IGZhbHNlLFxuICAgICAgcnVuV2hlbjogb3B0aW9ucyA/IG9wdGlvbnMucnVuV2hlbiA6IG51bGxcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVycy5sZW5ndGggLSAxO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbiBpbnRlcmNlcHRvciBmcm9tIHRoZSBzdGFja1xuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gaWQgVGhlIElEIHRoYXQgd2FzIHJldHVybmVkIGJ5IGB1c2VgXG4gICAqXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIGludGVyY2VwdG9yIHdhcyByZW1vdmVkLCBgZmFsc2VgIG90aGVyd2lzZVxuICAgKi9cbiAgZWplY3QoaWQpIHtcbiAgICBpZiAodGhpcy5oYW5kbGVyc1tpZF0pIHtcbiAgICAgIHRoaXMuaGFuZGxlcnNbaWRdID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2xlYXIgYWxsIGludGVyY2VwdG9ycyBmcm9tIHRoZSBzdGFja1xuICAgKlxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGNsZWFyKCkge1xuICAgIGlmICh0aGlzLmhhbmRsZXJzKSB7XG4gICAgICB0aGlzLmhhbmRsZXJzID0gW107XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEl0ZXJhdGUgb3ZlciBhbGwgdGhlIHJlZ2lzdGVyZWQgaW50ZXJjZXB0b3JzXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGlzIHBhcnRpY3VsYXJseSB1c2VmdWwgZm9yIHNraXBwaW5nIG92ZXIgYW55XG4gICAqIGludGVyY2VwdG9ycyB0aGF0IG1heSBoYXZlIGJlY29tZSBgbnVsbGAgY2FsbGluZyBgZWplY3RgLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCBpbnRlcmNlcHRvclxuICAgKlxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGZvckVhY2goZm4pIHtcbiAgICB1dGlscy5mb3JFYWNoKHRoaXMuaGFuZGxlcnMsIGZ1bmN0aW9uIGZvckVhY2hIYW5kbGVyKGgpIHtcbiAgICAgIGlmIChoICE9PSBudWxsKSB7XG4gICAgICAgIGZuKGgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEludGVyY2VwdG9yTWFuYWdlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBzaWxlbnRKU09OUGFyc2luZzogdHJ1ZSxcbiAgZm9yY2VkSlNPTlBhcnNpbmc6IHRydWUsXG4gIGNsYXJpZnlUaW1lb3V0RXJyb3I6IGZhbHNlXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgdXJsIGZyb20gJ3VybCc7XG5leHBvcnQgZGVmYXVsdCB1cmwuVVJMU2VhcmNoUGFyYW1zO1xuIiwiaW1wb3J0IGNyeXB0byBmcm9tICdjcnlwdG8nO1xuaW1wb3J0IFVSTFNlYXJjaFBhcmFtcyBmcm9tICcuL2NsYXNzZXMvVVJMU2VhcmNoUGFyYW1zLmpzJ1xuaW1wb3J0IEZvcm1EYXRhIGZyb20gJy4vY2xhc3Nlcy9Gb3JtRGF0YS5qcydcblxuY29uc3QgQUxQSEEgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXonXG5cbmNvbnN0IERJR0lUID0gJzAxMjM0NTY3ODknO1xuXG5jb25zdCBBTFBIQUJFVCA9IHtcbiAgRElHSVQsXG4gIEFMUEhBLFxuICBBTFBIQV9ESUdJVDogQUxQSEEgKyBBTFBIQS50b1VwcGVyQ2FzZSgpICsgRElHSVRcbn1cblxuY29uc3QgZ2VuZXJhdGVTdHJpbmcgPSAoc2l6ZSA9IDE2LCBhbHBoYWJldCA9IEFMUEhBQkVULkFMUEhBX0RJR0lUKSA9PiB7XG4gIGxldCBzdHIgPSAnJztcbiAgY29uc3Qge2xlbmd0aH0gPSBhbHBoYWJldDtcbiAgY29uc3QgcmFuZG9tVmFsdWVzID0gbmV3IFVpbnQzMkFycmF5KHNpemUpO1xuICBjcnlwdG8ucmFuZG9tRmlsbFN5bmMocmFuZG9tVmFsdWVzKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICBzdHIgKz0gYWxwaGFiZXRbcmFuZG9tVmFsdWVzW2ldICUgbGVuZ3RoXTtcbiAgfVxuXG4gIHJldHVybiBzdHI7XG59XG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBpc05vZGU6IHRydWUsXG4gIGNsYXNzZXM6IHtcbiAgICBVUkxTZWFyY2hQYXJhbXMsXG4gICAgRm9ybURhdGEsXG4gICAgQmxvYjogdHlwZW9mIEJsb2IgIT09ICd1bmRlZmluZWQnICYmIEJsb2IgfHwgbnVsbFxuICB9LFxuICBBTFBIQUJFVCxcbiAgZ2VuZXJhdGVTdHJpbmcsXG4gIHByb3RvY29sczogWyAnaHR0cCcsICdodHRwcycsICdmaWxlJywgJ2RhdGEnIF1cbn07XG4iLCJjb25zdCBoYXNCcm93c2VyRW52ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcblxuY29uc3QgX25hdmlnYXRvciA9IHR5cGVvZiBuYXZpZ2F0b3IgPT09ICdvYmplY3QnICYmIG5hdmlnYXRvciB8fCB1bmRlZmluZWQ7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIHdlJ3JlIHJ1bm5pbmcgaW4gYSBzdGFuZGFyZCBicm93c2VyIGVudmlyb25tZW50XG4gKlxuICogVGhpcyBhbGxvd3MgYXhpb3MgdG8gcnVuIGluIGEgd2ViIHdvcmtlciwgYW5kIHJlYWN0LW5hdGl2ZS5cbiAqIEJvdGggZW52aXJvbm1lbnRzIHN1cHBvcnQgWE1MSHR0cFJlcXVlc3QsIGJ1dCBub3QgZnVsbHkgc3RhbmRhcmQgZ2xvYmFscy5cbiAqXG4gKiB3ZWIgd29ya2VyczpcbiAqICB0eXBlb2Ygd2luZG93IC0+IHVuZGVmaW5lZFxuICogIHR5cGVvZiBkb2N1bWVudCAtPiB1bmRlZmluZWRcbiAqXG4gKiByZWFjdC1uYXRpdmU6XG4gKiAgbmF2aWdhdG9yLnByb2R1Y3QgLT4gJ1JlYWN0TmF0aXZlJ1xuICogbmF0aXZlc2NyaXB0XG4gKiAgbmF2aWdhdG9yLnByb2R1Y3QgLT4gJ05hdGl2ZVNjcmlwdCcgb3IgJ05TJ1xuICpcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5jb25zdCBoYXNTdGFuZGFyZEJyb3dzZXJFbnYgPSBoYXNCcm93c2VyRW52ICYmXG4gICghX25hdmlnYXRvciB8fCBbJ1JlYWN0TmF0aXZlJywgJ05hdGl2ZVNjcmlwdCcsICdOUyddLmluZGV4T2YoX25hdmlnYXRvci5wcm9kdWN0KSA8IDApO1xuXG4vKipcbiAqIERldGVybWluZSBpZiB3ZSdyZSBydW5uaW5nIGluIGEgc3RhbmRhcmQgYnJvd3NlciB3ZWJXb3JrZXIgZW52aXJvbm1lbnRcbiAqXG4gKiBBbHRob3VnaCB0aGUgYGlzU3RhbmRhcmRCcm93c2VyRW52YCBtZXRob2QgaW5kaWNhdGVzIHRoYXRcbiAqIGBhbGxvd3MgYXhpb3MgdG8gcnVuIGluIGEgd2ViIHdvcmtlcmAsIHRoZSBXZWJXb3JrZXIgd2lsbCBzdGlsbCBiZVxuICogZmlsdGVyZWQgb3V0IGR1ZSB0byBpdHMganVkZ21lbnQgc3RhbmRhcmRcbiAqIGB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnYC5cbiAqIFRoaXMgbGVhZHMgdG8gYSBwcm9ibGVtIHdoZW4gYXhpb3MgcG9zdCBgRm9ybURhdGFgIGluIHdlYldvcmtlclxuICovXG5jb25zdCBoYXNTdGFuZGFyZEJyb3dzZXJXZWJXb3JrZXJFbnYgPSAoKCkgPT4ge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICBzZWxmIGluc3RhbmNlb2YgV29ya2VyR2xvYmFsU2NvcGUgJiZcbiAgICB0eXBlb2Ygc2VsZi5pbXBvcnRTY3JpcHRzID09PSAnZnVuY3Rpb24nXG4gICk7XG59KSgpO1xuXG5jb25zdCBvcmlnaW4gPSBoYXNCcm93c2VyRW52ICYmIHdpbmRvdy5sb2NhdGlvbi5ocmVmIHx8ICdodHRwOi8vbG9jYWxob3N0JztcblxuZXhwb3J0IHtcbiAgaGFzQnJvd3NlckVudixcbiAgaGFzU3RhbmRhcmRCcm93c2VyV2ViV29ya2VyRW52LFxuICBoYXNTdGFuZGFyZEJyb3dzZXJFbnYsXG4gIF9uYXZpZ2F0b3IgYXMgbmF2aWdhdG9yLFxuICBvcmlnaW5cbn1cbiIsImltcG9ydCBwbGF0Zm9ybSBmcm9tICcuL25vZGUvaW5kZXguanMnO1xuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi9jb21tb24vdXRpbHMuanMnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIC4uLnV0aWxzLFxuICAuLi5wbGF0Zm9ybVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgdXRpbHMgZnJvbSAnLi4vdXRpbHMuanMnO1xuaW1wb3J0IHRvRm9ybURhdGEgZnJvbSAnLi90b0Zvcm1EYXRhLmpzJztcbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuLi9wbGF0Zm9ybS9pbmRleC5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRvVVJMRW5jb2RlZEZvcm0oZGF0YSwgb3B0aW9ucykge1xuICByZXR1cm4gdG9Gb3JtRGF0YShkYXRhLCBuZXcgcGxhdGZvcm0uY2xhc3Nlcy5VUkxTZWFyY2hQYXJhbXMoKSwge1xuICAgIHZpc2l0b3I6IGZ1bmN0aW9uKHZhbHVlLCBrZXksIHBhdGgsIGhlbHBlcnMpIHtcbiAgICAgIGlmIChwbGF0Zm9ybS5pc05vZGUgJiYgdXRpbHMuaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kKGtleSwgdmFsdWUudG9TdHJpbmcoJ2Jhc2U2NCcpKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaGVscGVycy5kZWZhdWx0VmlzaXRvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgLi4ub3B0aW9uc1xuICB9KTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4uL3V0aWxzLmpzJztcblxuLyoqXG4gKiBJdCB0YWtlcyBhIHN0cmluZyBsaWtlIGBmb29beF1beV1bel1gIGFuZCByZXR1cm5zIGFuIGFycmF5IGxpa2UgYFsnZm9vJywgJ3gnLCAneScsICd6J11cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKlxuICogQHJldHVybnMgQW4gYXJyYXkgb2Ygc3RyaW5ncy5cbiAqL1xuZnVuY3Rpb24gcGFyc2VQcm9wUGF0aChuYW1lKSB7XG4gIC8vIGZvb1t4XVt5XVt6XVxuICAvLyBmb28ueC55LnpcbiAgLy8gZm9vLXgteS16XG4gIC8vIGZvbyB4IHkgelxuICByZXR1cm4gdXRpbHMubWF0Y2hBbGwoL1xcdyt8XFxbKFxcdyopXS9nLCBuYW1lKS5tYXAobWF0Y2ggPT4ge1xuICAgIHJldHVybiBtYXRjaFswXSA9PT0gJ1tdJyA/ICcnIDogbWF0Y2hbMV0gfHwgbWF0Y2hbMF07XG4gIH0pO1xufVxuXG4vKipcbiAqIENvbnZlcnQgYW4gYXJyYXkgdG8gYW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gYXJyIC0gVGhlIGFycmF5IHRvIGNvbnZlcnQgdG8gYW4gb2JqZWN0LlxuICpcbiAqIEByZXR1cm5zIEFuIG9iamVjdCB3aXRoIHRoZSBzYW1lIGtleXMgYW5kIHZhbHVlcyBhcyB0aGUgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5VG9PYmplY3QoYXJyKSB7XG4gIGNvbnN0IG9iaiA9IHt9O1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoYXJyKTtcbiAgbGV0IGk7XG4gIGNvbnN0IGxlbiA9IGtleXMubGVuZ3RoO1xuICBsZXQga2V5O1xuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBrZXkgPSBrZXlzW2ldO1xuICAgIG9ialtrZXldID0gYXJyW2tleV07XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiBJdCB0YWtlcyBhIEZvcm1EYXRhIG9iamVjdCBhbmQgcmV0dXJucyBhIEphdmFTY3JpcHQgb2JqZWN0XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGZvcm1EYXRhIFRoZSBGb3JtRGF0YSBvYmplY3QgdG8gY29udmVydCB0byBKU09OLlxuICpcbiAqIEByZXR1cm5zIHtPYmplY3Q8c3RyaW5nLCBhbnk+IHwgbnVsbH0gVGhlIGNvbnZlcnRlZCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGZvcm1EYXRhVG9KU09OKGZvcm1EYXRhKSB7XG4gIGZ1bmN0aW9uIGJ1aWxkUGF0aChwYXRoLCB2YWx1ZSwgdGFyZ2V0LCBpbmRleCkge1xuICAgIGxldCBuYW1lID0gcGF0aFtpbmRleCsrXTtcblxuICAgIGlmIChuYW1lID09PSAnX19wcm90b19fJykgcmV0dXJuIHRydWU7XG5cbiAgICBjb25zdCBpc051bWVyaWNLZXkgPSBOdW1iZXIuaXNGaW5pdGUoK25hbWUpO1xuICAgIGNvbnN0IGlzTGFzdCA9IGluZGV4ID49IHBhdGgubGVuZ3RoO1xuICAgIG5hbWUgPSAhbmFtZSAmJiB1dGlscy5pc0FycmF5KHRhcmdldCkgPyB0YXJnZXQubGVuZ3RoIDogbmFtZTtcblxuICAgIGlmIChpc0xhc3QpIHtcbiAgICAgIGlmICh1dGlscy5oYXNPd25Qcm9wKHRhcmdldCwgbmFtZSkpIHtcbiAgICAgICAgdGFyZ2V0W25hbWVdID0gW3RhcmdldFtuYW1lXSwgdmFsdWVdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFyZ2V0W25hbWVdID0gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAhaXNOdW1lcmljS2V5O1xuICAgIH1cblxuICAgIGlmICghdGFyZ2V0W25hbWVdIHx8ICF1dGlscy5pc09iamVjdCh0YXJnZXRbbmFtZV0pKSB7XG4gICAgICB0YXJnZXRbbmFtZV0gPSBbXTtcbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHQgPSBidWlsZFBhdGgocGF0aCwgdmFsdWUsIHRhcmdldFtuYW1lXSwgaW5kZXgpO1xuXG4gICAgaWYgKHJlc3VsdCAmJiB1dGlscy5pc0FycmF5KHRhcmdldFtuYW1lXSkpIHtcbiAgICAgIHRhcmdldFtuYW1lXSA9IGFycmF5VG9PYmplY3QodGFyZ2V0W25hbWVdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gIWlzTnVtZXJpY0tleTtcbiAgfVxuXG4gIGlmICh1dGlscy5pc0Zvcm1EYXRhKGZvcm1EYXRhKSAmJiB1dGlscy5pc0Z1bmN0aW9uKGZvcm1EYXRhLmVudHJpZXMpKSB7XG4gICAgY29uc3Qgb2JqID0ge307XG5cbiAgICB1dGlscy5mb3JFYWNoRW50cnkoZm9ybURhdGEsIChuYW1lLCB2YWx1ZSkgPT4ge1xuICAgICAgYnVpbGRQYXRoKHBhcnNlUHJvcFBhdGgobmFtZSksIHZhbHVlLCBvYmosIDApO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmb3JtRGF0YVRvSlNPTjtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4uL3V0aWxzLmpzJztcbmltcG9ydCBBeGlvc0Vycm9yIGZyb20gJy4uL2NvcmUvQXhpb3NFcnJvci5qcyc7XG5pbXBvcnQgdHJhbnNpdGlvbmFsRGVmYXVsdHMgZnJvbSAnLi90cmFuc2l0aW9uYWwuanMnO1xuaW1wb3J0IHRvRm9ybURhdGEgZnJvbSAnLi4vaGVscGVycy90b0Zvcm1EYXRhLmpzJztcbmltcG9ydCB0b1VSTEVuY29kZWRGb3JtIGZyb20gJy4uL2hlbHBlcnMvdG9VUkxFbmNvZGVkRm9ybS5qcyc7XG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnLi4vcGxhdGZvcm0vaW5kZXguanMnO1xuaW1wb3J0IGZvcm1EYXRhVG9KU09OIGZyb20gJy4uL2hlbHBlcnMvZm9ybURhdGFUb0pTT04uanMnO1xuXG4vKipcbiAqIEl0IHRha2VzIGEgc3RyaW5nLCB0cmllcyB0byBwYXJzZSBpdCwgYW5kIGlmIGl0IGZhaWxzLCBpdCByZXR1cm5zIHRoZSBzdHJpbmdpZmllZCB2ZXJzaW9uXG4gKiBvZiB0aGUgaW5wdXRcbiAqXG4gKiBAcGFyYW0ge2FueX0gcmF3VmFsdWUgLSBUaGUgdmFsdWUgdG8gYmUgc3RyaW5naWZpZWQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwYXJzZXIgLSBBIGZ1bmN0aW9uIHRoYXQgcGFyc2VzIGEgc3RyaW5nIGludG8gYSBKYXZhU2NyaXB0IG9iamVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVuY29kZXIgLSBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSB2YWx1ZSBhbmQgcmV0dXJucyBhIHN0cmluZy5cbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBBIHN0cmluZ2lmaWVkIHZlcnNpb24gb2YgdGhlIHJhd1ZhbHVlLlxuICovXG5mdW5jdGlvbiBzdHJpbmdpZnlTYWZlbHkocmF3VmFsdWUsIHBhcnNlciwgZW5jb2Rlcikge1xuICBpZiAodXRpbHMuaXNTdHJpbmcocmF3VmFsdWUpKSB7XG4gICAgdHJ5IHtcbiAgICAgIChwYXJzZXIgfHwgSlNPTi5wYXJzZSkocmF3VmFsdWUpO1xuICAgICAgcmV0dXJuIHV0aWxzLnRyaW0ocmF3VmFsdWUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChlLm5hbWUgIT09ICdTeW50YXhFcnJvcicpIHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gKGVuY29kZXIgfHwgSlNPTi5zdHJpbmdpZnkpKHJhd1ZhbHVlKTtcbn1cblxuY29uc3QgZGVmYXVsdHMgPSB7XG5cbiAgdHJhbnNpdGlvbmFsOiB0cmFuc2l0aW9uYWxEZWZhdWx0cyxcblxuICBhZGFwdGVyOiBbJ3hocicsICdodHRwJywgJ2ZldGNoJ10sXG5cbiAgdHJhbnNmb3JtUmVxdWVzdDogW2Z1bmN0aW9uIHRyYW5zZm9ybVJlcXVlc3QoZGF0YSwgaGVhZGVycykge1xuICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gaGVhZGVycy5nZXRDb250ZW50VHlwZSgpIHx8ICcnO1xuICAgIGNvbnN0IGhhc0pTT05Db250ZW50VHlwZSA9IGNvbnRlbnRUeXBlLmluZGV4T2YoJ2FwcGxpY2F0aW9uL2pzb24nKSA+IC0xO1xuICAgIGNvbnN0IGlzT2JqZWN0UGF5bG9hZCA9IHV0aWxzLmlzT2JqZWN0KGRhdGEpO1xuXG4gICAgaWYgKGlzT2JqZWN0UGF5bG9hZCAmJiB1dGlscy5pc0hUTUxGb3JtKGRhdGEpKSB7XG4gICAgICBkYXRhID0gbmV3IEZvcm1EYXRhKGRhdGEpO1xuICAgIH1cblxuICAgIGNvbnN0IGlzRm9ybURhdGEgPSB1dGlscy5pc0Zvcm1EYXRhKGRhdGEpO1xuXG4gICAgaWYgKGlzRm9ybURhdGEpIHtcbiAgICAgIHJldHVybiBoYXNKU09OQ29udGVudFR5cGUgPyBKU09OLnN0cmluZ2lmeShmb3JtRGF0YVRvSlNPTihkYXRhKSkgOiBkYXRhO1xuICAgIH1cblxuICAgIGlmICh1dGlscy5pc0FycmF5QnVmZmVyKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0J1ZmZlcihkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNTdHJlYW0oZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzRmlsZShkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNCbG9iKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc1JlYWRhYmxlU3RyZWFtKGRhdGEpXG4gICAgKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgaWYgKHV0aWxzLmlzQXJyYXlCdWZmZXJWaWV3KGRhdGEpKSB7XG4gICAgICByZXR1cm4gZGF0YS5idWZmZXI7XG4gICAgfVxuICAgIGlmICh1dGlscy5pc1VSTFNlYXJjaFBhcmFtcyhkYXRhKSkge1xuICAgICAgaGVhZGVycy5zZXRDb250ZW50VHlwZSgnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9dXRmLTgnLCBmYWxzZSk7XG4gICAgICByZXR1cm4gZGF0YS50b1N0cmluZygpO1xuICAgIH1cblxuICAgIGxldCBpc0ZpbGVMaXN0O1xuXG4gICAgaWYgKGlzT2JqZWN0UGF5bG9hZCkge1xuICAgICAgaWYgKGNvbnRlbnRUeXBlLmluZGV4T2YoJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcpID4gLTEpIHtcbiAgICAgICAgcmV0dXJuIHRvVVJMRW5jb2RlZEZvcm0oZGF0YSwgdGhpcy5mb3JtU2VyaWFsaXplcikudG9TdHJpbmcoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKChpc0ZpbGVMaXN0ID0gdXRpbHMuaXNGaWxlTGlzdChkYXRhKSkgfHwgY29udGVudFR5cGUuaW5kZXhPZignbXVsdGlwYXJ0L2Zvcm0tZGF0YScpID4gLTEpIHtcbiAgICAgICAgY29uc3QgX0Zvcm1EYXRhID0gdGhpcy5lbnYgJiYgdGhpcy5lbnYuRm9ybURhdGE7XG5cbiAgICAgICAgcmV0dXJuIHRvRm9ybURhdGEoXG4gICAgICAgICAgaXNGaWxlTGlzdCA/IHsnZmlsZXNbXSc6IGRhdGF9IDogZGF0YSxcbiAgICAgICAgICBfRm9ybURhdGEgJiYgbmV3IF9Gb3JtRGF0YSgpLFxuICAgICAgICAgIHRoaXMuZm9ybVNlcmlhbGl6ZXJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNPYmplY3RQYXlsb2FkIHx8IGhhc0pTT05Db250ZW50VHlwZSApIHtcbiAgICAgIGhlYWRlcnMuc2V0Q29udGVudFR5cGUoJ2FwcGxpY2F0aW9uL2pzb24nLCBmYWxzZSk7XG4gICAgICByZXR1cm4gc3RyaW5naWZ5U2FmZWx5KGRhdGEpO1xuICAgIH1cblxuICAgIHJldHVybiBkYXRhO1xuICB9XSxcblxuICB0cmFuc2Zvcm1SZXNwb25zZTogW2Z1bmN0aW9uIHRyYW5zZm9ybVJlc3BvbnNlKGRhdGEpIHtcbiAgICBjb25zdCB0cmFuc2l0aW9uYWwgPSB0aGlzLnRyYW5zaXRpb25hbCB8fCBkZWZhdWx0cy50cmFuc2l0aW9uYWw7XG4gICAgY29uc3QgZm9yY2VkSlNPTlBhcnNpbmcgPSB0cmFuc2l0aW9uYWwgJiYgdHJhbnNpdGlvbmFsLmZvcmNlZEpTT05QYXJzaW5nO1xuICAgIGNvbnN0IEpTT05SZXF1ZXN0ZWQgPSB0aGlzLnJlc3BvbnNlVHlwZSA9PT0gJ2pzb24nO1xuXG4gICAgaWYgKHV0aWxzLmlzUmVzcG9uc2UoZGF0YSkgfHwgdXRpbHMuaXNSZWFkYWJsZVN0cmVhbShkYXRhKSkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgaWYgKGRhdGEgJiYgdXRpbHMuaXNTdHJpbmcoZGF0YSkgJiYgKChmb3JjZWRKU09OUGFyc2luZyAmJiAhdGhpcy5yZXNwb25zZVR5cGUpIHx8IEpTT05SZXF1ZXN0ZWQpKSB7XG4gICAgICBjb25zdCBzaWxlbnRKU09OUGFyc2luZyA9IHRyYW5zaXRpb25hbCAmJiB0cmFuc2l0aW9uYWwuc2lsZW50SlNPTlBhcnNpbmc7XG4gICAgICBjb25zdCBzdHJpY3RKU09OUGFyc2luZyA9ICFzaWxlbnRKU09OUGFyc2luZyAmJiBKU09OUmVxdWVzdGVkO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShkYXRhLCB0aGlzLnBhcnNlUmV2aXZlcik7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChzdHJpY3RKU09OUGFyc2luZykge1xuICAgICAgICAgIGlmIChlLm5hbWUgPT09ICdTeW50YXhFcnJvcicpIHtcbiAgICAgICAgICAgIHRocm93IEF4aW9zRXJyb3IuZnJvbShlLCBBeGlvc0Vycm9yLkVSUl9CQURfUkVTUE9OU0UsIHRoaXMsIG51bGwsIHRoaXMucmVzcG9uc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGE7XG4gIH1dLFxuXG4gIC8qKlxuICAgKiBBIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIHRvIGFib3J0IGEgcmVxdWVzdC4gSWYgc2V0IHRvIDAgKGRlZmF1bHQpIGFcbiAgICogdGltZW91dCBpcyBub3QgY3JlYXRlZC5cbiAgICovXG4gIHRpbWVvdXQ6IDAsXG5cbiAgeHNyZkNvb2tpZU5hbWU6ICdYU1JGLVRPS0VOJyxcbiAgeHNyZkhlYWRlck5hbWU6ICdYLVhTUkYtVE9LRU4nLFxuXG4gIG1heENvbnRlbnRMZW5ndGg6IC0xLFxuICBtYXhCb2R5TGVuZ3RoOiAtMSxcblxuICBlbnY6IHtcbiAgICBGb3JtRGF0YTogcGxhdGZvcm0uY2xhc3Nlcy5Gb3JtRGF0YSxcbiAgICBCbG9iOiBwbGF0Zm9ybS5jbGFzc2VzLkJsb2JcbiAgfSxcblxuICB2YWxpZGF0ZVN0YXR1czogZnVuY3Rpb24gdmFsaWRhdGVTdGF0dXMoc3RhdHVzKSB7XG4gICAgcmV0dXJuIHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwO1xuICB9LFxuXG4gIGhlYWRlcnM6IHtcbiAgICBjb21tb246IHtcbiAgICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbiwgdGV4dC9wbGFpbiwgKi8qJyxcbiAgICAgICdDb250ZW50LVR5cGUnOiB1bmRlZmluZWRcbiAgICB9XG4gIH1cbn07XG5cbnV0aWxzLmZvckVhY2goWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnLCAncG9zdCcsICdwdXQnLCAncGF0Y2gnXSwgKG1ldGhvZCkgPT4ge1xuICBkZWZhdWx0cy5oZWFkZXJzW21ldGhvZF0gPSB7fTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBkZWZhdWx0cztcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4vLi4vdXRpbHMuanMnO1xuXG4vLyBSYXdBeGlvc0hlYWRlcnMgd2hvc2UgZHVwbGljYXRlcyBhcmUgaWdub3JlZCBieSBub2RlXG4vLyBjLmYuIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvaHR0cC5odG1sI2h0dHBfbWVzc2FnZV9oZWFkZXJzXG5jb25zdCBpZ25vcmVEdXBsaWNhdGVPZiA9IHV0aWxzLnRvT2JqZWN0U2V0KFtcbiAgJ2FnZScsICdhdXRob3JpemF0aW9uJywgJ2NvbnRlbnQtbGVuZ3RoJywgJ2NvbnRlbnQtdHlwZScsICdldGFnJyxcbiAgJ2V4cGlyZXMnLCAnZnJvbScsICdob3N0JywgJ2lmLW1vZGlmaWVkLXNpbmNlJywgJ2lmLXVubW9kaWZpZWQtc2luY2UnLFxuICAnbGFzdC1tb2RpZmllZCcsICdsb2NhdGlvbicsICdtYXgtZm9yd2FyZHMnLCAncHJveHktYXV0aG9yaXphdGlvbicsXG4gICdyZWZlcmVyJywgJ3JldHJ5LWFmdGVyJywgJ3VzZXItYWdlbnQnXG5dKTtcblxuLyoqXG4gKiBQYXJzZSBoZWFkZXJzIGludG8gYW4gb2JqZWN0XG4gKlxuICogYGBgXG4gKiBEYXRlOiBXZWQsIDI3IEF1ZyAyMDE0IDA4OjU4OjQ5IEdNVFxuICogQ29udGVudC1UeXBlOiBhcHBsaWNhdGlvbi9qc29uXG4gKiBDb25uZWN0aW9uOiBrZWVwLWFsaXZlXG4gKiBUcmFuc2Zlci1FbmNvZGluZzogY2h1bmtlZFxuICogYGBgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHJhd0hlYWRlcnMgSGVhZGVycyBuZWVkaW5nIHRvIGJlIHBhcnNlZFxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9IEhlYWRlcnMgcGFyc2VkIGludG8gYW4gb2JqZWN0XG4gKi9cbmV4cG9ydCBkZWZhdWx0IHJhd0hlYWRlcnMgPT4ge1xuICBjb25zdCBwYXJzZWQgPSB7fTtcbiAgbGV0IGtleTtcbiAgbGV0IHZhbDtcbiAgbGV0IGk7XG5cbiAgcmF3SGVhZGVycyAmJiByYXdIZWFkZXJzLnNwbGl0KCdcXG4nKS5mb3JFYWNoKGZ1bmN0aW9uIHBhcnNlcihsaW5lKSB7XG4gICAgaSA9IGxpbmUuaW5kZXhPZignOicpO1xuICAgIGtleSA9IGxpbmUuc3Vic3RyaW5nKDAsIGkpLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhbCA9IGxpbmUuc3Vic3RyaW5nKGkgKyAxKS50cmltKCk7XG5cbiAgICBpZiAoIWtleSB8fCAocGFyc2VkW2tleV0gJiYgaWdub3JlRHVwbGljYXRlT2Zba2V5XSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoa2V5ID09PSAnc2V0LWNvb2tpZScpIHtcbiAgICAgIGlmIChwYXJzZWRba2V5XSkge1xuICAgICAgICBwYXJzZWRba2V5XS5wdXNoKHZhbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJzZWRba2V5XSA9IFt2YWxdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwYXJzZWRba2V5XSA9IHBhcnNlZFtrZXldID8gcGFyc2VkW2tleV0gKyAnLCAnICsgdmFsIDogdmFsO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHBhcnNlZDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB1dGlscyBmcm9tICcuLi91dGlscy5qcyc7XG5pbXBvcnQgcGFyc2VIZWFkZXJzIGZyb20gJy4uL2hlbHBlcnMvcGFyc2VIZWFkZXJzLmpzJztcblxuY29uc3QgJGludGVybmFscyA9IFN5bWJvbCgnaW50ZXJuYWxzJyk7XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUhlYWRlcihoZWFkZXIpIHtcbiAgcmV0dXJuIGhlYWRlciAmJiBTdHJpbmcoaGVhZGVyKS50cmltKCkudG9Mb3dlckNhc2UoKTtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplVmFsdWUodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSBmYWxzZSB8fCB2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHV0aWxzLmlzQXJyYXkodmFsdWUpID8gdmFsdWUubWFwKG5vcm1hbGl6ZVZhbHVlKSA6IFN0cmluZyh2YWx1ZSk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlVG9rZW5zKHN0cikge1xuICBjb25zdCB0b2tlbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBjb25zdCB0b2tlbnNSRSA9IC8oW15cXHMsOz1dKylcXHMqKD86PVxccyooW14sO10rKSk/L2c7XG4gIGxldCBtYXRjaDtcblxuICB3aGlsZSAoKG1hdGNoID0gdG9rZW5zUkUuZXhlYyhzdHIpKSkge1xuICAgIHRva2Vuc1ttYXRjaFsxXV0gPSBtYXRjaFsyXTtcbiAgfVxuXG4gIHJldHVybiB0b2tlbnM7XG59XG5cbmNvbnN0IGlzVmFsaWRIZWFkZXJOYW1lID0gKHN0cikgPT4gL15bLV9hLXpBLVowLTleYHx+LCEjJCUmJyorLl0rJC8udGVzdChzdHIudHJpbSgpKTtcblxuZnVuY3Rpb24gbWF0Y2hIZWFkZXJWYWx1ZShjb250ZXh0LCB2YWx1ZSwgaGVhZGVyLCBmaWx0ZXIsIGlzSGVhZGVyTmFtZUZpbHRlcikge1xuICBpZiAodXRpbHMuaXNGdW5jdGlvbihmaWx0ZXIpKSB7XG4gICAgcmV0dXJuIGZpbHRlci5jYWxsKHRoaXMsIHZhbHVlLCBoZWFkZXIpO1xuICB9XG5cbiAgaWYgKGlzSGVhZGVyTmFtZUZpbHRlcikge1xuICAgIHZhbHVlID0gaGVhZGVyO1xuICB9XG5cbiAgaWYgKCF1dGlscy5pc1N0cmluZyh2YWx1ZSkpIHJldHVybjtcblxuICBpZiAodXRpbHMuaXNTdHJpbmcoZmlsdGVyKSkge1xuICAgIHJldHVybiB2YWx1ZS5pbmRleE9mKGZpbHRlcikgIT09IC0xO1xuICB9XG5cbiAgaWYgKHV0aWxzLmlzUmVnRXhwKGZpbHRlcikpIHtcbiAgICByZXR1cm4gZmlsdGVyLnRlc3QodmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZvcm1hdEhlYWRlcihoZWFkZXIpIHtcbiAgcmV0dXJuIGhlYWRlci50cmltKClcbiAgICAudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC8oW2EtelxcZF0pKFxcdyopL2csICh3LCBjaGFyLCBzdHIpID0+IHtcbiAgICAgIHJldHVybiBjaGFyLnRvVXBwZXJDYXNlKCkgKyBzdHI7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkQWNjZXNzb3JzKG9iaiwgaGVhZGVyKSB7XG4gIGNvbnN0IGFjY2Vzc29yTmFtZSA9IHV0aWxzLnRvQ2FtZWxDYXNlKCcgJyArIGhlYWRlcik7XG5cbiAgWydnZXQnLCAnc2V0JywgJ2hhcyddLmZvckVhY2gobWV0aG9kTmFtZSA9PiB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgbWV0aG9kTmFtZSArIGFjY2Vzc29yTmFtZSwge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uKGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbbWV0aG9kTmFtZV0uY2FsbCh0aGlzLCBoZWFkZXIsIGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgICAgfSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9KTtcbn1cblxuY2xhc3MgQXhpb3NIZWFkZXJzIHtcbiAgY29uc3RydWN0b3IoaGVhZGVycykge1xuICAgIGhlYWRlcnMgJiYgdGhpcy5zZXQoaGVhZGVycyk7XG4gIH1cblxuICBzZXQoaGVhZGVyLCB2YWx1ZU9yUmV3cml0ZSwgcmV3cml0ZSkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuXG4gICAgZnVuY3Rpb24gc2V0SGVhZGVyKF92YWx1ZSwgX2hlYWRlciwgX3Jld3JpdGUpIHtcbiAgICAgIGNvbnN0IGxIZWFkZXIgPSBub3JtYWxpemVIZWFkZXIoX2hlYWRlcik7XG5cbiAgICAgIGlmICghbEhlYWRlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hlYWRlciBuYW1lIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGtleSA9IHV0aWxzLmZpbmRLZXkoc2VsZiwgbEhlYWRlcik7XG5cbiAgICAgIGlmKCFrZXkgfHwgc2VsZltrZXldID09PSB1bmRlZmluZWQgfHwgX3Jld3JpdGUgPT09IHRydWUgfHwgKF9yZXdyaXRlID09PSB1bmRlZmluZWQgJiYgc2VsZltrZXldICE9PSBmYWxzZSkpIHtcbiAgICAgICAgc2VsZltrZXkgfHwgX2hlYWRlcl0gPSBub3JtYWxpemVWYWx1ZShfdmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHNldEhlYWRlcnMgPSAoaGVhZGVycywgX3Jld3JpdGUpID0+XG4gICAgICB1dGlscy5mb3JFYWNoKGhlYWRlcnMsIChfdmFsdWUsIF9oZWFkZXIpID0+IHNldEhlYWRlcihfdmFsdWUsIF9oZWFkZXIsIF9yZXdyaXRlKSk7XG5cbiAgICBpZiAodXRpbHMuaXNQbGFpbk9iamVjdChoZWFkZXIpIHx8IGhlYWRlciBpbnN0YW5jZW9mIHRoaXMuY29uc3RydWN0b3IpIHtcbiAgICAgIHNldEhlYWRlcnMoaGVhZGVyLCB2YWx1ZU9yUmV3cml0ZSlcbiAgICB9IGVsc2UgaWYodXRpbHMuaXNTdHJpbmcoaGVhZGVyKSAmJiAoaGVhZGVyID0gaGVhZGVyLnRyaW0oKSkgJiYgIWlzVmFsaWRIZWFkZXJOYW1lKGhlYWRlcikpIHtcbiAgICAgIHNldEhlYWRlcnMocGFyc2VIZWFkZXJzKGhlYWRlciksIHZhbHVlT3JSZXdyaXRlKTtcbiAgICB9IGVsc2UgaWYgKHV0aWxzLmlzT2JqZWN0KGhlYWRlcikgJiYgdXRpbHMuaXNJdGVyYWJsZShoZWFkZXIpKSB7XG4gICAgICBsZXQgb2JqID0ge30sIGRlc3QsIGtleTtcbiAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgaGVhZGVyKSB7XG4gICAgICAgIGlmICghdXRpbHMuaXNBcnJheShlbnRyeSkpIHtcbiAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ09iamVjdCBpdGVyYXRvciBtdXN0IHJldHVybiBhIGtleS12YWx1ZSBwYWlyJyk7XG4gICAgICAgIH1cblxuICAgICAgICBvYmpba2V5ID0gZW50cnlbMF1dID0gKGRlc3QgPSBvYmpba2V5XSkgP1xuICAgICAgICAgICh1dGlscy5pc0FycmF5KGRlc3QpID8gWy4uLmRlc3QsIGVudHJ5WzFdXSA6IFtkZXN0LCBlbnRyeVsxXV0pIDogZW50cnlbMV07XG4gICAgICB9XG5cbiAgICAgIHNldEhlYWRlcnMob2JqLCB2YWx1ZU9yUmV3cml0ZSlcbiAgICB9IGVsc2Uge1xuICAgICAgaGVhZGVyICE9IG51bGwgJiYgc2V0SGVhZGVyKHZhbHVlT3JSZXdyaXRlLCBoZWFkZXIsIHJld3JpdGUpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZ2V0KGhlYWRlciwgcGFyc2VyKSB7XG4gICAgaGVhZGVyID0gbm9ybWFsaXplSGVhZGVyKGhlYWRlcik7XG5cbiAgICBpZiAoaGVhZGVyKSB7XG4gICAgICBjb25zdCBrZXkgPSB1dGlscy5maW5kS2V5KHRoaXMsIGhlYWRlcik7XG5cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzW2tleV07XG5cbiAgICAgICAgaWYgKCFwYXJzZXIpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFyc2VyID09PSB0cnVlKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlVG9rZW5zKHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1dGlscy5pc0Z1bmN0aW9uKHBhcnNlcikpIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VyLmNhbGwodGhpcywgdmFsdWUsIGtleSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXRpbHMuaXNSZWdFeHAocGFyc2VyKSkge1xuICAgICAgICAgIHJldHVybiBwYXJzZXIuZXhlYyh2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwYXJzZXIgbXVzdCBiZSBib29sZWFufHJlZ2V4cHxmdW5jdGlvbicpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGhhcyhoZWFkZXIsIG1hdGNoZXIpIHtcbiAgICBoZWFkZXIgPSBub3JtYWxpemVIZWFkZXIoaGVhZGVyKTtcblxuICAgIGlmIChoZWFkZXIpIHtcbiAgICAgIGNvbnN0IGtleSA9IHV0aWxzLmZpbmRLZXkodGhpcywgaGVhZGVyKTtcblxuICAgICAgcmV0dXJuICEhKGtleSAmJiB0aGlzW2tleV0gIT09IHVuZGVmaW5lZCAmJiAoIW1hdGNoZXIgfHwgbWF0Y2hIZWFkZXJWYWx1ZSh0aGlzLCB0aGlzW2tleV0sIGtleSwgbWF0Y2hlcikpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBkZWxldGUoaGVhZGVyLCBtYXRjaGVyKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgbGV0IGRlbGV0ZWQgPSBmYWxzZTtcblxuICAgIGZ1bmN0aW9uIGRlbGV0ZUhlYWRlcihfaGVhZGVyKSB7XG4gICAgICBfaGVhZGVyID0gbm9ybWFsaXplSGVhZGVyKF9oZWFkZXIpO1xuXG4gICAgICBpZiAoX2hlYWRlcikge1xuICAgICAgICBjb25zdCBrZXkgPSB1dGlscy5maW5kS2V5KHNlbGYsIF9oZWFkZXIpO1xuXG4gICAgICAgIGlmIChrZXkgJiYgKCFtYXRjaGVyIHx8IG1hdGNoSGVhZGVyVmFsdWUoc2VsZiwgc2VsZltrZXldLCBrZXksIG1hdGNoZXIpKSkge1xuICAgICAgICAgIGRlbGV0ZSBzZWxmW2tleV07XG5cbiAgICAgICAgICBkZWxldGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh1dGlscy5pc0FycmF5KGhlYWRlcikpIHtcbiAgICAgIGhlYWRlci5mb3JFYWNoKGRlbGV0ZUhlYWRlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZUhlYWRlcihoZWFkZXIpO1xuICAgIH1cblxuICAgIHJldHVybiBkZWxldGVkO1xuICB9XG5cbiAgY2xlYXIobWF0Y2hlcikge1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh0aGlzKTtcbiAgICBsZXQgaSA9IGtleXMubGVuZ3RoO1xuICAgIGxldCBkZWxldGVkID0gZmFsc2U7XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgaWYoIW1hdGNoZXIgfHwgbWF0Y2hIZWFkZXJWYWx1ZSh0aGlzLCB0aGlzW2tleV0sIGtleSwgbWF0Y2hlciwgdHJ1ZSkpIHtcbiAgICAgICAgZGVsZXRlIHRoaXNba2V5XTtcbiAgICAgICAgZGVsZXRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlbGV0ZWQ7XG4gIH1cblxuICBub3JtYWxpemUoZm9ybWF0KSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgY29uc3QgaGVhZGVycyA9IHt9O1xuXG4gICAgdXRpbHMuZm9yRWFjaCh0aGlzLCAodmFsdWUsIGhlYWRlcikgPT4ge1xuICAgICAgY29uc3Qga2V5ID0gdXRpbHMuZmluZEtleShoZWFkZXJzLCBoZWFkZXIpO1xuXG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIHNlbGZba2V5XSA9IG5vcm1hbGl6ZVZhbHVlKHZhbHVlKTtcbiAgICAgICAgZGVsZXRlIHNlbGZbaGVhZGVyXTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBub3JtYWxpemVkID0gZm9ybWF0ID8gZm9ybWF0SGVhZGVyKGhlYWRlcikgOiBTdHJpbmcoaGVhZGVyKS50cmltKCk7XG5cbiAgICAgIGlmIChub3JtYWxpemVkICE9PSBoZWFkZXIpIHtcbiAgICAgICAgZGVsZXRlIHNlbGZbaGVhZGVyXTtcbiAgICAgIH1cblxuICAgICAgc2VsZltub3JtYWxpemVkXSA9IG5vcm1hbGl6ZVZhbHVlKHZhbHVlKTtcblxuICAgICAgaGVhZGVyc1tub3JtYWxpemVkXSA9IHRydWU7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGNvbmNhdCguLi50YXJnZXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IuY29uY2F0KHRoaXMsIC4uLnRhcmdldHMpO1xuICB9XG5cbiAgdG9KU09OKGFzU3RyaW5ncykge1xuICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICB1dGlscy5mb3JFYWNoKHRoaXMsICh2YWx1ZSwgaGVhZGVyKSA9PiB7XG4gICAgICB2YWx1ZSAhPSBudWxsICYmIHZhbHVlICE9PSBmYWxzZSAmJiAob2JqW2hlYWRlcl0gPSBhc1N0cmluZ3MgJiYgdXRpbHMuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5qb2luKCcsICcpIDogdmFsdWUpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIHJldHVybiBPYmplY3QuZW50cmllcyh0aGlzLnRvSlNPTigpKVtTeW1ib2wuaXRlcmF0b3JdKCk7XG4gIH1cblxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmVudHJpZXModGhpcy50b0pTT04oKSkubWFwKChbaGVhZGVyLCB2YWx1ZV0pID0+IGhlYWRlciArICc6ICcgKyB2YWx1ZSkuam9pbignXFxuJyk7XG4gIH1cblxuICBnZXRTZXRDb29raWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KFwic2V0LWNvb2tpZVwiKSB8fCBbXTtcbiAgfVxuXG4gIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpIHtcbiAgICByZXR1cm4gJ0F4aW9zSGVhZGVycyc7XG4gIH1cblxuICBzdGF0aWMgZnJvbSh0aGluZykge1xuICAgIHJldHVybiB0aGluZyBpbnN0YW5jZW9mIHRoaXMgPyB0aGluZyA6IG5ldyB0aGlzKHRoaW5nKTtcbiAgfVxuXG4gIHN0YXRpYyBjb25jYXQoZmlyc3QsIC4uLnRhcmdldHMpIHtcbiAgICBjb25zdCBjb21wdXRlZCA9IG5ldyB0aGlzKGZpcnN0KTtcblxuICAgIHRhcmdldHMuZm9yRWFjaCgodGFyZ2V0KSA9PiBjb21wdXRlZC5zZXQodGFyZ2V0KSk7XG5cbiAgICByZXR1cm4gY29tcHV0ZWQ7XG4gIH1cblxuICBzdGF0aWMgYWNjZXNzb3IoaGVhZGVyKSB7XG4gICAgY29uc3QgaW50ZXJuYWxzID0gdGhpc1skaW50ZXJuYWxzXSA9ICh0aGlzWyRpbnRlcm5hbHNdID0ge1xuICAgICAgYWNjZXNzb3JzOiB7fVxuICAgIH0pO1xuXG4gICAgY29uc3QgYWNjZXNzb3JzID0gaW50ZXJuYWxzLmFjY2Vzc29ycztcbiAgICBjb25zdCBwcm90b3R5cGUgPSB0aGlzLnByb3RvdHlwZTtcblxuICAgIGZ1bmN0aW9uIGRlZmluZUFjY2Vzc29yKF9oZWFkZXIpIHtcbiAgICAgIGNvbnN0IGxIZWFkZXIgPSBub3JtYWxpemVIZWFkZXIoX2hlYWRlcik7XG5cbiAgICAgIGlmICghYWNjZXNzb3JzW2xIZWFkZXJdKSB7XG4gICAgICAgIGJ1aWxkQWNjZXNzb3JzKHByb3RvdHlwZSwgX2hlYWRlcik7XG4gICAgICAgIGFjY2Vzc29yc1tsSGVhZGVyXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdXRpbHMuaXNBcnJheShoZWFkZXIpID8gaGVhZGVyLmZvckVhY2goZGVmaW5lQWNjZXNzb3IpIDogZGVmaW5lQWNjZXNzb3IoaGVhZGVyKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG5cbkF4aW9zSGVhZGVycy5hY2Nlc3NvcihbJ0NvbnRlbnQtVHlwZScsICdDb250ZW50LUxlbmd0aCcsICdBY2NlcHQnLCAnQWNjZXB0LUVuY29kaW5nJywgJ1VzZXItQWdlbnQnLCAnQXV0aG9yaXphdGlvbiddKTtcblxuLy8gcmVzZXJ2ZWQgbmFtZXMgaG90Zml4XG51dGlscy5yZWR1Y2VEZXNjcmlwdG9ycyhBeGlvc0hlYWRlcnMucHJvdG90eXBlLCAoe3ZhbHVlfSwga2V5KSA9PiB7XG4gIGxldCBtYXBwZWQgPSBrZXlbMF0udG9VcHBlckNhc2UoKSArIGtleS5zbGljZSgxKTsgLy8gbWFwIGBzZXRgID0+IGBTZXRgXG4gIHJldHVybiB7XG4gICAgZ2V0OiAoKSA9PiB2YWx1ZSxcbiAgICBzZXQoaGVhZGVyVmFsdWUpIHtcbiAgICAgIHRoaXNbbWFwcGVkXSA9IGhlYWRlclZhbHVlO1xuICAgIH1cbiAgfVxufSk7XG5cbnV0aWxzLmZyZWV6ZU1ldGhvZHMoQXhpb3NIZWFkZXJzKTtcblxuZXhwb3J0IGRlZmF1bHQgQXhpb3NIZWFkZXJzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgdXRpbHMgZnJvbSAnLi8uLi91dGlscy5qcyc7XG5pbXBvcnQgZGVmYXVsdHMgZnJvbSAnLi4vZGVmYXVsdHMvaW5kZXguanMnO1xuaW1wb3J0IEF4aW9zSGVhZGVycyBmcm9tICcuLi9jb3JlL0F4aW9zSGVhZGVycy5qcyc7XG5cbi8qKlxuICogVHJhbnNmb3JtIHRoZSBkYXRhIGZvciBhIHJlcXVlc3Qgb3IgYSByZXNwb25zZVxuICpcbiAqIEBwYXJhbSB7QXJyYXl8RnVuY3Rpb259IGZucyBBIHNpbmdsZSBmdW5jdGlvbiBvciBBcnJheSBvZiBmdW5jdGlvbnNcbiAqIEBwYXJhbSB7P09iamVjdH0gcmVzcG9uc2UgVGhlIHJlc3BvbnNlIG9iamVjdFxuICpcbiAqIEByZXR1cm5zIHsqfSBUaGUgcmVzdWx0aW5nIHRyYW5zZm9ybWVkIGRhdGFcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdHJhbnNmb3JtRGF0YShmbnMsIHJlc3BvbnNlKSB7XG4gIGNvbnN0IGNvbmZpZyA9IHRoaXMgfHwgZGVmYXVsdHM7XG4gIGNvbnN0IGNvbnRleHQgPSByZXNwb25zZSB8fCBjb25maWc7XG4gIGNvbnN0IGhlYWRlcnMgPSBBeGlvc0hlYWRlcnMuZnJvbShjb250ZXh0LmhlYWRlcnMpO1xuICBsZXQgZGF0YSA9IGNvbnRleHQuZGF0YTtcblxuICB1dGlscy5mb3JFYWNoKGZucywgZnVuY3Rpb24gdHJhbnNmb3JtKGZuKSB7XG4gICAgZGF0YSA9IGZuLmNhbGwoY29uZmlnLCBkYXRhLCBoZWFkZXJzLm5vcm1hbGl6ZSgpLCByZXNwb25zZSA/IHJlc3BvbnNlLnN0YXR1cyA6IHVuZGVmaW5lZCk7XG4gIH0pO1xuXG4gIGhlYWRlcnMubm9ybWFsaXplKCk7XG5cbiAgcmV0dXJuIGRhdGE7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzQ2FuY2VsKHZhbHVlKSB7XG4gIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZS5fX0NBTkNFTF9fKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IEF4aW9zRXJyb3IgZnJvbSAnLi4vY29yZS9BeGlvc0Vycm9yLmpzJztcbmltcG9ydCB1dGlscyBmcm9tICcuLi91dGlscy5qcyc7XG5cbi8qKlxuICogQSBgQ2FuY2VsZWRFcnJvcmAgaXMgYW4gb2JqZWN0IHRoYXQgaXMgdGhyb3duIHdoZW4gYW4gb3BlcmF0aW9uIGlzIGNhbmNlbGVkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nPX0gbWVzc2FnZSBUaGUgbWVzc2FnZS5cbiAqIEBwYXJhbSB7T2JqZWN0PX0gY29uZmlnIFRoZSBjb25maWcuXG4gKiBAcGFyYW0ge09iamVjdD19IHJlcXVlc3QgVGhlIHJlcXVlc3QuXG4gKlxuICogQHJldHVybnMge0NhbmNlbGVkRXJyb3J9IFRoZSBjcmVhdGVkIGVycm9yLlxuICovXG5mdW5jdGlvbiBDYW5jZWxlZEVycm9yKG1lc3NhZ2UsIGNvbmZpZywgcmVxdWVzdCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZXEtbnVsbCxlcWVxZXFcbiAgQXhpb3NFcnJvci5jYWxsKHRoaXMsIG1lc3NhZ2UgPT0gbnVsbCA/ICdjYW5jZWxlZCcgOiBtZXNzYWdlLCBBeGlvc0Vycm9yLkVSUl9DQU5DRUxFRCwgY29uZmlnLCByZXF1ZXN0KTtcbiAgdGhpcy5uYW1lID0gJ0NhbmNlbGVkRXJyb3InO1xufVxuXG51dGlscy5pbmhlcml0cyhDYW5jZWxlZEVycm9yLCBBeGlvc0Vycm9yLCB7XG4gIF9fQ0FOQ0VMX186IHRydWVcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBDYW5jZWxlZEVycm9yO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgQXhpb3NFcnJvciBmcm9tICcuL0F4aW9zRXJyb3IuanMnO1xuXG4vKipcbiAqIFJlc29sdmUgb3IgcmVqZWN0IGEgUHJvbWlzZSBiYXNlZCBvbiByZXNwb25zZSBzdGF0dXMuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVzb2x2ZSBBIGZ1bmN0aW9uIHRoYXQgcmVzb2x2ZXMgdGhlIHByb21pc2UuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWplY3QgQSBmdW5jdGlvbiB0aGF0IHJlamVjdHMgdGhlIHByb21pc2UuXG4gKiBAcGFyYW0ge29iamVjdH0gcmVzcG9uc2UgVGhlIHJlc3BvbnNlLlxuICpcbiAqIEByZXR1cm5zIHtvYmplY3R9IFRoZSByZXNwb25zZS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgcmVzcG9uc2UpIHtcbiAgY29uc3QgdmFsaWRhdGVTdGF0dXMgPSByZXNwb25zZS5jb25maWcudmFsaWRhdGVTdGF0dXM7XG4gIGlmICghcmVzcG9uc2Uuc3RhdHVzIHx8ICF2YWxpZGF0ZVN0YXR1cyB8fCB2YWxpZGF0ZVN0YXR1cyhyZXNwb25zZS5zdGF0dXMpKSB7XG4gICAgcmVzb2x2ZShyZXNwb25zZSk7XG4gIH0gZWxzZSB7XG4gICAgcmVqZWN0KG5ldyBBeGlvc0Vycm9yKFxuICAgICAgJ1JlcXVlc3QgZmFpbGVkIHdpdGggc3RhdHVzIGNvZGUgJyArIHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgIFtBeGlvc0Vycm9yLkVSUl9CQURfUkVRVUVTVCwgQXhpb3NFcnJvci5FUlJfQkFEX1JFU1BPTlNFXVtNYXRoLmZsb29yKHJlc3BvbnNlLnN0YXR1cyAvIDEwMCkgLSA0XSxcbiAgICAgIHJlc3BvbnNlLmNvbmZpZyxcbiAgICAgIHJlc3BvbnNlLnJlcXVlc3QsXG4gICAgICByZXNwb25zZVxuICAgICkpO1xuICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBzcGVjaWZpZWQgVVJMIGlzIGFic29sdXRlXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgVVJMIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIFVSTCBpcyBhYnNvbHV0ZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzQWJzb2x1dGVVUkwodXJsKSB7XG4gIC8vIEEgVVJMIGlzIGNvbnNpZGVyZWQgYWJzb2x1dGUgaWYgaXQgYmVnaW5zIHdpdGggXCI8c2NoZW1lPjovL1wiIG9yIFwiLy9cIiAocHJvdG9jb2wtcmVsYXRpdmUgVVJMKS5cbiAgLy8gUkZDIDM5ODYgZGVmaW5lcyBzY2hlbWUgbmFtZSBhcyBhIHNlcXVlbmNlIG9mIGNoYXJhY3RlcnMgYmVnaW5uaW5nIHdpdGggYSBsZXR0ZXIgYW5kIGZvbGxvd2VkXG4gIC8vIGJ5IGFueSBjb21iaW5hdGlvbiBvZiBsZXR0ZXJzLCBkaWdpdHMsIHBsdXMsIHBlcmlvZCwgb3IgaHlwaGVuLlxuICByZXR1cm4gL14oW2Etel1bYS16XFxkK1xcLS5dKjopP1xcL1xcLy9pLnRlc3QodXJsKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFVSTCBieSBjb21iaW5pbmcgdGhlIHNwZWNpZmllZCBVUkxzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2VVUkwgVGhlIGJhc2UgVVJMXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVsYXRpdmVVUkwgVGhlIHJlbGF0aXZlIFVSTFxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBjb21iaW5lZCBVUkxcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29tYmluZVVSTHMoYmFzZVVSTCwgcmVsYXRpdmVVUkwpIHtcbiAgcmV0dXJuIHJlbGF0aXZlVVJMXG4gICAgPyBiYXNlVVJMLnJlcGxhY2UoL1xcLz9cXC8kLywgJycpICsgJy8nICsgcmVsYXRpdmVVUkwucmVwbGFjZSgvXlxcLysvLCAnJylcbiAgICA6IGJhc2VVUkw7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBpc0Fic29sdXRlVVJMIGZyb20gJy4uL2hlbHBlcnMvaXNBYnNvbHV0ZVVSTC5qcyc7XG5pbXBvcnQgY29tYmluZVVSTHMgZnJvbSAnLi4vaGVscGVycy9jb21iaW5lVVJMcy5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBVUkwgYnkgY29tYmluaW5nIHRoZSBiYXNlVVJMIHdpdGggdGhlIHJlcXVlc3RlZFVSTCxcbiAqIG9ubHkgd2hlbiB0aGUgcmVxdWVzdGVkVVJMIGlzIG5vdCBhbHJlYWR5IGFuIGFic29sdXRlIFVSTC5cbiAqIElmIHRoZSByZXF1ZXN0VVJMIGlzIGFic29sdXRlLCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIHJlcXVlc3RlZFVSTCB1bnRvdWNoZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2VVUkwgVGhlIGJhc2UgVVJMXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVxdWVzdGVkVVJMIEFic29sdXRlIG9yIHJlbGF0aXZlIFVSTCB0byBjb21iaW5lXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGNvbWJpbmVkIGZ1bGwgcGF0aFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBidWlsZEZ1bGxQYXRoKGJhc2VVUkwsIHJlcXVlc3RlZFVSTCwgYWxsb3dBYnNvbHV0ZVVybHMpIHtcbiAgbGV0IGlzUmVsYXRpdmVVcmwgPSAhaXNBYnNvbHV0ZVVSTChyZXF1ZXN0ZWRVUkwpO1xuICBpZiAoYmFzZVVSTCAmJiAoaXNSZWxhdGl2ZVVybCB8fCBhbGxvd0Fic29sdXRlVXJscyA9PSBmYWxzZSkpIHtcbiAgICByZXR1cm4gY29tYmluZVVSTHMoYmFzZVVSTCwgcmVxdWVzdGVkVVJMKTtcbiAgfVxuICByZXR1cm4gcmVxdWVzdGVkVVJMO1xufVxuIiwiZXhwb3J0IGNvbnN0IFZFUlNJT04gPSBcIjEuMTIuMlwiOyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcGFyc2VQcm90b2NvbCh1cmwpIHtcbiAgY29uc3QgbWF0Y2ggPSAvXihbLStcXHddezEsMjV9KSg6P1xcL1xcL3w6KS8uZXhlYyh1cmwpO1xuICByZXR1cm4gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBBeGlvc0Vycm9yIGZyb20gJy4uL2NvcmUvQXhpb3NFcnJvci5qcyc7XG5pbXBvcnQgcGFyc2VQcm90b2NvbCBmcm9tICcuL3BhcnNlUHJvdG9jb2wuanMnO1xuaW1wb3J0IHBsYXRmb3JtIGZyb20gJy4uL3BsYXRmb3JtL2luZGV4LmpzJztcblxuY29uc3QgREFUQV9VUkxfUEFUVEVSTiA9IC9eKD86KFteO10rKTspPyg/OlteO10rOyk/KGJhc2U2NHwpLChbXFxzXFxTXSopJC87XG5cbi8qKlxuICogUGFyc2UgZGF0YSB1cmkgdG8gYSBCdWZmZXIgb3IgQmxvYlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmlcbiAqIEBwYXJhbSB7P0Jvb2xlYW59IGFzQmxvYlxuICogQHBhcmFtIHs/T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0gez9GdW5jdGlvbn0gb3B0aW9ucy5CbG9iXG4gKlxuICogQHJldHVybnMge0J1ZmZlcnxCbG9ifVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBmcm9tRGF0YVVSSSh1cmksIGFzQmxvYiwgb3B0aW9ucykge1xuICBjb25zdCBfQmxvYiA9IG9wdGlvbnMgJiYgb3B0aW9ucy5CbG9iIHx8IHBsYXRmb3JtLmNsYXNzZXMuQmxvYjtcbiAgY29uc3QgcHJvdG9jb2wgPSBwYXJzZVByb3RvY29sKHVyaSk7XG5cbiAgaWYgKGFzQmxvYiA9PT0gdW5kZWZpbmVkICYmIF9CbG9iKSB7XG4gICAgYXNCbG9iID0gdHJ1ZTtcbiAgfVxuXG4gIGlmIChwcm90b2NvbCA9PT0gJ2RhdGEnKSB7XG4gICAgdXJpID0gcHJvdG9jb2wubGVuZ3RoID8gdXJpLnNsaWNlKHByb3RvY29sLmxlbmd0aCArIDEpIDogdXJpO1xuXG4gICAgY29uc3QgbWF0Y2ggPSBEQVRBX1VSTF9QQVRURVJOLmV4ZWModXJpKTtcblxuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgIHRocm93IG5ldyBBeGlvc0Vycm9yKCdJbnZhbGlkIFVSTCcsIEF4aW9zRXJyb3IuRVJSX0lOVkFMSURfVVJMKTtcbiAgICB9XG5cbiAgICBjb25zdCBtaW1lID0gbWF0Y2hbMV07XG4gICAgY29uc3QgaXNCYXNlNjQgPSBtYXRjaFsyXTtcbiAgICBjb25zdCBib2R5ID0gbWF0Y2hbM107XG4gICAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmZyb20oZGVjb2RlVVJJQ29tcG9uZW50KGJvZHkpLCBpc0Jhc2U2NCA/ICdiYXNlNjQnIDogJ3V0ZjgnKTtcblxuICAgIGlmIChhc0Jsb2IpIHtcbiAgICAgIGlmICghX0Jsb2IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEF4aW9zRXJyb3IoJ0Jsb2IgaXMgbm90IHN1cHBvcnRlZCcsIEF4aW9zRXJyb3IuRVJSX05PVF9TVVBQT1JUKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBfQmxvYihbYnVmZmVyXSwge3R5cGU6IG1pbWV9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gYnVmZmVyO1xuICB9XG5cbiAgdGhyb3cgbmV3IEF4aW9zRXJyb3IoJ1Vuc3VwcG9ydGVkIHByb3RvY29sICcgKyBwcm90b2NvbCwgQXhpb3NFcnJvci5FUlJfTk9UX1NVUFBPUlQpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgc3RyZWFtIGZyb20gJ3N0cmVhbSc7XG5pbXBvcnQgdXRpbHMgZnJvbSAnLi4vdXRpbHMuanMnO1xuXG5jb25zdCBrSW50ZXJuYWxzID0gU3ltYm9sKCdpbnRlcm5hbHMnKTtcblxuY2xhc3MgQXhpb3NUcmFuc2Zvcm1TdHJlYW0gZXh0ZW5kcyBzdHJlYW0uVHJhbnNmb3Jte1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHV0aWxzLnRvRmxhdE9iamVjdChvcHRpb25zLCB7XG4gICAgICBtYXhSYXRlOiAwLFxuICAgICAgY2h1bmtTaXplOiA2NCAqIDEwMjQsXG4gICAgICBtaW5DaHVua1NpemU6IDEwMCxcbiAgICAgIHRpbWVXaW5kb3c6IDUwMCxcbiAgICAgIHRpY2tzUmF0ZTogMixcbiAgICAgIHNhbXBsZXNDb3VudDogMTVcbiAgICB9LCBudWxsLCAocHJvcCwgc291cmNlKSA9PiB7XG4gICAgICByZXR1cm4gIXV0aWxzLmlzVW5kZWZpbmVkKHNvdXJjZVtwcm9wXSk7XG4gICAgfSk7XG5cbiAgICBzdXBlcih7XG4gICAgICByZWFkYWJsZUhpZ2hXYXRlck1hcms6IG9wdGlvbnMuY2h1bmtTaXplXG4gICAgfSk7XG5cbiAgICBjb25zdCBpbnRlcm5hbHMgPSB0aGlzW2tJbnRlcm5hbHNdID0ge1xuICAgICAgdGltZVdpbmRvdzogb3B0aW9ucy50aW1lV2luZG93LFxuICAgICAgY2h1bmtTaXplOiBvcHRpb25zLmNodW5rU2l6ZSxcbiAgICAgIG1heFJhdGU6IG9wdGlvbnMubWF4UmF0ZSxcbiAgICAgIG1pbkNodW5rU2l6ZTogb3B0aW9ucy5taW5DaHVua1NpemUsXG4gICAgICBieXRlc1NlZW46IDAsXG4gICAgICBpc0NhcHR1cmVkOiBmYWxzZSxcbiAgICAgIG5vdGlmaWVkQnl0ZXNMb2FkZWQ6IDAsXG4gICAgICB0czogRGF0ZS5ub3coKSxcbiAgICAgIGJ5dGVzOiAwLFxuICAgICAgb25SZWFkQ2FsbGJhY2s6IG51bGxcbiAgICB9O1xuXG4gICAgdGhpcy5vbignbmV3TGlzdGVuZXInLCBldmVudCA9PiB7XG4gICAgICBpZiAoZXZlbnQgPT09ICdwcm9ncmVzcycpIHtcbiAgICAgICAgaWYgKCFpbnRlcm5hbHMuaXNDYXB0dXJlZCkge1xuICAgICAgICAgIGludGVybmFscy5pc0NhcHR1cmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgX3JlYWQoc2l6ZSkge1xuICAgIGNvbnN0IGludGVybmFscyA9IHRoaXNba0ludGVybmFsc107XG5cbiAgICBpZiAoaW50ZXJuYWxzLm9uUmVhZENhbGxiYWNrKSB7XG4gICAgICBpbnRlcm5hbHMub25SZWFkQ2FsbGJhY2soKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3VwZXIuX3JlYWQoc2l6ZSk7XG4gIH1cblxuICBfdHJhbnNmb3JtKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spIHtcbiAgICBjb25zdCBpbnRlcm5hbHMgPSB0aGlzW2tJbnRlcm5hbHNdO1xuICAgIGNvbnN0IG1heFJhdGUgPSBpbnRlcm5hbHMubWF4UmF0ZTtcblxuICAgIGNvbnN0IHJlYWRhYmxlSGlnaFdhdGVyTWFyayA9IHRoaXMucmVhZGFibGVIaWdoV2F0ZXJNYXJrO1xuXG4gICAgY29uc3QgdGltZVdpbmRvdyA9IGludGVybmFscy50aW1lV2luZG93O1xuXG4gICAgY29uc3QgZGl2aWRlciA9IDEwMDAgLyB0aW1lV2luZG93O1xuICAgIGNvbnN0IGJ5dGVzVGhyZXNob2xkID0gKG1heFJhdGUgLyBkaXZpZGVyKTtcbiAgICBjb25zdCBtaW5DaHVua1NpemUgPSBpbnRlcm5hbHMubWluQ2h1bmtTaXplICE9PSBmYWxzZSA/IE1hdGgubWF4KGludGVybmFscy5taW5DaHVua1NpemUsIGJ5dGVzVGhyZXNob2xkICogMC4wMSkgOiAwO1xuXG4gICAgY29uc3QgcHVzaENodW5rID0gKF9jaHVuaywgX2NhbGxiYWNrKSA9PiB7XG4gICAgICBjb25zdCBieXRlcyA9IEJ1ZmZlci5ieXRlTGVuZ3RoKF9jaHVuayk7XG4gICAgICBpbnRlcm5hbHMuYnl0ZXNTZWVuICs9IGJ5dGVzO1xuICAgICAgaW50ZXJuYWxzLmJ5dGVzICs9IGJ5dGVzO1xuXG4gICAgICBpbnRlcm5hbHMuaXNDYXB0dXJlZCAmJiB0aGlzLmVtaXQoJ3Byb2dyZXNzJywgaW50ZXJuYWxzLmJ5dGVzU2Vlbik7XG5cbiAgICAgIGlmICh0aGlzLnB1c2goX2NodW5rKSkge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKF9jYWxsYmFjayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnRlcm5hbHMub25SZWFkQ2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgICAgaW50ZXJuYWxzLm9uUmVhZENhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKF9jYWxsYmFjayk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgdHJhbnNmb3JtQ2h1bmsgPSAoX2NodW5rLCBfY2FsbGJhY2spID0+IHtcbiAgICAgIGNvbnN0IGNodW5rU2l6ZSA9IEJ1ZmZlci5ieXRlTGVuZ3RoKF9jaHVuayk7XG4gICAgICBsZXQgY2h1bmtSZW1haW5kZXIgPSBudWxsO1xuICAgICAgbGV0IG1heENodW5rU2l6ZSA9IHJlYWRhYmxlSGlnaFdhdGVyTWFyaztcbiAgICAgIGxldCBieXRlc0xlZnQ7XG4gICAgICBsZXQgcGFzc2VkID0gMDtcblxuICAgICAgaWYgKG1heFJhdGUpIHtcbiAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcblxuICAgICAgICBpZiAoIWludGVybmFscy50cyB8fCAocGFzc2VkID0gKG5vdyAtIGludGVybmFscy50cykpID49IHRpbWVXaW5kb3cpIHtcbiAgICAgICAgICBpbnRlcm5hbHMudHMgPSBub3c7XG4gICAgICAgICAgYnl0ZXNMZWZ0ID0gYnl0ZXNUaHJlc2hvbGQgLSBpbnRlcm5hbHMuYnl0ZXM7XG4gICAgICAgICAgaW50ZXJuYWxzLmJ5dGVzID0gYnl0ZXNMZWZ0IDwgMCA/IC1ieXRlc0xlZnQgOiAwO1xuICAgICAgICAgIHBhc3NlZCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBieXRlc0xlZnQgPSBieXRlc1RocmVzaG9sZCAtIGludGVybmFscy5ieXRlcztcbiAgICAgIH1cblxuICAgICAgaWYgKG1heFJhdGUpIHtcbiAgICAgICAgaWYgKGJ5dGVzTGVmdCA8PSAwKSB7XG4gICAgICAgICAgLy8gbmV4dCB0aW1lIHdpbmRvd1xuICAgICAgICAgIHJldHVybiBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIF9jYWxsYmFjayhudWxsLCBfY2h1bmspO1xuICAgICAgICAgIH0sIHRpbWVXaW5kb3cgLSBwYXNzZWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJ5dGVzTGVmdCA8IG1heENodW5rU2l6ZSkge1xuICAgICAgICAgIG1heENodW5rU2l6ZSA9IGJ5dGVzTGVmdDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobWF4Q2h1bmtTaXplICYmIGNodW5rU2l6ZSA+IG1heENodW5rU2l6ZSAmJiAoY2h1bmtTaXplIC0gbWF4Q2h1bmtTaXplKSA+IG1pbkNodW5rU2l6ZSkge1xuICAgICAgICBjaHVua1JlbWFpbmRlciA9IF9jaHVuay5zdWJhcnJheShtYXhDaHVua1NpemUpO1xuICAgICAgICBfY2h1bmsgPSBfY2h1bmsuc3ViYXJyYXkoMCwgbWF4Q2h1bmtTaXplKTtcbiAgICAgIH1cblxuICAgICAgcHVzaENodW5rKF9jaHVuaywgY2h1bmtSZW1haW5kZXIgPyAoKSA9PiB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soX2NhbGxiYWNrLCBudWxsLCBjaHVua1JlbWFpbmRlcik7XG4gICAgICB9IDogX2NhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgdHJhbnNmb3JtQ2h1bmsoY2h1bmssIGZ1bmN0aW9uIHRyYW5zZm9ybU5leHRDaHVuayhlcnIsIF9jaHVuaykge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKF9jaHVuaykge1xuICAgICAgICB0cmFuc2Zvcm1DaHVuayhfY2h1bmssIHRyYW5zZm9ybU5leHRDaHVuayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBBeGlvc1RyYW5zZm9ybVN0cmVhbTtcbiIsImNvbnN0IHthc3luY0l0ZXJhdG9yfSA9IFN5bWJvbDtcblxuY29uc3QgcmVhZEJsb2IgPSBhc3luYyBmdW5jdGlvbiogKGJsb2IpIHtcbiAgaWYgKGJsb2Iuc3RyZWFtKSB7XG4gICAgeWllbGQqIGJsb2Iuc3RyZWFtKClcbiAgfSBlbHNlIGlmIChibG9iLmFycmF5QnVmZmVyKSB7XG4gICAgeWllbGQgYXdhaXQgYmxvYi5hcnJheUJ1ZmZlcigpXG4gIH0gZWxzZSBpZiAoYmxvYlthc3luY0l0ZXJhdG9yXSkge1xuICAgIHlpZWxkKiBibG9iW2FzeW5jSXRlcmF0b3JdKCk7XG4gIH0gZWxzZSB7XG4gICAgeWllbGQgYmxvYjtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCByZWFkQmxvYjtcbiIsImltcG9ydCB1dGlsIGZyb20gJ3V0aWwnO1xuaW1wb3J0IHtSZWFkYWJsZX0gZnJvbSAnc3RyZWFtJztcbmltcG9ydCB1dGlscyBmcm9tIFwiLi4vdXRpbHMuanNcIjtcbmltcG9ydCByZWFkQmxvYiBmcm9tIFwiLi9yZWFkQmxvYi5qc1wiO1xuaW1wb3J0IHBsYXRmb3JtIGZyb20gXCIuLi9wbGF0Zm9ybS9pbmRleC5qc1wiO1xuXG5jb25zdCBCT1VOREFSWV9BTFBIQUJFVCA9IHBsYXRmb3JtLkFMUEhBQkVULkFMUEhBX0RJR0lUICsgJy1fJztcblxuY29uc3QgdGV4dEVuY29kZXIgPSB0eXBlb2YgVGV4dEVuY29kZXIgPT09ICdmdW5jdGlvbicgPyBuZXcgVGV4dEVuY29kZXIoKSA6IG5ldyB1dGlsLlRleHRFbmNvZGVyKCk7XG5cbmNvbnN0IENSTEYgPSAnXFxyXFxuJztcbmNvbnN0IENSTEZfQllURVMgPSB0ZXh0RW5jb2Rlci5lbmNvZGUoQ1JMRik7XG5jb25zdCBDUkxGX0JZVEVTX0NPVU5UID0gMjtcblxuY2xhc3MgRm9ybURhdGFQYXJ0IHtcbiAgY29uc3RydWN0b3IobmFtZSwgdmFsdWUpIHtcbiAgICBjb25zdCB7ZXNjYXBlTmFtZX0gPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgIGNvbnN0IGlzU3RyaW5nVmFsdWUgPSB1dGlscy5pc1N0cmluZyh2YWx1ZSk7XG5cbiAgICBsZXQgaGVhZGVycyA9IGBDb250ZW50LURpc3Bvc2l0aW9uOiBmb3JtLWRhdGE7IG5hbWU9XCIke2VzY2FwZU5hbWUobmFtZSl9XCIke1xuICAgICAgIWlzU3RyaW5nVmFsdWUgJiYgdmFsdWUubmFtZSA/IGA7IGZpbGVuYW1lPVwiJHtlc2NhcGVOYW1lKHZhbHVlLm5hbWUpfVwiYCA6ICcnXG4gICAgfSR7Q1JMRn1gO1xuXG4gICAgaWYgKGlzU3RyaW5nVmFsdWUpIHtcbiAgICAgIHZhbHVlID0gdGV4dEVuY29kZXIuZW5jb2RlKFN0cmluZyh2YWx1ZSkucmVwbGFjZSgvXFxyP1xcbnxcXHJcXG4/L2csIENSTEYpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGVhZGVycyArPSBgQ29udGVudC1UeXBlOiAke3ZhbHVlLnR5cGUgfHwgXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIn0ke0NSTEZ9YFxuICAgIH1cblxuICAgIHRoaXMuaGVhZGVycyA9IHRleHRFbmNvZGVyLmVuY29kZShoZWFkZXJzICsgQ1JMRik7XG5cbiAgICB0aGlzLmNvbnRlbnRMZW5ndGggPSBpc1N0cmluZ1ZhbHVlID8gdmFsdWUuYnl0ZUxlbmd0aCA6IHZhbHVlLnNpemU7XG5cbiAgICB0aGlzLnNpemUgPSB0aGlzLmhlYWRlcnMuYnl0ZUxlbmd0aCArIHRoaXMuY29udGVudExlbmd0aCArIENSTEZfQllURVNfQ09VTlQ7XG5cbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgfVxuXG4gIGFzeW5jICplbmNvZGUoKXtcbiAgICB5aWVsZCB0aGlzLmhlYWRlcnM7XG5cbiAgICBjb25zdCB7dmFsdWV9ID0gdGhpcztcblxuICAgIGlmKHV0aWxzLmlzVHlwZWRBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHlpZWxkIHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB5aWVsZCogcmVhZEJsb2IodmFsdWUpO1xuICAgIH1cblxuICAgIHlpZWxkIENSTEZfQllURVM7XG4gIH1cblxuICBzdGF0aWMgZXNjYXBlTmFtZShuYW1lKSB7XG4gICAgICByZXR1cm4gU3RyaW5nKG5hbWUpLnJlcGxhY2UoL1tcXHJcXG5cIl0vZywgKG1hdGNoKSA9PiAoe1xuICAgICAgICAnXFxyJyA6ICclMEQnLFxuICAgICAgICAnXFxuJyA6ICclMEEnLFxuICAgICAgICAnXCInIDogJyUyMicsXG4gICAgICB9W21hdGNoXSkpO1xuICB9XG59XG5cbmNvbnN0IGZvcm1EYXRhVG9TdHJlYW0gPSAoZm9ybSwgaGVhZGVyc0hhbmRsZXIsIG9wdGlvbnMpID0+IHtcbiAgY29uc3Qge1xuICAgIHRhZyA9ICdmb3JtLWRhdGEtYm91bmRhcnknLFxuICAgIHNpemUgPSAyNSxcbiAgICBib3VuZGFyeSA9IHRhZyArICctJyArIHBsYXRmb3JtLmdlbmVyYXRlU3RyaW5nKHNpemUsIEJPVU5EQVJZX0FMUEhBQkVUKVxuICB9ID0gb3B0aW9ucyB8fCB7fTtcblxuICBpZighdXRpbHMuaXNGb3JtRGF0YShmb3JtKSkge1xuICAgIHRocm93IFR5cGVFcnJvcignRm9ybURhdGEgaW5zdGFuY2UgcmVxdWlyZWQnKTtcbiAgfVxuXG4gIGlmIChib3VuZGFyeS5sZW5ndGggPCAxIHx8IGJvdW5kYXJ5Lmxlbmd0aCA+IDcwKSB7XG4gICAgdGhyb3cgRXJyb3IoJ2JvdW5kYXJ5IG11c3QgYmUgMTAtNzAgY2hhcmFjdGVycyBsb25nJylcbiAgfVxuXG4gIGNvbnN0IGJvdW5kYXJ5Qnl0ZXMgPSB0ZXh0RW5jb2Rlci5lbmNvZGUoJy0tJyArIGJvdW5kYXJ5ICsgQ1JMRik7XG4gIGNvbnN0IGZvb3RlckJ5dGVzID0gdGV4dEVuY29kZXIuZW5jb2RlKCctLScgKyBib3VuZGFyeSArICctLScgKyBDUkxGKTtcbiAgbGV0IGNvbnRlbnRMZW5ndGggPSBmb290ZXJCeXRlcy5ieXRlTGVuZ3RoO1xuXG4gIGNvbnN0IHBhcnRzID0gQXJyYXkuZnJvbShmb3JtLmVudHJpZXMoKSkubWFwKChbbmFtZSwgdmFsdWVdKSA9PiB7XG4gICAgY29uc3QgcGFydCA9IG5ldyBGb3JtRGF0YVBhcnQobmFtZSwgdmFsdWUpO1xuICAgIGNvbnRlbnRMZW5ndGggKz0gcGFydC5zaXplO1xuICAgIHJldHVybiBwYXJ0O1xuICB9KTtcblxuICBjb250ZW50TGVuZ3RoICs9IGJvdW5kYXJ5Qnl0ZXMuYnl0ZUxlbmd0aCAqIHBhcnRzLmxlbmd0aDtcblxuICBjb250ZW50TGVuZ3RoID0gdXRpbHMudG9GaW5pdGVOdW1iZXIoY29udGVudExlbmd0aCk7XG5cbiAgY29uc3QgY29tcHV0ZWRIZWFkZXJzID0ge1xuICAgICdDb250ZW50LVR5cGUnOiBgbXVsdGlwYXJ0L2Zvcm0tZGF0YTsgYm91bmRhcnk9JHtib3VuZGFyeX1gXG4gIH1cblxuICBpZiAoTnVtYmVyLmlzRmluaXRlKGNvbnRlbnRMZW5ndGgpKSB7XG4gICAgY29tcHV0ZWRIZWFkZXJzWydDb250ZW50LUxlbmd0aCddID0gY29udGVudExlbmd0aDtcbiAgfVxuXG4gIGhlYWRlcnNIYW5kbGVyICYmIGhlYWRlcnNIYW5kbGVyKGNvbXB1dGVkSGVhZGVycyk7XG5cbiAgcmV0dXJuIFJlYWRhYmxlLmZyb20oKGFzeW5jIGZ1bmN0aW9uICooKSB7XG4gICAgZm9yKGNvbnN0IHBhcnQgb2YgcGFydHMpIHtcbiAgICAgIHlpZWxkIGJvdW5kYXJ5Qnl0ZXM7XG4gICAgICB5aWVsZCogcGFydC5lbmNvZGUoKTtcbiAgICB9XG5cbiAgICB5aWVsZCBmb290ZXJCeXRlcztcbiAgfSkoKSk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBmb3JtRGF0YVRvU3RyZWFtO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBzdHJlYW0gZnJvbSBcInN0cmVhbVwiO1xuXG5jbGFzcyBabGliSGVhZGVyVHJhbnNmb3JtU3RyZWFtIGV4dGVuZHMgc3RyZWFtLlRyYW5zZm9ybSB7XG4gIF9fdHJhbnNmb3JtKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spIHtcbiAgICB0aGlzLnB1c2goY2h1bmspO1xuICAgIGNhbGxiYWNrKCk7XG4gIH1cblxuICBfdHJhbnNmb3JtKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spIHtcbiAgICBpZiAoY2h1bmsubGVuZ3RoICE9PSAwKSB7XG4gICAgICB0aGlzLl90cmFuc2Zvcm0gPSB0aGlzLl9fdHJhbnNmb3JtO1xuXG4gICAgICAvLyBBZGQgRGVmYXVsdCBDb21wcmVzc2lvbiBoZWFkZXJzIGlmIG5vIHpsaWIgaGVhZGVycyBhcmUgcHJlc2VudFxuICAgICAgaWYgKGNodW5rWzBdICE9PSAxMjApIHsgLy8gSGV4OiA3OFxuICAgICAgICBjb25zdCBoZWFkZXIgPSBCdWZmZXIuYWxsb2MoMik7XG4gICAgICAgIGhlYWRlclswXSA9IDEyMDsgLy8gSGV4OiA3OFxuICAgICAgICBoZWFkZXJbMV0gPSAxNTY7IC8vIEhleDogOUMgXG4gICAgICAgIHRoaXMucHVzaChoZWFkZXIsIGVuY29kaW5nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9fdHJhbnNmb3JtKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFpsaWJIZWFkZXJUcmFuc2Zvcm1TdHJlYW07XG4iLCJpbXBvcnQgdXRpbHMgZnJvbSBcIi4uL3V0aWxzLmpzXCI7XG5cbmNvbnN0IGNhbGxiYWNraWZ5ID0gKGZuLCByZWR1Y2VyKSA9PiB7XG4gIHJldHVybiB1dGlscy5pc0FzeW5jRm4oZm4pID8gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICBjb25zdCBjYiA9IGFyZ3MucG9wKCk7XG4gICAgZm4uYXBwbHkodGhpcywgYXJncykudGhlbigodmFsdWUpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlZHVjZXIgPyBjYihudWxsLCAuLi5yZWR1Y2VyKHZhbHVlKSkgOiBjYihudWxsLCB2YWx1ZSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY2IoZXJyKTtcbiAgICAgIH1cbiAgICB9LCBjYik7XG4gIH0gOiBmbjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2FsbGJhY2tpZnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ2FsY3VsYXRlIGRhdGEgbWF4UmF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IFtzYW1wbGVzQ291bnQ9IDEwXVxuICogQHBhcmFtIHtOdW1iZXJ9IFttaW49IDEwMDBdXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKi9cbmZ1bmN0aW9uIHNwZWVkb21ldGVyKHNhbXBsZXNDb3VudCwgbWluKSB7XG4gIHNhbXBsZXNDb3VudCA9IHNhbXBsZXNDb3VudCB8fCAxMDtcbiAgY29uc3QgYnl0ZXMgPSBuZXcgQXJyYXkoc2FtcGxlc0NvdW50KTtcbiAgY29uc3QgdGltZXN0YW1wcyA9IG5ldyBBcnJheShzYW1wbGVzQ291bnQpO1xuICBsZXQgaGVhZCA9IDA7XG4gIGxldCB0YWlsID0gMDtcbiAgbGV0IGZpcnN0U2FtcGxlVFM7XG5cbiAgbWluID0gbWluICE9PSB1bmRlZmluZWQgPyBtaW4gOiAxMDAwO1xuXG4gIHJldHVybiBmdW5jdGlvbiBwdXNoKGNodW5rTGVuZ3RoKSB7XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcblxuICAgIGNvbnN0IHN0YXJ0ZWRBdCA9IHRpbWVzdGFtcHNbdGFpbF07XG5cbiAgICBpZiAoIWZpcnN0U2FtcGxlVFMpIHtcbiAgICAgIGZpcnN0U2FtcGxlVFMgPSBub3c7XG4gICAgfVxuXG4gICAgYnl0ZXNbaGVhZF0gPSBjaHVua0xlbmd0aDtcbiAgICB0aW1lc3RhbXBzW2hlYWRdID0gbm93O1xuXG4gICAgbGV0IGkgPSB0YWlsO1xuICAgIGxldCBieXRlc0NvdW50ID0gMDtcblxuICAgIHdoaWxlIChpICE9PSBoZWFkKSB7XG4gICAgICBieXRlc0NvdW50ICs9IGJ5dGVzW2krK107XG4gICAgICBpID0gaSAlIHNhbXBsZXNDb3VudDtcbiAgICB9XG5cbiAgICBoZWFkID0gKGhlYWQgKyAxKSAlIHNhbXBsZXNDb3VudDtcblxuICAgIGlmIChoZWFkID09PSB0YWlsKSB7XG4gICAgICB0YWlsID0gKHRhaWwgKyAxKSAlIHNhbXBsZXNDb3VudDtcbiAgICB9XG5cbiAgICBpZiAobm93IC0gZmlyc3RTYW1wbGVUUyA8IG1pbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHBhc3NlZCA9IHN0YXJ0ZWRBdCAmJiBub3cgLSBzdGFydGVkQXQ7XG5cbiAgICByZXR1cm4gcGFzc2VkID8gTWF0aC5yb3VuZChieXRlc0NvdW50ICogMTAwMCAvIHBhc3NlZCkgOiB1bmRlZmluZWQ7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IHNwZWVkb21ldGVyO1xuIiwiLyoqXG4gKiBUaHJvdHRsZSBkZWNvcmF0b3JcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcGFyYW0ge051bWJlcn0gZnJlcVxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cbmZ1bmN0aW9uIHRocm90dGxlKGZuLCBmcmVxKSB7XG4gIGxldCB0aW1lc3RhbXAgPSAwO1xuICBsZXQgdGhyZXNob2xkID0gMTAwMCAvIGZyZXE7XG4gIGxldCBsYXN0QXJncztcbiAgbGV0IHRpbWVyO1xuXG4gIGNvbnN0IGludm9rZSA9IChhcmdzLCBub3cgPSBEYXRlLm5vdygpKSA9PiB7XG4gICAgdGltZXN0YW1wID0gbm93O1xuICAgIGxhc3RBcmdzID0gbnVsbDtcbiAgICBpZiAodGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICB0aW1lciA9IG51bGw7XG4gICAgfVxuICAgIGZuKC4uLmFyZ3MpO1xuICB9XG5cbiAgY29uc3QgdGhyb3R0bGVkID0gKC4uLmFyZ3MpID0+IHtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IHBhc3NlZCA9IG5vdyAtIHRpbWVzdGFtcDtcbiAgICBpZiAoIHBhc3NlZCA+PSB0aHJlc2hvbGQpIHtcbiAgICAgIGludm9rZShhcmdzLCBub3cpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsYXN0QXJncyA9IGFyZ3M7XG4gICAgICBpZiAoIXRpbWVyKSB7XG4gICAgICAgIHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGltZXIgPSBudWxsO1xuICAgICAgICAgIGludm9rZShsYXN0QXJncylcbiAgICAgICAgfSwgdGhyZXNob2xkIC0gcGFzc2VkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25zdCBmbHVzaCA9ICgpID0+IGxhc3RBcmdzICYmIGludm9rZShsYXN0QXJncyk7XG5cbiAgcmV0dXJuIFt0aHJvdHRsZWQsIGZsdXNoXTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdGhyb3R0bGU7XG4iLCJpbXBvcnQgc3BlZWRvbWV0ZXIgZnJvbSBcIi4vc3BlZWRvbWV0ZXIuanNcIjtcbmltcG9ydCB0aHJvdHRsZSBmcm9tIFwiLi90aHJvdHRsZS5qc1wiO1xuaW1wb3J0IHV0aWxzIGZyb20gXCIuLi91dGlscy5qc1wiO1xuXG5leHBvcnQgY29uc3QgcHJvZ3Jlc3NFdmVudFJlZHVjZXIgPSAobGlzdGVuZXIsIGlzRG93bmxvYWRTdHJlYW0sIGZyZXEgPSAzKSA9PiB7XG4gIGxldCBieXRlc05vdGlmaWVkID0gMDtcbiAgY29uc3QgX3NwZWVkb21ldGVyID0gc3BlZWRvbWV0ZXIoNTAsIDI1MCk7XG5cbiAgcmV0dXJuIHRocm90dGxlKGUgPT4ge1xuICAgIGNvbnN0IGxvYWRlZCA9IGUubG9hZGVkO1xuICAgIGNvbnN0IHRvdGFsID0gZS5sZW5ndGhDb21wdXRhYmxlID8gZS50b3RhbCA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBwcm9ncmVzc0J5dGVzID0gbG9hZGVkIC0gYnl0ZXNOb3RpZmllZDtcbiAgICBjb25zdCByYXRlID0gX3NwZWVkb21ldGVyKHByb2dyZXNzQnl0ZXMpO1xuICAgIGNvbnN0IGluUmFuZ2UgPSBsb2FkZWQgPD0gdG90YWw7XG5cbiAgICBieXRlc05vdGlmaWVkID0gbG9hZGVkO1xuXG4gICAgY29uc3QgZGF0YSA9IHtcbiAgICAgIGxvYWRlZCxcbiAgICAgIHRvdGFsLFxuICAgICAgcHJvZ3Jlc3M6IHRvdGFsID8gKGxvYWRlZCAvIHRvdGFsKSA6IHVuZGVmaW5lZCxcbiAgICAgIGJ5dGVzOiBwcm9ncmVzc0J5dGVzLFxuICAgICAgcmF0ZTogcmF0ZSA/IHJhdGUgOiB1bmRlZmluZWQsXG4gICAgICBlc3RpbWF0ZWQ6IHJhdGUgJiYgdG90YWwgJiYgaW5SYW5nZSA/ICh0b3RhbCAtIGxvYWRlZCkgLyByYXRlIDogdW5kZWZpbmVkLFxuICAgICAgZXZlbnQ6IGUsXG4gICAgICBsZW5ndGhDb21wdXRhYmxlOiB0b3RhbCAhPSBudWxsLFxuICAgICAgW2lzRG93bmxvYWRTdHJlYW0gPyAnZG93bmxvYWQnIDogJ3VwbG9hZCddOiB0cnVlXG4gICAgfTtcblxuICAgIGxpc3RlbmVyKGRhdGEpO1xuICB9LCBmcmVxKTtcbn1cblxuZXhwb3J0IGNvbnN0IHByb2dyZXNzRXZlbnREZWNvcmF0b3IgPSAodG90YWwsIHRocm90dGxlZCkgPT4ge1xuICBjb25zdCBsZW5ndGhDb21wdXRhYmxlID0gdG90YWwgIT0gbnVsbDtcblxuICByZXR1cm4gWyhsb2FkZWQpID0+IHRocm90dGxlZFswXSh7XG4gICAgbGVuZ3RoQ29tcHV0YWJsZSxcbiAgICB0b3RhbCxcbiAgICBsb2FkZWRcbiAgfSksIHRocm90dGxlZFsxXV07XG59XG5cbmV4cG9ydCBjb25zdCBhc3luY0RlY29yYXRvciA9IChmbikgPT4gKC4uLmFyZ3MpID0+IHV0aWxzLmFzYXAoKCkgPT4gZm4oLi4uYXJncykpO1xuIiwiLyoqXG4gKiBFc3RpbWF0ZSBkZWNvZGVkIGJ5dGUgbGVuZ3RoIG9mIGEgZGF0YTovLyBVUkwgKndpdGhvdXQqIGFsbG9jYXRpbmcgbGFyZ2UgYnVmZmVycy5cbiAqIC0gRm9yIGJhc2U2NDogY29tcHV0ZSBleGFjdCBkZWNvZGVkIHNpemUgdXNpbmcgbGVuZ3RoIGFuZCBwYWRkaW5nO1xuICogICAgICAgICAgICAgICBoYW5kbGUgJVhYIGF0IHRoZSBjaGFyYWN0ZXItY291bnQgbGV2ZWwgKG5vIHN0cmluZyBhbGxvY2F0aW9uKS5cbiAqIC0gRm9yIG5vbi1iYXNlNjQ6IHVzZSBVVEYtOCBieXRlTGVuZ3RoIG9mIHRoZSBlbmNvZGVkIGJvZHkgYXMgYSBzYWZlIHVwcGVyIGJvdW5kLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGVzdGltYXRlRGF0YVVSTERlY29kZWRCeXRlcyh1cmwpIHtcbiAgaWYgKCF1cmwgfHwgdHlwZW9mIHVybCAhPT0gJ3N0cmluZycpIHJldHVybiAwO1xuICBpZiAoIXVybC5zdGFydHNXaXRoKCdkYXRhOicpKSByZXR1cm4gMDtcblxuICBjb25zdCBjb21tYSA9IHVybC5pbmRleE9mKCcsJyk7XG4gIGlmIChjb21tYSA8IDApIHJldHVybiAwO1xuXG4gIGNvbnN0IG1ldGEgPSB1cmwuc2xpY2UoNSwgY29tbWEpO1xuICBjb25zdCBib2R5ID0gdXJsLnNsaWNlKGNvbW1hICsgMSk7XG4gIGNvbnN0IGlzQmFzZTY0ID0gLztiYXNlNjQvaS50ZXN0KG1ldGEpO1xuXG4gIGlmIChpc0Jhc2U2NCkge1xuICAgIGxldCBlZmZlY3RpdmVMZW4gPSBib2R5Lmxlbmd0aDtcbiAgICBjb25zdCBsZW4gPSBib2R5Lmxlbmd0aDsgLy8gY2FjaGUgbGVuZ3RoXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoYm9keS5jaGFyQ29kZUF0KGkpID09PSAzNyAvKiAnJScgKi8gJiYgaSArIDIgPCBsZW4pIHtcbiAgICAgICAgY29uc3QgYSA9IGJvZHkuY2hhckNvZGVBdChpICsgMSk7XG4gICAgICAgIGNvbnN0IGIgPSBib2R5LmNoYXJDb2RlQXQoaSArIDIpO1xuICAgICAgICBjb25zdCBpc0hleCA9XG4gICAgICAgICAgKChhID49IDQ4ICYmIGEgPD0gNTcpIHx8IChhID49IDY1ICYmIGEgPD0gNzApIHx8IChhID49IDk3ICYmIGEgPD0gMTAyKSkgJiZcbiAgICAgICAgICAoKGIgPj0gNDggJiYgYiA8PSA1NykgfHwgKGIgPj0gNjUgJiYgYiA8PSA3MCkgfHwgKGIgPj0gOTcgJiYgYiA8PSAxMDIpKTtcblxuICAgICAgICBpZiAoaXNIZXgpIHtcbiAgICAgICAgICBlZmZlY3RpdmVMZW4gLT0gMjtcbiAgICAgICAgICBpICs9IDI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgcGFkID0gMDtcbiAgICBsZXQgaWR4ID0gbGVuIC0gMTtcblxuICAgIGNvbnN0IHRhaWxJc1BjdDNEID0gKGopID0+XG4gICAgICBqID49IDIgJiZcbiAgICAgIGJvZHkuY2hhckNvZGVBdChqIC0gMikgPT09IDM3ICYmIC8vICclJ1xuICAgICAgYm9keS5jaGFyQ29kZUF0KGogLSAxKSA9PT0gNTEgJiYgLy8gJzMnXG4gICAgICAoYm9keS5jaGFyQ29kZUF0KGopID09PSA2OCB8fCBib2R5LmNoYXJDb2RlQXQoaikgPT09IDEwMCk7IC8vICdEJyBvciAnZCdcblxuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgaWYgKGJvZHkuY2hhckNvZGVBdChpZHgpID09PSA2MSAvKiAnPScgKi8pIHtcbiAgICAgICAgcGFkKys7XG4gICAgICAgIGlkeC0tO1xuICAgICAgfSBlbHNlIGlmICh0YWlsSXNQY3QzRChpZHgpKSB7XG4gICAgICAgIHBhZCsrO1xuICAgICAgICBpZHggLT0gMztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocGFkID09PSAxICYmIGlkeCA+PSAwKSB7XG4gICAgICBpZiAoYm9keS5jaGFyQ29kZUF0KGlkeCkgPT09IDYxIC8qICc9JyAqLykge1xuICAgICAgICBwYWQrKztcbiAgICAgIH0gZWxzZSBpZiAodGFpbElzUGN0M0QoaWR4KSkge1xuICAgICAgICBwYWQrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBncm91cHMgPSBNYXRoLmZsb29yKGVmZmVjdGl2ZUxlbiAvIDQpO1xuICAgIGNvbnN0IGJ5dGVzID0gZ3JvdXBzICogMyAtIChwYWQgfHwgMCk7XG4gICAgcmV0dXJuIGJ5dGVzID4gMCA/IGJ5dGVzIDogMDtcbiAgfVxuXG4gIHJldHVybiBCdWZmZXIuYnl0ZUxlbmd0aChib2R5LCAndXRmOCcpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgdXRpbHMgZnJvbSAnLi8uLi91dGlscy5qcyc7XG5pbXBvcnQgc2V0dGxlIGZyb20gJy4vLi4vY29yZS9zZXR0bGUuanMnO1xuaW1wb3J0IGJ1aWxkRnVsbFBhdGggZnJvbSAnLi4vY29yZS9idWlsZEZ1bGxQYXRoLmpzJztcbmltcG9ydCBidWlsZFVSTCBmcm9tICcuLy4uL2hlbHBlcnMvYnVpbGRVUkwuanMnO1xuaW1wb3J0IHByb3h5RnJvbUVudiBmcm9tICdwcm94eS1mcm9tLWVudic7XG5pbXBvcnQgaHR0cCBmcm9tICdodHRwJztcbmltcG9ydCBodHRwcyBmcm9tICdodHRwcyc7XG5pbXBvcnQgdXRpbCBmcm9tICd1dGlsJztcbmltcG9ydCBmb2xsb3dSZWRpcmVjdHMgZnJvbSAnZm9sbG93LXJlZGlyZWN0cyc7XG5pbXBvcnQgemxpYiBmcm9tICd6bGliJztcbmltcG9ydCB7VkVSU0lPTn0gZnJvbSAnLi4vZW52L2RhdGEuanMnO1xuaW1wb3J0IHRyYW5zaXRpb25hbERlZmF1bHRzIGZyb20gJy4uL2RlZmF1bHRzL3RyYW5zaXRpb25hbC5qcyc7XG5pbXBvcnQgQXhpb3NFcnJvciBmcm9tICcuLi9jb3JlL0F4aW9zRXJyb3IuanMnO1xuaW1wb3J0IENhbmNlbGVkRXJyb3IgZnJvbSAnLi4vY2FuY2VsL0NhbmNlbGVkRXJyb3IuanMnO1xuaW1wb3J0IHBsYXRmb3JtIGZyb20gJy4uL3BsYXRmb3JtL2luZGV4LmpzJztcbmltcG9ydCBmcm9tRGF0YVVSSSBmcm9tICcuLi9oZWxwZXJzL2Zyb21EYXRhVVJJLmpzJztcbmltcG9ydCBzdHJlYW0gZnJvbSAnc3RyZWFtJztcbmltcG9ydCBBeGlvc0hlYWRlcnMgZnJvbSAnLi4vY29yZS9BeGlvc0hlYWRlcnMuanMnO1xuaW1wb3J0IEF4aW9zVHJhbnNmb3JtU3RyZWFtIGZyb20gJy4uL2hlbHBlcnMvQXhpb3NUcmFuc2Zvcm1TdHJlYW0uanMnO1xuaW1wb3J0IHtFdmVudEVtaXR0ZXJ9IGZyb20gJ2V2ZW50cyc7XG5pbXBvcnQgZm9ybURhdGFUb1N0cmVhbSBmcm9tIFwiLi4vaGVscGVycy9mb3JtRGF0YVRvU3RyZWFtLmpzXCI7XG5pbXBvcnQgcmVhZEJsb2IgZnJvbSBcIi4uL2hlbHBlcnMvcmVhZEJsb2IuanNcIjtcbmltcG9ydCBabGliSGVhZGVyVHJhbnNmb3JtU3RyZWFtIGZyb20gJy4uL2hlbHBlcnMvWmxpYkhlYWRlclRyYW5zZm9ybVN0cmVhbS5qcyc7XG5pbXBvcnQgY2FsbGJhY2tpZnkgZnJvbSBcIi4uL2hlbHBlcnMvY2FsbGJhY2tpZnkuanNcIjtcbmltcG9ydCB7cHJvZ3Jlc3NFdmVudFJlZHVjZXIsIHByb2dyZXNzRXZlbnREZWNvcmF0b3IsIGFzeW5jRGVjb3JhdG9yfSBmcm9tIFwiLi4vaGVscGVycy9wcm9ncmVzc0V2ZW50UmVkdWNlci5qc1wiO1xuaW1wb3J0IGVzdGltYXRlRGF0YVVSTERlY29kZWRCeXRlcyBmcm9tICcuLi9oZWxwZXJzL2VzdGltYXRlRGF0YVVSTERlY29kZWRCeXRlcy5qcyc7XG5cbmNvbnN0IHpsaWJPcHRpb25zID0ge1xuICBmbHVzaDogemxpYi5jb25zdGFudHMuWl9TWU5DX0ZMVVNILFxuICBmaW5pc2hGbHVzaDogemxpYi5jb25zdGFudHMuWl9TWU5DX0ZMVVNIXG59O1xuXG5jb25zdCBicm90bGlPcHRpb25zID0ge1xuICBmbHVzaDogemxpYi5jb25zdGFudHMuQlJPVExJX09QRVJBVElPTl9GTFVTSCxcbiAgZmluaXNoRmx1c2g6IHpsaWIuY29uc3RhbnRzLkJST1RMSV9PUEVSQVRJT05fRkxVU0hcbn1cblxuY29uc3QgaXNCcm90bGlTdXBwb3J0ZWQgPSB1dGlscy5pc0Z1bmN0aW9uKHpsaWIuY3JlYXRlQnJvdGxpRGVjb21wcmVzcyk7XG5cbmNvbnN0IHtodHRwOiBodHRwRm9sbG93LCBodHRwczogaHR0cHNGb2xsb3d9ID0gZm9sbG93UmVkaXJlY3RzO1xuXG5jb25zdCBpc0h0dHBzID0gL2h0dHBzOj8vO1xuXG5jb25zdCBzdXBwb3J0ZWRQcm90b2NvbHMgPSBwbGF0Zm9ybS5wcm90b2NvbHMubWFwKHByb3RvY29sID0+IHtcbiAgcmV0dXJuIHByb3RvY29sICsgJzonO1xufSk7XG5cblxuY29uc3QgZmx1c2hPbkZpbmlzaCA9IChzdHJlYW0sIFt0aHJvdHRsZWQsIGZsdXNoXSkgPT4ge1xuICBzdHJlYW1cbiAgICAub24oJ2VuZCcsIGZsdXNoKVxuICAgIC5vbignZXJyb3InLCBmbHVzaCk7XG5cbiAgcmV0dXJuIHRocm90dGxlZDtcbn1cblxuXG4vKipcbiAqIElmIHRoZSBwcm94eSBvciBjb25maWcgYmVmb3JlUmVkaXJlY3RzIGZ1bmN0aW9ucyBhcmUgZGVmaW5lZCwgY2FsbCB0aGVtIHdpdGggdGhlIG9wdGlvbnNcbiAqIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsIGFueT59IG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBvYmplY3QgdGhhdCB3YXMgcGFzc2VkIHRvIHRoZSByZXF1ZXN0LlxuICpcbiAqIEByZXR1cm5zIHtPYmplY3Q8c3RyaW5nLCBhbnk+fVxuICovXG5mdW5jdGlvbiBkaXNwYXRjaEJlZm9yZVJlZGlyZWN0KG9wdGlvbnMsIHJlc3BvbnNlRGV0YWlscykge1xuICBpZiAob3B0aW9ucy5iZWZvcmVSZWRpcmVjdHMucHJveHkpIHtcbiAgICBvcHRpb25zLmJlZm9yZVJlZGlyZWN0cy5wcm94eShvcHRpb25zKTtcbiAgfVxuICBpZiAob3B0aW9ucy5iZWZvcmVSZWRpcmVjdHMuY29uZmlnKSB7XG4gICAgb3B0aW9ucy5iZWZvcmVSZWRpcmVjdHMuY29uZmlnKG9wdGlvbnMsIHJlc3BvbnNlRGV0YWlscyk7XG4gIH1cbn1cblxuLyoqXG4gKiBJZiB0aGUgcHJveHkgb3IgY29uZmlnIGFmdGVyUmVkaXJlY3RzIGZ1bmN0aW9ucyBhcmUgZGVmaW5lZCwgY2FsbCB0aGVtIHdpdGggdGhlIG9wdGlvbnNcbiAqXG4gKiBAcGFyYW0ge2h0dHAuQ2xpZW50UmVxdWVzdEFyZ3N9IG9wdGlvbnNcbiAqIEBwYXJhbSB7QXhpb3NQcm94eUNvbmZpZ30gY29uZmlnUHJveHkgY29uZmlndXJhdGlvbiBmcm9tIEF4aW9zIG9wdGlvbnMgb2JqZWN0XG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb25cbiAqXG4gKiBAcmV0dXJucyB7aHR0cC5DbGllbnRSZXF1ZXN0QXJnc31cbiAqL1xuZnVuY3Rpb24gc2V0UHJveHkob3B0aW9ucywgY29uZmlnUHJveHksIGxvY2F0aW9uKSB7XG4gIGxldCBwcm94eSA9IGNvbmZpZ1Byb3h5O1xuICBpZiAoIXByb3h5ICYmIHByb3h5ICE9PSBmYWxzZSkge1xuICAgIGNvbnN0IHByb3h5VXJsID0gcHJveHlGcm9tRW52LmdldFByb3h5Rm9yVXJsKGxvY2F0aW9uKTtcbiAgICBpZiAocHJveHlVcmwpIHtcbiAgICAgIHByb3h5ID0gbmV3IFVSTChwcm94eVVybCk7XG4gICAgfVxuICB9XG4gIGlmIChwcm94eSkge1xuICAgIC8vIEJhc2ljIHByb3h5IGF1dGhvcml6YXRpb25cbiAgICBpZiAocHJveHkudXNlcm5hbWUpIHtcbiAgICAgIHByb3h5LmF1dGggPSAocHJveHkudXNlcm5hbWUgfHwgJycpICsgJzonICsgKHByb3h5LnBhc3N3b3JkIHx8ICcnKTtcbiAgICB9XG5cbiAgICBpZiAocHJveHkuYXV0aCkge1xuICAgICAgLy8gU3VwcG9ydCBwcm94eSBhdXRoIG9iamVjdCBmb3JtXG4gICAgICBpZiAocHJveHkuYXV0aC51c2VybmFtZSB8fCBwcm94eS5hdXRoLnBhc3N3b3JkKSB7XG4gICAgICAgIHByb3h5LmF1dGggPSAocHJveHkuYXV0aC51c2VybmFtZSB8fCAnJykgKyAnOicgKyAocHJveHkuYXV0aC5wYXNzd29yZCB8fCAnJyk7XG4gICAgICB9XG4gICAgICBjb25zdCBiYXNlNjQgPSBCdWZmZXJcbiAgICAgICAgLmZyb20ocHJveHkuYXV0aCwgJ3V0ZjgnKVxuICAgICAgICAudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgICAgb3B0aW9ucy5oZWFkZXJzWydQcm94eS1BdXRob3JpemF0aW9uJ10gPSAnQmFzaWMgJyArIGJhc2U2NDtcbiAgICB9XG5cbiAgICBvcHRpb25zLmhlYWRlcnMuaG9zdCA9IG9wdGlvbnMuaG9zdG5hbWUgKyAob3B0aW9ucy5wb3J0ID8gJzonICsgb3B0aW9ucy5wb3J0IDogJycpO1xuICAgIGNvbnN0IHByb3h5SG9zdCA9IHByb3h5Lmhvc3RuYW1lIHx8IHByb3h5Lmhvc3Q7XG4gICAgb3B0aW9ucy5ob3N0bmFtZSA9IHByb3h5SG9zdDtcbiAgICAvLyBSZXBsYWNlICdob3N0JyBzaW5jZSBvcHRpb25zIGlzIG5vdCBhIFVSTCBvYmplY3RcbiAgICBvcHRpb25zLmhvc3QgPSBwcm94eUhvc3Q7XG4gICAgb3B0aW9ucy5wb3J0ID0gcHJveHkucG9ydDtcbiAgICBvcHRpb25zLnBhdGggPSBsb2NhdGlvbjtcbiAgICBpZiAocHJveHkucHJvdG9jb2wpIHtcbiAgICAgIG9wdGlvbnMucHJvdG9jb2wgPSBwcm94eS5wcm90b2NvbC5pbmNsdWRlcygnOicpID8gcHJveHkucHJvdG9jb2wgOiBgJHtwcm94eS5wcm90b2NvbH06YDtcbiAgICB9XG4gIH1cblxuICBvcHRpb25zLmJlZm9yZVJlZGlyZWN0cy5wcm94eSA9IGZ1bmN0aW9uIGJlZm9yZVJlZGlyZWN0KHJlZGlyZWN0T3B0aW9ucykge1xuICAgIC8vIENvbmZpZ3VyZSBwcm94eSBmb3IgcmVkaXJlY3RlZCByZXF1ZXN0LCBwYXNzaW5nIHRoZSBvcmlnaW5hbCBjb25maWcgcHJveHkgdG8gYXBwbHlcbiAgICAvLyB0aGUgZXhhY3Qgc2FtZSBsb2dpYyBhcyBpZiB0aGUgcmVkaXJlY3RlZCByZXF1ZXN0IHdhcyBwZXJmb3JtZWQgYnkgYXhpb3MgZGlyZWN0bHkuXG4gICAgc2V0UHJveHkocmVkaXJlY3RPcHRpb25zLCBjb25maWdQcm94eSwgcmVkaXJlY3RPcHRpb25zLmhyZWYpO1xuICB9O1xufVxuXG5jb25zdCBpc0h0dHBBZGFwdGVyU3VwcG9ydGVkID0gdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHV0aWxzLmtpbmRPZihwcm9jZXNzKSA9PT0gJ3Byb2Nlc3MnO1xuXG4vLyB0ZW1wb3JhcnkgaG90Zml4XG5cbmNvbnN0IHdyYXBBc3luYyA9IChhc3luY0V4ZWN1dG9yKSA9PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgbGV0IG9uRG9uZTtcbiAgICBsZXQgaXNEb25lO1xuXG4gICAgY29uc3QgZG9uZSA9ICh2YWx1ZSwgaXNSZWplY3RlZCkgPT4ge1xuICAgICAgaWYgKGlzRG9uZSkgcmV0dXJuO1xuICAgICAgaXNEb25lID0gdHJ1ZTtcbiAgICAgIG9uRG9uZSAmJiBvbkRvbmUodmFsdWUsIGlzUmVqZWN0ZWQpO1xuICAgIH1cblxuICAgIGNvbnN0IF9yZXNvbHZlID0gKHZhbHVlKSA9PiB7XG4gICAgICBkb25lKHZhbHVlKTtcbiAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgIH07XG5cbiAgICBjb25zdCBfcmVqZWN0ID0gKHJlYXNvbikgPT4ge1xuICAgICAgZG9uZShyZWFzb24sIHRydWUpO1xuICAgICAgcmVqZWN0KHJlYXNvbik7XG4gICAgfVxuXG4gICAgYXN5bmNFeGVjdXRvcihfcmVzb2x2ZSwgX3JlamVjdCwgKG9uRG9uZUhhbmRsZXIpID0+IChvbkRvbmUgPSBvbkRvbmVIYW5kbGVyKSkuY2F0Y2goX3JlamVjdCk7XG4gIH0pXG59O1xuXG5jb25zdCByZXNvbHZlRmFtaWx5ID0gKHthZGRyZXNzLCBmYW1pbHl9KSA9PiB7XG4gIGlmICghdXRpbHMuaXNTdHJpbmcoYWRkcmVzcykpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2FkZHJlc3MgbXVzdCBiZSBhIHN0cmluZycpO1xuICB9XG4gIHJldHVybiAoe1xuICAgIGFkZHJlc3MsXG4gICAgZmFtaWx5OiBmYW1pbHkgfHwgKGFkZHJlc3MuaW5kZXhPZignLicpIDwgMCA/IDYgOiA0KVxuICB9KTtcbn1cblxuY29uc3QgYnVpbGRBZGRyZXNzRW50cnkgPSAoYWRkcmVzcywgZmFtaWx5KSA9PiByZXNvbHZlRmFtaWx5KHV0aWxzLmlzT2JqZWN0KGFkZHJlc3MpID8gYWRkcmVzcyA6IHthZGRyZXNzLCBmYW1pbHl9KTtcblxuLyplc2xpbnQgY29uc2lzdGVudC1yZXR1cm46MCovXG5leHBvcnQgZGVmYXVsdCBpc0h0dHBBZGFwdGVyU3VwcG9ydGVkICYmIGZ1bmN0aW9uIGh0dHBBZGFwdGVyKGNvbmZpZykge1xuICByZXR1cm4gd3JhcEFzeW5jKGFzeW5jIGZ1bmN0aW9uIGRpc3BhdGNoSHR0cFJlcXVlc3QocmVzb2x2ZSwgcmVqZWN0LCBvbkRvbmUpIHtcbiAgICBsZXQge2RhdGEsIGxvb2t1cCwgZmFtaWx5fSA9IGNvbmZpZztcbiAgICBjb25zdCB7cmVzcG9uc2VUeXBlLCByZXNwb25zZUVuY29kaW5nfSA9IGNvbmZpZztcbiAgICBjb25zdCBtZXRob2QgPSBjb25maWcubWV0aG9kLnRvVXBwZXJDYXNlKCk7XG4gICAgbGV0IGlzRG9uZTtcbiAgICBsZXQgcmVqZWN0ZWQgPSBmYWxzZTtcbiAgICBsZXQgcmVxO1xuXG4gICAgaWYgKGxvb2t1cCkge1xuICAgICAgY29uc3QgX2xvb2t1cCA9IGNhbGxiYWNraWZ5KGxvb2t1cCwgKHZhbHVlKSA9PiB1dGlscy5pc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlXSk7XG4gICAgICAvLyBob3RmaXggdG8gc3VwcG9ydCBvcHQuYWxsIG9wdGlvbiB3aGljaCBpcyByZXF1aXJlZCBmb3Igbm9kZSAyMC54XG4gICAgICBsb29rdXAgPSAoaG9zdG5hbWUsIG9wdCwgY2IpID0+IHtcbiAgICAgICAgX2xvb2t1cChob3N0bmFtZSwgb3B0LCAoZXJyLCBhcmcwLCBhcmcxKSA9PiB7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIGNiKGVycik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgYWRkcmVzc2VzID0gdXRpbHMuaXNBcnJheShhcmcwKSA/IGFyZzAubWFwKGFkZHIgPT4gYnVpbGRBZGRyZXNzRW50cnkoYWRkcikpIDogW2J1aWxkQWRkcmVzc0VudHJ5KGFyZzAsIGFyZzEpXTtcblxuICAgICAgICAgIG9wdC5hbGwgPyBjYihlcnIsIGFkZHJlc3NlcykgOiBjYihlcnIsIGFkZHJlc3Nlc1swXS5hZGRyZXNzLCBhZGRyZXNzZXNbMF0uZmFtaWx5KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gdGVtcG9yYXJ5IGludGVybmFsIGVtaXR0ZXIgdW50aWwgdGhlIEF4aW9zUmVxdWVzdCBjbGFzcyB3aWxsIGJlIGltcGxlbWVudGVkXG4gICAgY29uc3QgZW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAgIGNvbnN0IG9uRmluaXNoZWQgPSAoKSA9PiB7XG4gICAgICBpZiAoY29uZmlnLmNhbmNlbFRva2VuKSB7XG4gICAgICAgIGNvbmZpZy5jYW5jZWxUb2tlbi51bnN1YnNjcmliZShhYm9ydCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjb25maWcuc2lnbmFsKSB7XG4gICAgICAgIGNvbmZpZy5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydCk7XG4gICAgICB9XG5cbiAgICAgIGVtaXR0ZXIucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgfVxuXG4gICAgb25Eb25lKCh2YWx1ZSwgaXNSZWplY3RlZCkgPT4ge1xuICAgICAgaXNEb25lID0gdHJ1ZTtcbiAgICAgIGlmIChpc1JlamVjdGVkKSB7XG4gICAgICAgIHJlamVjdGVkID0gdHJ1ZTtcbiAgICAgICAgb25GaW5pc2hlZCgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gYWJvcnQocmVhc29uKSB7XG4gICAgICBlbWl0dGVyLmVtaXQoJ2Fib3J0JywgIXJlYXNvbiB8fCByZWFzb24udHlwZSA/IG5ldyBDYW5jZWxlZEVycm9yKG51bGwsIGNvbmZpZywgcmVxKSA6IHJlYXNvbik7XG4gICAgfVxuXG4gICAgZW1pdHRlci5vbmNlKCdhYm9ydCcsIHJlamVjdCk7XG5cbiAgICBpZiAoY29uZmlnLmNhbmNlbFRva2VuIHx8IGNvbmZpZy5zaWduYWwpIHtcbiAgICAgIGNvbmZpZy5jYW5jZWxUb2tlbiAmJiBjb25maWcuY2FuY2VsVG9rZW4uc3Vic2NyaWJlKGFib3J0KTtcbiAgICAgIGlmIChjb25maWcuc2lnbmFsKSB7XG4gICAgICAgIGNvbmZpZy5zaWduYWwuYWJvcnRlZCA/IGFib3J0KCkgOiBjb25maWcuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFBhcnNlIHVybFxuICAgIGNvbnN0IGZ1bGxQYXRoID0gYnVpbGRGdWxsUGF0aChjb25maWcuYmFzZVVSTCwgY29uZmlnLnVybCwgY29uZmlnLmFsbG93QWJzb2x1dGVVcmxzKTtcbiAgICBjb25zdCBwYXJzZWQgPSBuZXcgVVJMKGZ1bGxQYXRoLCBwbGF0Zm9ybS5oYXNCcm93c2VyRW52ID8gcGxhdGZvcm0ub3JpZ2luIDogdW5kZWZpbmVkKTtcbiAgICBjb25zdCBwcm90b2NvbCA9IHBhcnNlZC5wcm90b2NvbCB8fCBzdXBwb3J0ZWRQcm90b2NvbHNbMF07XG5cbiAgICBpZiAocHJvdG9jb2wgPT09ICdkYXRhOicpIHtcbiAgICAgIC8vIEFwcGx5IHRoZSBzYW1lIHNlbWFudGljcyBhcyBIVFRQOiBvbmx5IGVuZm9yY2UgaWYgYSBmaW5pdGUsIG5vbi1uZWdhdGl2ZSBjYXAgaXMgc2V0LlxuICAgICAgaWYgKGNvbmZpZy5tYXhDb250ZW50TGVuZ3RoID4gLTEpIHtcbiAgICAgICAgLy8gVXNlIHRoZSBleGFjdCBzdHJpbmcgcGFzc2VkIHRvIGZyb21EYXRhVVJJIChjb25maWcudXJsKTsgZmFsbCBiYWNrIHRvIGZ1bGxQYXRoIGlmIG5lZWRlZC5cbiAgICAgICAgY29uc3QgZGF0YVVybCA9IFN0cmluZyhjb25maWcudXJsIHx8IGZ1bGxQYXRoIHx8ICcnKTtcbiAgICAgICAgY29uc3QgZXN0aW1hdGVkID0gZXN0aW1hdGVEYXRhVVJMRGVjb2RlZEJ5dGVzKGRhdGFVcmwpO1xuXG4gICAgICAgIGlmIChlc3RpbWF0ZWQgPiBjb25maWcubWF4Q29udGVudExlbmd0aCkge1xuICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEF4aW9zRXJyb3IoXG4gICAgICAgICAgICAnbWF4Q29udGVudExlbmd0aCBzaXplIG9mICcgKyBjb25maWcubWF4Q29udGVudExlbmd0aCArICcgZXhjZWVkZWQnLFxuICAgICAgICAgICAgQXhpb3NFcnJvci5FUlJfQkFEX1JFU1BPTlNFLFxuICAgICAgICAgICAgY29uZmlnXG4gICAgICAgICAgKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGV0IGNvbnZlcnRlZERhdGE7XG5cbiAgICAgIGlmIChtZXRob2QgIT09ICdHRVQnKSB7XG4gICAgICAgIHJldHVybiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB7XG4gICAgICAgICAgc3RhdHVzOiA0MDUsXG4gICAgICAgICAgc3RhdHVzVGV4dDogJ21ldGhvZCBub3QgYWxsb3dlZCcsXG4gICAgICAgICAgaGVhZGVyczoge30sXG4gICAgICAgICAgY29uZmlnXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICBjb252ZXJ0ZWREYXRhID0gZnJvbURhdGFVUkkoY29uZmlnLnVybCwgcmVzcG9uc2VUeXBlID09PSAnYmxvYicsIHtcbiAgICAgICAgICBCbG9iOiBjb25maWcuZW52ICYmIGNvbmZpZy5lbnYuQmxvYlxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aHJvdyBBeGlvc0Vycm9yLmZyb20oZXJyLCBBeGlvc0Vycm9yLkVSUl9CQURfUkVRVUVTVCwgY29uZmlnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlc3BvbnNlVHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgIGNvbnZlcnRlZERhdGEgPSBjb252ZXJ0ZWREYXRhLnRvU3RyaW5nKHJlc3BvbnNlRW5jb2RpbmcpO1xuXG4gICAgICAgIGlmICghcmVzcG9uc2VFbmNvZGluZyB8fCByZXNwb25zZUVuY29kaW5nID09PSAndXRmOCcpIHtcbiAgICAgICAgICBjb252ZXJ0ZWREYXRhID0gdXRpbHMuc3RyaXBCT00oY29udmVydGVkRGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocmVzcG9uc2VUeXBlID09PSAnc3RyZWFtJykge1xuICAgICAgICBjb252ZXJ0ZWREYXRhID0gc3RyZWFtLlJlYWRhYmxlLmZyb20oY29udmVydGVkRGF0YSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB7XG4gICAgICAgIGRhdGE6IGNvbnZlcnRlZERhdGEsXG4gICAgICAgIHN0YXR1czogMjAwLFxuICAgICAgICBzdGF0dXNUZXh0OiAnT0snLFxuICAgICAgICBoZWFkZXJzOiBuZXcgQXhpb3NIZWFkZXJzKCksXG4gICAgICAgIGNvbmZpZ1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHN1cHBvcnRlZFByb3RvY29scy5pbmRleE9mKHByb3RvY29sKSA9PT0gLTEpIHtcbiAgICAgIHJldHVybiByZWplY3QobmV3IEF4aW9zRXJyb3IoXG4gICAgICAgICdVbnN1cHBvcnRlZCBwcm90b2NvbCAnICsgcHJvdG9jb2wsXG4gICAgICAgIEF4aW9zRXJyb3IuRVJSX0JBRF9SRVFVRVNULFxuICAgICAgICBjb25maWdcbiAgICAgICkpO1xuICAgIH1cblxuICAgIGNvbnN0IGhlYWRlcnMgPSBBeGlvc0hlYWRlcnMuZnJvbShjb25maWcuaGVhZGVycykubm9ybWFsaXplKCk7XG5cbiAgICAvLyBTZXQgVXNlci1BZ2VudCAocmVxdWlyZWQgYnkgc29tZSBzZXJ2ZXJzKVxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vYXhpb3MvYXhpb3MvaXNzdWVzLzY5XG4gICAgLy8gVXNlci1BZ2VudCBpcyBzcGVjaWZpZWQ7IGhhbmRsZSBjYXNlIHdoZXJlIG5vIFVBIGhlYWRlciBpcyBkZXNpcmVkXG4gICAgLy8gT25seSBzZXQgaGVhZGVyIGlmIGl0IGhhc24ndCBiZWVuIHNldCBpbiBjb25maWdcbiAgICBoZWFkZXJzLnNldCgnVXNlci1BZ2VudCcsICdheGlvcy8nICsgVkVSU0lPTiwgZmFsc2UpO1xuXG4gICAgY29uc3Qge29uVXBsb2FkUHJvZ3Jlc3MsIG9uRG93bmxvYWRQcm9ncmVzc30gPSBjb25maWc7XG4gICAgY29uc3QgbWF4UmF0ZSA9IGNvbmZpZy5tYXhSYXRlO1xuICAgIGxldCBtYXhVcGxvYWRSYXRlID0gdW5kZWZpbmVkO1xuICAgIGxldCBtYXhEb3dubG9hZFJhdGUgPSB1bmRlZmluZWQ7XG5cbiAgICAvLyBzdXBwb3J0IGZvciBzcGVjIGNvbXBsaWFudCBGb3JtRGF0YSBvYmplY3RzXG4gICAgaWYgKHV0aWxzLmlzU3BlY0NvbXBsaWFudEZvcm0oZGF0YSkpIHtcbiAgICAgIGNvbnN0IHVzZXJCb3VuZGFyeSA9IGhlYWRlcnMuZ2V0Q29udGVudFR5cGUoL2JvdW5kYXJ5PShbLV9cXHdcXGRdezEwLDcwfSkvaSk7XG5cbiAgICAgIGRhdGEgPSBmb3JtRGF0YVRvU3RyZWFtKGRhdGEsIChmb3JtSGVhZGVycykgPT4ge1xuICAgICAgICBoZWFkZXJzLnNldChmb3JtSGVhZGVycyk7XG4gICAgICB9LCB7XG4gICAgICAgIHRhZzogYGF4aW9zLSR7VkVSU0lPTn0tYm91bmRhcnlgLFxuICAgICAgICBib3VuZGFyeTogdXNlckJvdW5kYXJ5ICYmIHVzZXJCb3VuZGFyeVsxXSB8fCB1bmRlZmluZWRcbiAgICAgIH0pO1xuICAgICAgLy8gc3VwcG9ydCBmb3IgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZm9ybS1kYXRhIGFwaVxuICAgIH0gZWxzZSBpZiAodXRpbHMuaXNGb3JtRGF0YShkYXRhKSAmJiB1dGlscy5pc0Z1bmN0aW9uKGRhdGEuZ2V0SGVhZGVycykpIHtcbiAgICAgIGhlYWRlcnMuc2V0KGRhdGEuZ2V0SGVhZGVycygpKTtcblxuICAgICAgaWYgKCFoZWFkZXJzLmhhc0NvbnRlbnRMZW5ndGgoKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGtub3duTGVuZ3RoID0gYXdhaXQgdXRpbC5wcm9taXNpZnkoZGF0YS5nZXRMZW5ndGgpLmNhbGwoZGF0YSk7XG4gICAgICAgICAgTnVtYmVyLmlzRmluaXRlKGtub3duTGVuZ3RoKSAmJiBrbm93bkxlbmd0aCA+PSAwICYmIGhlYWRlcnMuc2V0Q29udGVudExlbmd0aChrbm93bkxlbmd0aCk7XG4gICAgICAgICAgLyplc2xpbnQgbm8tZW1wdHk6MCovXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodXRpbHMuaXNCbG9iKGRhdGEpIHx8IHV0aWxzLmlzRmlsZShkYXRhKSkge1xuICAgICAgZGF0YS5zaXplICYmIGhlYWRlcnMuc2V0Q29udGVudFR5cGUoZGF0YS50eXBlIHx8ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nKTtcbiAgICAgIGhlYWRlcnMuc2V0Q29udGVudExlbmd0aChkYXRhLnNpemUgfHwgMCk7XG4gICAgICBkYXRhID0gc3RyZWFtLlJlYWRhYmxlLmZyb20ocmVhZEJsb2IoZGF0YSkpO1xuICAgIH0gZWxzZSBpZiAoZGF0YSAmJiAhdXRpbHMuaXNTdHJlYW0oZGF0YSkpIHtcbiAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoZGF0YSkpIHtcbiAgICAgICAgLy8gTm90aGluZyB0byBkby4uLlxuICAgICAgfSBlbHNlIGlmICh1dGlscy5pc0FycmF5QnVmZmVyKGRhdGEpKSB7XG4gICAgICAgIGRhdGEgPSBCdWZmZXIuZnJvbShuZXcgVWludDhBcnJheShkYXRhKSk7XG4gICAgICB9IGVsc2UgaWYgKHV0aWxzLmlzU3RyaW5nKGRhdGEpKSB7XG4gICAgICAgIGRhdGEgPSBCdWZmZXIuZnJvbShkYXRhLCAndXRmLTgnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiByZWplY3QobmV3IEF4aW9zRXJyb3IoXG4gICAgICAgICAgJ0RhdGEgYWZ0ZXIgdHJhbnNmb3JtYXRpb24gbXVzdCBiZSBhIHN0cmluZywgYW4gQXJyYXlCdWZmZXIsIGEgQnVmZmVyLCBvciBhIFN0cmVhbScsXG4gICAgICAgICAgQXhpb3NFcnJvci5FUlJfQkFEX1JFUVVFU1QsXG4gICAgICAgICAgY29uZmlnXG4gICAgICAgICkpO1xuICAgICAgfVxuXG4gICAgICAvLyBBZGQgQ29udGVudC1MZW5ndGggaGVhZGVyIGlmIGRhdGEgZXhpc3RzXG4gICAgICBoZWFkZXJzLnNldENvbnRlbnRMZW5ndGgoZGF0YS5sZW5ndGgsIGZhbHNlKTtcblxuICAgICAgaWYgKGNvbmZpZy5tYXhCb2R5TGVuZ3RoID4gLTEgJiYgZGF0YS5sZW5ndGggPiBjb25maWcubWF4Qm9keUxlbmd0aCkge1xuICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBBeGlvc0Vycm9yKFxuICAgICAgICAgICdSZXF1ZXN0IGJvZHkgbGFyZ2VyIHRoYW4gbWF4Qm9keUxlbmd0aCBsaW1pdCcsXG4gICAgICAgICAgQXhpb3NFcnJvci5FUlJfQkFEX1JFUVVFU1QsXG4gICAgICAgICAgY29uZmlnXG4gICAgICAgICkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGNvbnRlbnRMZW5ndGggPSB1dGlscy50b0Zpbml0ZU51bWJlcihoZWFkZXJzLmdldENvbnRlbnRMZW5ndGgoKSk7XG5cbiAgICBpZiAodXRpbHMuaXNBcnJheShtYXhSYXRlKSkge1xuICAgICAgbWF4VXBsb2FkUmF0ZSA9IG1heFJhdGVbMF07XG4gICAgICBtYXhEb3dubG9hZFJhdGUgPSBtYXhSYXRlWzFdO1xuICAgIH0gZWxzZSB7XG4gICAgICBtYXhVcGxvYWRSYXRlID0gbWF4RG93bmxvYWRSYXRlID0gbWF4UmF0ZTtcbiAgICB9XG5cbiAgICBpZiAoZGF0YSAmJiAob25VcGxvYWRQcm9ncmVzcyB8fCBtYXhVcGxvYWRSYXRlKSkge1xuICAgICAgaWYgKCF1dGlscy5pc1N0cmVhbShkYXRhKSkge1xuICAgICAgICBkYXRhID0gc3RyZWFtLlJlYWRhYmxlLmZyb20oZGF0YSwge29iamVjdE1vZGU6IGZhbHNlfSk7XG4gICAgICB9XG5cbiAgICAgIGRhdGEgPSBzdHJlYW0ucGlwZWxpbmUoW2RhdGEsIG5ldyBBeGlvc1RyYW5zZm9ybVN0cmVhbSh7XG4gICAgICAgIG1heFJhdGU6IHV0aWxzLnRvRmluaXRlTnVtYmVyKG1heFVwbG9hZFJhdGUpXG4gICAgICB9KV0sIHV0aWxzLm5vb3ApO1xuXG4gICAgICBvblVwbG9hZFByb2dyZXNzICYmIGRhdGEub24oJ3Byb2dyZXNzJywgZmx1c2hPbkZpbmlzaChcbiAgICAgICAgZGF0YSxcbiAgICAgICAgcHJvZ3Jlc3NFdmVudERlY29yYXRvcihcbiAgICAgICAgICBjb250ZW50TGVuZ3RoLFxuICAgICAgICAgIHByb2dyZXNzRXZlbnRSZWR1Y2VyKGFzeW5jRGVjb3JhdG9yKG9uVXBsb2FkUHJvZ3Jlc3MpLCBmYWxzZSwgMylcbiAgICAgICAgKVxuICAgICAgKSk7XG4gICAgfVxuXG4gICAgLy8gSFRUUCBiYXNpYyBhdXRoZW50aWNhdGlvblxuICAgIGxldCBhdXRoID0gdW5kZWZpbmVkO1xuICAgIGlmIChjb25maWcuYXV0aCkge1xuICAgICAgY29uc3QgdXNlcm5hbWUgPSBjb25maWcuYXV0aC51c2VybmFtZSB8fCAnJztcbiAgICAgIGNvbnN0IHBhc3N3b3JkID0gY29uZmlnLmF1dGgucGFzc3dvcmQgfHwgJyc7XG4gICAgICBhdXRoID0gdXNlcm5hbWUgKyAnOicgKyBwYXNzd29yZDtcbiAgICB9XG5cbiAgICBpZiAoIWF1dGggJiYgcGFyc2VkLnVzZXJuYW1lKSB7XG4gICAgICBjb25zdCB1cmxVc2VybmFtZSA9IHBhcnNlZC51c2VybmFtZTtcbiAgICAgIGNvbnN0IHVybFBhc3N3b3JkID0gcGFyc2VkLnBhc3N3b3JkO1xuICAgICAgYXV0aCA9IHVybFVzZXJuYW1lICsgJzonICsgdXJsUGFzc3dvcmQ7XG4gICAgfVxuXG4gICAgYXV0aCAmJiBoZWFkZXJzLmRlbGV0ZSgnYXV0aG9yaXphdGlvbicpO1xuXG4gICAgbGV0IHBhdGg7XG5cbiAgICB0cnkge1xuICAgICAgcGF0aCA9IGJ1aWxkVVJMKFxuICAgICAgICBwYXJzZWQucGF0aG5hbWUgKyBwYXJzZWQuc2VhcmNoLFxuICAgICAgICBjb25maWcucGFyYW1zLFxuICAgICAgICBjb25maWcucGFyYW1zU2VyaWFsaXplclxuICAgICAgKS5yZXBsYWNlKC9eXFw/LywgJycpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc3QgY3VzdG9tRXJyID0gbmV3IEVycm9yKGVyci5tZXNzYWdlKTtcbiAgICAgIGN1c3RvbUVyci5jb25maWcgPSBjb25maWc7XG4gICAgICBjdXN0b21FcnIudXJsID0gY29uZmlnLnVybDtcbiAgICAgIGN1c3RvbUVyci5leGlzdHMgPSB0cnVlO1xuICAgICAgcmV0dXJuIHJlamVjdChjdXN0b21FcnIpO1xuICAgIH1cblxuICAgIGhlYWRlcnMuc2V0KFxuICAgICAgJ0FjY2VwdC1FbmNvZGluZycsXG4gICAgICAnZ3ppcCwgY29tcHJlc3MsIGRlZmxhdGUnICsgKGlzQnJvdGxpU3VwcG9ydGVkID8gJywgYnInIDogJycpLCBmYWxzZVxuICAgICAgKTtcblxuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBwYXRoLFxuICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICBoZWFkZXJzOiBoZWFkZXJzLnRvSlNPTigpLFxuICAgICAgYWdlbnRzOiB7IGh0dHA6IGNvbmZpZy5odHRwQWdlbnQsIGh0dHBzOiBjb25maWcuaHR0cHNBZ2VudCB9LFxuICAgICAgYXV0aCxcbiAgICAgIHByb3RvY29sLFxuICAgICAgZmFtaWx5LFxuICAgICAgYmVmb3JlUmVkaXJlY3Q6IGRpc3BhdGNoQmVmb3JlUmVkaXJlY3QsXG4gICAgICBiZWZvcmVSZWRpcmVjdHM6IHt9XG4gICAgfTtcblxuICAgIC8vIGNhY2hlYWJsZS1sb29rdXAgaW50ZWdyYXRpb24gaG90Zml4XG4gICAgIXV0aWxzLmlzVW5kZWZpbmVkKGxvb2t1cCkgJiYgKG9wdGlvbnMubG9va3VwID0gbG9va3VwKTtcblxuICAgIGlmIChjb25maWcuc29ja2V0UGF0aCkge1xuICAgICAgb3B0aW9ucy5zb2NrZXRQYXRoID0gY29uZmlnLnNvY2tldFBhdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMuaG9zdG5hbWUgPSBwYXJzZWQuaG9zdG5hbWUuc3RhcnRzV2l0aChcIltcIikgPyBwYXJzZWQuaG9zdG5hbWUuc2xpY2UoMSwgLTEpIDogcGFyc2VkLmhvc3RuYW1lO1xuICAgICAgb3B0aW9ucy5wb3J0ID0gcGFyc2VkLnBvcnQ7XG4gICAgICBzZXRQcm94eShvcHRpb25zLCBjb25maWcucHJveHksIHByb3RvY29sICsgJy8vJyArIHBhcnNlZC5ob3N0bmFtZSArIChwYXJzZWQucG9ydCA/ICc6JyArIHBhcnNlZC5wb3J0IDogJycpICsgb3B0aW9ucy5wYXRoKTtcbiAgICB9XG5cbiAgICBsZXQgdHJhbnNwb3J0O1xuICAgIGNvbnN0IGlzSHR0cHNSZXF1ZXN0ID0gaXNIdHRwcy50ZXN0KG9wdGlvbnMucHJvdG9jb2wpO1xuICAgIG9wdGlvbnMuYWdlbnQgPSBpc0h0dHBzUmVxdWVzdCA/IGNvbmZpZy5odHRwc0FnZW50IDogY29uZmlnLmh0dHBBZ2VudDtcbiAgICBpZiAoY29uZmlnLnRyYW5zcG9ydCkge1xuICAgICAgdHJhbnNwb3J0ID0gY29uZmlnLnRyYW5zcG9ydDtcbiAgICB9IGVsc2UgaWYgKGNvbmZpZy5tYXhSZWRpcmVjdHMgPT09IDApIHtcbiAgICAgIHRyYW5zcG9ydCA9IGlzSHR0cHNSZXF1ZXN0ID8gaHR0cHMgOiBodHRwO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY29uZmlnLm1heFJlZGlyZWN0cykge1xuICAgICAgICBvcHRpb25zLm1heFJlZGlyZWN0cyA9IGNvbmZpZy5tYXhSZWRpcmVjdHM7XG4gICAgICB9XG4gICAgICBpZiAoY29uZmlnLmJlZm9yZVJlZGlyZWN0KSB7XG4gICAgICAgIG9wdGlvbnMuYmVmb3JlUmVkaXJlY3RzLmNvbmZpZyA9IGNvbmZpZy5iZWZvcmVSZWRpcmVjdDtcbiAgICAgIH1cbiAgICAgIHRyYW5zcG9ydCA9IGlzSHR0cHNSZXF1ZXN0ID8gaHR0cHNGb2xsb3cgOiBodHRwRm9sbG93O1xuICAgIH1cblxuICAgIGlmIChjb25maWcubWF4Qm9keUxlbmd0aCA+IC0xKSB7XG4gICAgICBvcHRpb25zLm1heEJvZHlMZW5ndGggPSBjb25maWcubWF4Qm9keUxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZm9sbG93LXJlZGlyZWN0cyBkb2VzIG5vdCBza2lwIGNvbXBhcmlzb24sIHNvIGl0IHNob3VsZCBhbHdheXMgc3VjY2VlZCBmb3IgYXhpb3MgLTEgdW5saW1pdGVkXG4gICAgICBvcHRpb25zLm1heEJvZHlMZW5ndGggPSBJbmZpbml0eTtcbiAgICB9XG5cbiAgICBpZiAoY29uZmlnLmluc2VjdXJlSFRUUFBhcnNlcikge1xuICAgICAgb3B0aW9ucy5pbnNlY3VyZUhUVFBQYXJzZXIgPSBjb25maWcuaW5zZWN1cmVIVFRQUGFyc2VyO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSB0aGUgcmVxdWVzdFxuICAgIHJlcSA9IHRyYW5zcG9ydC5yZXF1ZXN0KG9wdGlvbnMsIGZ1bmN0aW9uIGhhbmRsZVJlc3BvbnNlKHJlcykge1xuICAgICAgaWYgKHJlcS5kZXN0cm95ZWQpIHJldHVybjtcblxuICAgICAgY29uc3Qgc3RyZWFtcyA9IFtyZXNdO1xuXG4gICAgICBjb25zdCByZXNwb25zZUxlbmd0aCA9ICtyZXMuaGVhZGVyc1snY29udGVudC1sZW5ndGgnXTtcblxuICAgICAgaWYgKG9uRG93bmxvYWRQcm9ncmVzcyB8fCBtYXhEb3dubG9hZFJhdGUpIHtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtU3RyZWFtID0gbmV3IEF4aW9zVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgICAgICBtYXhSYXRlOiB1dGlscy50b0Zpbml0ZU51bWJlcihtYXhEb3dubG9hZFJhdGUpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIG9uRG93bmxvYWRQcm9ncmVzcyAmJiB0cmFuc2Zvcm1TdHJlYW0ub24oJ3Byb2dyZXNzJywgZmx1c2hPbkZpbmlzaChcbiAgICAgICAgICB0cmFuc2Zvcm1TdHJlYW0sXG4gICAgICAgICAgcHJvZ3Jlc3NFdmVudERlY29yYXRvcihcbiAgICAgICAgICAgIHJlc3BvbnNlTGVuZ3RoLFxuICAgICAgICAgICAgcHJvZ3Jlc3NFdmVudFJlZHVjZXIoYXN5bmNEZWNvcmF0b3Iob25Eb3dubG9hZFByb2dyZXNzKSwgdHJ1ZSwgMylcbiAgICAgICAgICApXG4gICAgICAgICkpO1xuXG4gICAgICAgIHN0cmVhbXMucHVzaCh0cmFuc2Zvcm1TdHJlYW0pO1xuICAgICAgfVxuXG4gICAgICAvLyBkZWNvbXByZXNzIHRoZSByZXNwb25zZSBib2R5IHRyYW5zcGFyZW50bHkgaWYgcmVxdWlyZWRcbiAgICAgIGxldCByZXNwb25zZVN0cmVhbSA9IHJlcztcblxuICAgICAgLy8gcmV0dXJuIHRoZSBsYXN0IHJlcXVlc3QgaW4gY2FzZSBvZiByZWRpcmVjdHNcbiAgICAgIGNvbnN0IGxhc3RSZXF1ZXN0ID0gcmVzLnJlcSB8fCByZXE7XG5cbiAgICAgIC8vIGlmIGRlY29tcHJlc3MgZGlzYWJsZWQgd2Ugc2hvdWxkIG5vdCBkZWNvbXByZXNzXG4gICAgICBpZiAoY29uZmlnLmRlY29tcHJlc3MgIT09IGZhbHNlICYmIHJlcy5oZWFkZXJzWydjb250ZW50LWVuY29kaW5nJ10pIHtcbiAgICAgICAgLy8gaWYgbm8gY29udGVudCwgYnV0IGhlYWRlcnMgc3RpbGwgc2F5IHRoYXQgaXQgaXMgZW5jb2RlZCxcbiAgICAgICAgLy8gcmVtb3ZlIHRoZSBoZWFkZXIgbm90IGNvbmZ1c2UgZG93bnN0cmVhbSBvcGVyYXRpb25zXG4gICAgICAgIGlmIChtZXRob2QgPT09ICdIRUFEJyB8fCByZXMuc3RhdHVzQ29kZSA9PT0gMjA0KSB7XG4gICAgICAgICAgZGVsZXRlIHJlcy5oZWFkZXJzWydjb250ZW50LWVuY29kaW5nJ107XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKChyZXMuaGVhZGVyc1snY29udGVudC1lbmNvZGluZyddIHx8ICcnKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgIC8qZXNsaW50IGRlZmF1bHQtY2FzZTowKi9cbiAgICAgICAgY2FzZSAnZ3ppcCc6XG4gICAgICAgIGNhc2UgJ3gtZ3ppcCc6XG4gICAgICAgIGNhc2UgJ2NvbXByZXNzJzpcbiAgICAgICAgY2FzZSAneC1jb21wcmVzcyc6XG4gICAgICAgICAgLy8gYWRkIHRoZSB1bnppcHBlciB0byB0aGUgYm9keSBzdHJlYW0gcHJvY2Vzc2luZyBwaXBlbGluZVxuICAgICAgICAgIHN0cmVhbXMucHVzaCh6bGliLmNyZWF0ZVVuemlwKHpsaWJPcHRpb25zKSk7XG5cbiAgICAgICAgICAvLyByZW1vdmUgdGhlIGNvbnRlbnQtZW5jb2RpbmcgaW4gb3JkZXIgdG8gbm90IGNvbmZ1c2UgZG93bnN0cmVhbSBvcGVyYXRpb25zXG4gICAgICAgICAgZGVsZXRlIHJlcy5oZWFkZXJzWydjb250ZW50LWVuY29kaW5nJ107XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2RlZmxhdGUnOlxuICAgICAgICAgIHN0cmVhbXMucHVzaChuZXcgWmxpYkhlYWRlclRyYW5zZm9ybVN0cmVhbSgpKTtcblxuICAgICAgICAgIC8vIGFkZCB0aGUgdW56aXBwZXIgdG8gdGhlIGJvZHkgc3RyZWFtIHByb2Nlc3NpbmcgcGlwZWxpbmVcbiAgICAgICAgICBzdHJlYW1zLnB1c2goemxpYi5jcmVhdGVVbnppcCh6bGliT3B0aW9ucykpO1xuXG4gICAgICAgICAgLy8gcmVtb3ZlIHRoZSBjb250ZW50LWVuY29kaW5nIGluIG9yZGVyIHRvIG5vdCBjb25mdXNlIGRvd25zdHJlYW0gb3BlcmF0aW9uc1xuICAgICAgICAgIGRlbGV0ZSByZXMuaGVhZGVyc1snY29udGVudC1lbmNvZGluZyddO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdicic6XG4gICAgICAgICAgaWYgKGlzQnJvdGxpU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICBzdHJlYW1zLnB1c2goemxpYi5jcmVhdGVCcm90bGlEZWNvbXByZXNzKGJyb3RsaU9wdGlvbnMpKTtcbiAgICAgICAgICAgIGRlbGV0ZSByZXMuaGVhZGVyc1snY29udGVudC1lbmNvZGluZyddO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXNwb25zZVN0cmVhbSA9IHN0cmVhbXMubGVuZ3RoID4gMSA/IHN0cmVhbS5waXBlbGluZShzdHJlYW1zLCB1dGlscy5ub29wKSA6IHN0cmVhbXNbMF07XG5cbiAgICAgIGNvbnN0IG9mZkxpc3RlbmVycyA9IHN0cmVhbS5maW5pc2hlZChyZXNwb25zZVN0cmVhbSwgKCkgPT4ge1xuICAgICAgICBvZmZMaXN0ZW5lcnMoKTtcbiAgICAgICAgb25GaW5pc2hlZCgpO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0ge1xuICAgICAgICBzdGF0dXM6IHJlcy5zdGF0dXNDb2RlLFxuICAgICAgICBzdGF0dXNUZXh0OiByZXMuc3RhdHVzTWVzc2FnZSxcbiAgICAgICAgaGVhZGVyczogbmV3IEF4aW9zSGVhZGVycyhyZXMuaGVhZGVycyksXG4gICAgICAgIGNvbmZpZyxcbiAgICAgICAgcmVxdWVzdDogbGFzdFJlcXVlc3RcbiAgICAgIH07XG5cbiAgICAgIGlmIChyZXNwb25zZVR5cGUgPT09ICdzdHJlYW0nKSB7XG4gICAgICAgIHJlc3BvbnNlLmRhdGEgPSByZXNwb25zZVN0cmVhbTtcbiAgICAgICAgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgcmVzcG9uc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2VCdWZmZXIgPSBbXTtcbiAgICAgICAgbGV0IHRvdGFsUmVzcG9uc2VCeXRlcyA9IDA7XG5cbiAgICAgICAgcmVzcG9uc2VTdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbiBoYW5kbGVTdHJlYW1EYXRhKGNodW5rKSB7XG4gICAgICAgICAgcmVzcG9uc2VCdWZmZXIucHVzaChjaHVuayk7XG4gICAgICAgICAgdG90YWxSZXNwb25zZUJ5dGVzICs9IGNodW5rLmxlbmd0aDtcblxuICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0aGUgY29udGVudCBsZW5ndGggaXMgbm90IG92ZXIgdGhlIG1heENvbnRlbnRMZW5ndGggaWYgc3BlY2lmaWVkXG4gICAgICAgICAgaWYgKGNvbmZpZy5tYXhDb250ZW50TGVuZ3RoID4gLTEgJiYgdG90YWxSZXNwb25zZUJ5dGVzID4gY29uZmlnLm1heENvbnRlbnRMZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIHN0cmVhbS5kZXN0cm95KCkgZW1pdCBhYm9ydGVkIGV2ZW50IGJlZm9yZSBjYWxsaW5nIHJlamVjdCgpIG9uIE5vZGUuanMgdjE2XG4gICAgICAgICAgICByZWplY3RlZCA9IHRydWU7XG4gICAgICAgICAgICByZXNwb25zZVN0cmVhbS5kZXN0cm95KCk7XG4gICAgICAgICAgICByZWplY3QobmV3IEF4aW9zRXJyb3IoJ21heENvbnRlbnRMZW5ndGggc2l6ZSBvZiAnICsgY29uZmlnLm1heENvbnRlbnRMZW5ndGggKyAnIGV4Y2VlZGVkJyxcbiAgICAgICAgICAgICAgQXhpb3NFcnJvci5FUlJfQkFEX1JFU1BPTlNFLCBjb25maWcsIGxhc3RSZXF1ZXN0KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXNwb25zZVN0cmVhbS5vbignYWJvcnRlZCcsIGZ1bmN0aW9uIGhhbmRsZXJTdHJlYW1BYm9ydGVkKCkge1xuICAgICAgICAgIGlmIChyZWplY3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGVyciA9IG5ldyBBeGlvc0Vycm9yKFxuICAgICAgICAgICAgJ3N0cmVhbSBoYXMgYmVlbiBhYm9ydGVkJyxcbiAgICAgICAgICAgIEF4aW9zRXJyb3IuRVJSX0JBRF9SRVNQT05TRSxcbiAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgIGxhc3RSZXF1ZXN0XG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXNwb25zZVN0cmVhbS5kZXN0cm95KGVycik7XG4gICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlc3BvbnNlU3RyZWFtLm9uKCdlcnJvcicsIGZ1bmN0aW9uIGhhbmRsZVN0cmVhbUVycm9yKGVycikge1xuICAgICAgICAgIGlmIChyZXEuZGVzdHJveWVkKSByZXR1cm47XG4gICAgICAgICAgcmVqZWN0KEF4aW9zRXJyb3IuZnJvbShlcnIsIG51bGwsIGNvbmZpZywgbGFzdFJlcXVlc3QpKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmVzcG9uc2VTdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uIGhhbmRsZVN0cmVhbUVuZCgpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IHJlc3BvbnNlRGF0YSA9IHJlc3BvbnNlQnVmZmVyLmxlbmd0aCA9PT0gMSA/IHJlc3BvbnNlQnVmZmVyWzBdIDogQnVmZmVyLmNvbmNhdChyZXNwb25zZUJ1ZmZlcik7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2VUeXBlICE9PSAnYXJyYXlidWZmZXInKSB7XG4gICAgICAgICAgICAgIHJlc3BvbnNlRGF0YSA9IHJlc3BvbnNlRGF0YS50b1N0cmluZyhyZXNwb25zZUVuY29kaW5nKTtcbiAgICAgICAgICAgICAgaWYgKCFyZXNwb25zZUVuY29kaW5nIHx8IHJlc3BvbnNlRW5jb2RpbmcgPT09ICd1dGY4Jykge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlRGF0YSA9IHV0aWxzLnN0cmlwQk9NKHJlc3BvbnNlRGF0YSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3BvbnNlLmRhdGEgPSByZXNwb25zZURhdGE7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0KEF4aW9zRXJyb3IuZnJvbShlcnIsIG51bGwsIGNvbmZpZywgcmVzcG9uc2UucmVxdWVzdCwgcmVzcG9uc2UpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgcmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgZW1pdHRlci5vbmNlKCdhYm9ydCcsIGVyciA9PiB7XG4gICAgICAgIGlmICghcmVzcG9uc2VTdHJlYW0uZGVzdHJveWVkKSB7XG4gICAgICAgICAgcmVzcG9uc2VTdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICAgIHJlc3BvbnNlU3RyZWFtLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBlbWl0dGVyLm9uY2UoJ2Fib3J0JywgZXJyID0+IHtcbiAgICAgIHJlamVjdChlcnIpO1xuICAgICAgcmVxLmRlc3Ryb3koZXJyKTtcbiAgICB9KTtcblxuICAgIC8vIEhhbmRsZSBlcnJvcnNcbiAgICByZXEub24oJ2Vycm9yJywgZnVuY3Rpb24gaGFuZGxlUmVxdWVzdEVycm9yKGVycikge1xuICAgICAgLy8gQHRvZG8gcmVtb3ZlXG4gICAgICAvLyBpZiAocmVxLmFib3J0ZWQgJiYgZXJyLmNvZGUgIT09IEF4aW9zRXJyb3IuRVJSX0ZSX1RPT19NQU5ZX1JFRElSRUNUUykgcmV0dXJuO1xuICAgICAgcmVqZWN0KEF4aW9zRXJyb3IuZnJvbShlcnIsIG51bGwsIGNvbmZpZywgcmVxKSk7XG4gICAgfSk7XG5cbiAgICAvLyBzZXQgdGNwIGtlZXAgYWxpdmUgdG8gcHJldmVudCBkcm9wIGNvbm5lY3Rpb24gYnkgcGVlclxuICAgIHJlcS5vbignc29ja2V0JywgZnVuY3Rpb24gaGFuZGxlUmVxdWVzdFNvY2tldChzb2NrZXQpIHtcbiAgICAgIC8vIGRlZmF1bHQgaW50ZXJ2YWwgb2Ygc2VuZGluZyBhY2sgcGFja2V0IGlzIDEgbWludXRlXG4gICAgICBzb2NrZXQuc2V0S2VlcEFsaXZlKHRydWUsIDEwMDAgKiA2MCk7XG4gICAgfSk7XG5cbiAgICAvLyBIYW5kbGUgcmVxdWVzdCB0aW1lb3V0XG4gICAgaWYgKGNvbmZpZy50aW1lb3V0KSB7XG4gICAgICAvLyBUaGlzIGlzIGZvcmNpbmcgYSBpbnQgdGltZW91dCB0byBhdm9pZCBwcm9ibGVtcyBpZiB0aGUgYHJlcWAgaW50ZXJmYWNlIGRvZXNuJ3QgaGFuZGxlIG90aGVyIHR5cGVzLlxuICAgICAgY29uc3QgdGltZW91dCA9IHBhcnNlSW50KGNvbmZpZy50aW1lb3V0LCAxMCk7XG5cbiAgICAgIGlmIChOdW1iZXIuaXNOYU4odGltZW91dCkpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBBeGlvc0Vycm9yKFxuICAgICAgICAgICdlcnJvciB0cnlpbmcgdG8gcGFyc2UgYGNvbmZpZy50aW1lb3V0YCB0byBpbnQnLFxuICAgICAgICAgIEF4aW9zRXJyb3IuRVJSX0JBRF9PUFRJT05fVkFMVUUsXG4gICAgICAgICAgY29uZmlnLFxuICAgICAgICAgIHJlcVxuICAgICAgICApKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFNvbWV0aW1lLCB0aGUgcmVzcG9uc2Ugd2lsbCBiZSB2ZXJ5IHNsb3csIGFuZCBkb2VzIG5vdCByZXNwb25kLCB0aGUgY29ubmVjdCBldmVudCB3aWxsIGJlIGJsb2NrIGJ5IGV2ZW50IGxvb3Agc3lzdGVtLlxuICAgICAgLy8gQW5kIHRpbWVyIGNhbGxiYWNrIHdpbGwgYmUgZmlyZWQsIGFuZCBhYm9ydCgpIHdpbGwgYmUgaW52b2tlZCBiZWZvcmUgY29ubmVjdGlvbiwgdGhlbiBnZXQgXCJzb2NrZXQgaGFuZyB1cFwiIGFuZCBjb2RlIEVDT05OUkVTRVQuXG4gICAgICAvLyBBdCB0aGlzIHRpbWUsIGlmIHdlIGhhdmUgYSBsYXJnZSBudW1iZXIgb2YgcmVxdWVzdCwgbm9kZWpzIHdpbGwgaGFuZyB1cCBzb21lIHNvY2tldCBvbiBiYWNrZ3JvdW5kLiBhbmQgdGhlIG51bWJlciB3aWxsIHVwIGFuZCB1cC5cbiAgICAgIC8vIEFuZCB0aGVuIHRoZXNlIHNvY2tldCB3aGljaCBiZSBoYW5nIHVwIHdpbGwgZGV2b3VyaW5nIENQVSBsaXR0bGUgYnkgbGl0dGxlLlxuICAgICAgLy8gQ2xpZW50UmVxdWVzdC5zZXRUaW1lb3V0IHdpbGwgYmUgZmlyZWQgb24gdGhlIHNwZWNpZnkgbWlsbGlzZWNvbmRzLCBhbmQgY2FuIG1ha2Ugc3VyZSB0aGF0IGFib3J0KCkgd2lsbCBiZSBmaXJlZCBhZnRlciBjb25uZWN0LlxuICAgICAgcmVxLnNldFRpbWVvdXQodGltZW91dCwgZnVuY3Rpb24gaGFuZGxlUmVxdWVzdFRpbWVvdXQoKSB7XG4gICAgICAgIGlmIChpc0RvbmUpIHJldHVybjtcbiAgICAgICAgbGV0IHRpbWVvdXRFcnJvck1lc3NhZ2UgPSBjb25maWcudGltZW91dCA/ICd0aW1lb3V0IG9mICcgKyBjb25maWcudGltZW91dCArICdtcyBleGNlZWRlZCcgOiAndGltZW91dCBleGNlZWRlZCc7XG4gICAgICAgIGNvbnN0IHRyYW5zaXRpb25hbCA9IGNvbmZpZy50cmFuc2l0aW9uYWwgfHwgdHJhbnNpdGlvbmFsRGVmYXVsdHM7XG4gICAgICAgIGlmIChjb25maWcudGltZW91dEVycm9yTWVzc2FnZSkge1xuICAgICAgICAgIHRpbWVvdXRFcnJvck1lc3NhZ2UgPSBjb25maWcudGltZW91dEVycm9yTWVzc2FnZTtcbiAgICAgICAgfVxuICAgICAgICByZWplY3QobmV3IEF4aW9zRXJyb3IoXG4gICAgICAgICAgdGltZW91dEVycm9yTWVzc2FnZSxcbiAgICAgICAgICB0cmFuc2l0aW9uYWwuY2xhcmlmeVRpbWVvdXRFcnJvciA/IEF4aW9zRXJyb3IuRVRJTUVET1VUIDogQXhpb3NFcnJvci5FQ09OTkFCT1JURUQsXG4gICAgICAgICAgY29uZmlnLFxuICAgICAgICAgIHJlcVxuICAgICAgICApKTtcbiAgICAgICAgYWJvcnQoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuXG4gICAgLy8gU2VuZCB0aGUgcmVxdWVzdFxuICAgIGlmICh1dGlscy5pc1N0cmVhbShkYXRhKSkge1xuICAgICAgbGV0IGVuZGVkID0gZmFsc2U7XG4gICAgICBsZXQgZXJyb3JlZCA9IGZhbHNlO1xuXG4gICAgICBkYXRhLm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgIGVuZGVkID0gdHJ1ZTtcbiAgICAgIH0pO1xuXG4gICAgICBkYXRhLm9uY2UoJ2Vycm9yJywgZXJyID0+IHtcbiAgICAgICAgZXJyb3JlZCA9IHRydWU7XG4gICAgICAgIHJlcS5kZXN0cm95KGVycik7XG4gICAgICB9KTtcblxuICAgICAgZGF0YS5vbignY2xvc2UnLCAoKSA9PiB7XG4gICAgICAgIGlmICghZW5kZWQgJiYgIWVycm9yZWQpIHtcbiAgICAgICAgICBhYm9ydChuZXcgQ2FuY2VsZWRFcnJvcignUmVxdWVzdCBzdHJlYW0gaGFzIGJlZW4gYWJvcnRlZCcsIGNvbmZpZywgcmVxKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBkYXRhLnBpcGUocmVxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVxLmVuZChkYXRhKTtcbiAgICB9XG4gIH0pO1xufVxuXG5leHBvcnQgY29uc3QgX19zZXRQcm94eSA9IHNldFByb3h5O1xuIiwiaW1wb3J0IHBsYXRmb3JtIGZyb20gJy4uL3BsYXRmb3JtL2luZGV4LmpzJztcblxuZXhwb3J0IGRlZmF1bHQgcGxhdGZvcm0uaGFzU3RhbmRhcmRCcm93c2VyRW52ID8gKChvcmlnaW4sIGlzTVNJRSkgPT4gKHVybCkgPT4ge1xuICB1cmwgPSBuZXcgVVJMKHVybCwgcGxhdGZvcm0ub3JpZ2luKTtcblxuICByZXR1cm4gKFxuICAgIG9yaWdpbi5wcm90b2NvbCA9PT0gdXJsLnByb3RvY29sICYmXG4gICAgb3JpZ2luLmhvc3QgPT09IHVybC5ob3N0ICYmXG4gICAgKGlzTVNJRSB8fCBvcmlnaW4ucG9ydCA9PT0gdXJsLnBvcnQpXG4gICk7XG59KShcbiAgbmV3IFVSTChwbGF0Zm9ybS5vcmlnaW4pLFxuICBwbGF0Zm9ybS5uYXZpZ2F0b3IgJiYgLyhtc2llfHRyaWRlbnQpL2kudGVzdChwbGF0Zm9ybS5uYXZpZ2F0b3IudXNlckFnZW50KVxuKSA6ICgpID0+IHRydWU7XG4iLCJpbXBvcnQgdXRpbHMgZnJvbSAnLi8uLi91dGlscy5qcyc7XG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnLi4vcGxhdGZvcm0vaW5kZXguanMnO1xuXG5leHBvcnQgZGVmYXVsdCBwbGF0Zm9ybS5oYXNTdGFuZGFyZEJyb3dzZXJFbnYgP1xuXG4gIC8vIFN0YW5kYXJkIGJyb3dzZXIgZW52cyBzdXBwb3J0IGRvY3VtZW50LmNvb2tpZVxuICB7XG4gICAgd3JpdGUobmFtZSwgdmFsdWUsIGV4cGlyZXMsIHBhdGgsIGRvbWFpbiwgc2VjdXJlKSB7XG4gICAgICBjb25zdCBjb29raWUgPSBbbmFtZSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSldO1xuXG4gICAgICB1dGlscy5pc051bWJlcihleHBpcmVzKSAmJiBjb29raWUucHVzaCgnZXhwaXJlcz0nICsgbmV3IERhdGUoZXhwaXJlcykudG9HTVRTdHJpbmcoKSk7XG5cbiAgICAgIHV0aWxzLmlzU3RyaW5nKHBhdGgpICYmIGNvb2tpZS5wdXNoKCdwYXRoPScgKyBwYXRoKTtcblxuICAgICAgdXRpbHMuaXNTdHJpbmcoZG9tYWluKSAmJiBjb29raWUucHVzaCgnZG9tYWluPScgKyBkb21haW4pO1xuXG4gICAgICBzZWN1cmUgPT09IHRydWUgJiYgY29va2llLnB1c2goJ3NlY3VyZScpO1xuXG4gICAgICBkb2N1bWVudC5jb29raWUgPSBjb29raWUuam9pbignOyAnKTtcbiAgICB9LFxuXG4gICAgcmVhZChuYW1lKSB7XG4gICAgICBjb25zdCBtYXRjaCA9IGRvY3VtZW50LmNvb2tpZS5tYXRjaChuZXcgUmVnRXhwKCcoXnw7XFxcXHMqKSgnICsgbmFtZSArICcpPShbXjtdKiknKSk7XG4gICAgICByZXR1cm4gKG1hdGNoID8gZGVjb2RlVVJJQ29tcG9uZW50KG1hdGNoWzNdKSA6IG51bGwpO1xuICAgIH0sXG5cbiAgICByZW1vdmUobmFtZSkge1xuICAgICAgdGhpcy53cml0ZShuYW1lLCAnJywgRGF0ZS5ub3coKSAtIDg2NDAwMDAwKTtcbiAgICB9XG4gIH1cblxuICA6XG5cbiAgLy8gTm9uLXN0YW5kYXJkIGJyb3dzZXIgZW52ICh3ZWIgd29ya2VycywgcmVhY3QtbmF0aXZlKSBsYWNrIG5lZWRlZCBzdXBwb3J0LlxuICB7XG4gICAgd3JpdGUoKSB7fSxcbiAgICByZWFkKCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICByZW1vdmUoKSB7fVxuICB9O1xuXG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB1dGlscyBmcm9tICcuLi91dGlscy5qcyc7XG5pbXBvcnQgQXhpb3NIZWFkZXJzIGZyb20gXCIuL0F4aW9zSGVhZGVycy5qc1wiO1xuXG5jb25zdCBoZWFkZXJzVG9PYmplY3QgPSAodGhpbmcpID0+IHRoaW5nIGluc3RhbmNlb2YgQXhpb3NIZWFkZXJzID8geyAuLi50aGluZyB9IDogdGhpbmc7XG5cbi8qKlxuICogQ29uZmlnLXNwZWNpZmljIG1lcmdlLWZ1bmN0aW9uIHdoaWNoIGNyZWF0ZXMgYSBuZXcgY29uZmlnLW9iamVjdFxuICogYnkgbWVyZ2luZyB0d28gY29uZmlndXJhdGlvbiBvYmplY3RzIHRvZ2V0aGVyLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcxXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnMlxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9IE5ldyBvYmplY3QgcmVzdWx0aW5nIGZyb20gbWVyZ2luZyBjb25maWcyIHRvIGNvbmZpZzFcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWVyZ2VDb25maWcoY29uZmlnMSwgY29uZmlnMikge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgY29uZmlnMiA9IGNvbmZpZzIgfHwge307XG4gIGNvbnN0IGNvbmZpZyA9IHt9O1xuXG4gIGZ1bmN0aW9uIGdldE1lcmdlZFZhbHVlKHRhcmdldCwgc291cmNlLCBwcm9wLCBjYXNlbGVzcykge1xuICAgIGlmICh1dGlscy5pc1BsYWluT2JqZWN0KHRhcmdldCkgJiYgdXRpbHMuaXNQbGFpbk9iamVjdChzb3VyY2UpKSB7XG4gICAgICByZXR1cm4gdXRpbHMubWVyZ2UuY2FsbCh7Y2FzZWxlc3N9LCB0YXJnZXQsIHNvdXJjZSk7XG4gICAgfSBlbHNlIGlmICh1dGlscy5pc1BsYWluT2JqZWN0KHNvdXJjZSkpIHtcbiAgICAgIHJldHVybiB1dGlscy5tZXJnZSh7fSwgc291cmNlKTtcbiAgICB9IGVsc2UgaWYgKHV0aWxzLmlzQXJyYXkoc291cmNlKSkge1xuICAgICAgcmV0dXJuIHNvdXJjZS5zbGljZSgpO1xuICAgIH1cbiAgICByZXR1cm4gc291cmNlO1xuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG4gIGZ1bmN0aW9uIG1lcmdlRGVlcFByb3BlcnRpZXMoYSwgYiwgcHJvcCAsIGNhc2VsZXNzKSB7XG4gICAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChiKSkge1xuICAgICAgcmV0dXJuIGdldE1lcmdlZFZhbHVlKGEsIGIsIHByb3AgLCBjYXNlbGVzcyk7XG4gICAgfSBlbHNlIGlmICghdXRpbHMuaXNVbmRlZmluZWQoYSkpIHtcbiAgICAgIHJldHVybiBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGEsIHByb3AgLCBjYXNlbGVzcyk7XG4gICAgfVxuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG4gIGZ1bmN0aW9uIHZhbHVlRnJvbUNvbmZpZzIoYSwgYikge1xuICAgIGlmICghdXRpbHMuaXNVbmRlZmluZWQoYikpIHtcbiAgICAgIHJldHVybiBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGIpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb25zaXN0ZW50LXJldHVyblxuICBmdW5jdGlvbiBkZWZhdWx0VG9Db25maWcyKGEsIGIpIHtcbiAgICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGIpKSB7XG4gICAgICByZXR1cm4gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBiKTtcbiAgICB9IGVsc2UgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChhKSkge1xuICAgICAgcmV0dXJuIGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgYSk7XG4gICAgfVxuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG4gIGZ1bmN0aW9uIG1lcmdlRGlyZWN0S2V5cyhhLCBiLCBwcm9wKSB7XG4gICAgaWYgKHByb3AgaW4gY29uZmlnMikge1xuICAgICAgcmV0dXJuIGdldE1lcmdlZFZhbHVlKGEsIGIpO1xuICAgIH0gZWxzZSBpZiAocHJvcCBpbiBjb25maWcxKSB7XG4gICAgICByZXR1cm4gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBhKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBtZXJnZU1hcCA9IHtcbiAgICB1cmw6IHZhbHVlRnJvbUNvbmZpZzIsXG4gICAgbWV0aG9kOiB2YWx1ZUZyb21Db25maWcyLFxuICAgIGRhdGE6IHZhbHVlRnJvbUNvbmZpZzIsXG4gICAgYmFzZVVSTDogZGVmYXVsdFRvQ29uZmlnMixcbiAgICB0cmFuc2Zvcm1SZXF1ZXN0OiBkZWZhdWx0VG9Db25maWcyLFxuICAgIHRyYW5zZm9ybVJlc3BvbnNlOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIHBhcmFtc1NlcmlhbGl6ZXI6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgdGltZW91dDogZGVmYXVsdFRvQ29uZmlnMixcbiAgICB0aW1lb3V0TWVzc2FnZTogZGVmYXVsdFRvQ29uZmlnMixcbiAgICB3aXRoQ3JlZGVudGlhbHM6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgd2l0aFhTUkZUb2tlbjogZGVmYXVsdFRvQ29uZmlnMixcbiAgICBhZGFwdGVyOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIHJlc3BvbnNlVHlwZTogZGVmYXVsdFRvQ29uZmlnMixcbiAgICB4c3JmQ29va2llTmFtZTogZGVmYXVsdFRvQ29uZmlnMixcbiAgICB4c3JmSGVhZGVyTmFtZTogZGVmYXVsdFRvQ29uZmlnMixcbiAgICBvblVwbG9hZFByb2dyZXNzOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIG9uRG93bmxvYWRQcm9ncmVzczogZGVmYXVsdFRvQ29uZmlnMixcbiAgICBkZWNvbXByZXNzOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIG1heENvbnRlbnRMZW5ndGg6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgbWF4Qm9keUxlbmd0aDogZGVmYXVsdFRvQ29uZmlnMixcbiAgICBiZWZvcmVSZWRpcmVjdDogZGVmYXVsdFRvQ29uZmlnMixcbiAgICB0cmFuc3BvcnQ6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgaHR0cEFnZW50OiBkZWZhdWx0VG9Db25maWcyLFxuICAgIGh0dHBzQWdlbnQ6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgY2FuY2VsVG9rZW46IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgc29ja2V0UGF0aDogZGVmYXVsdFRvQ29uZmlnMixcbiAgICByZXNwb25zZUVuY29kaW5nOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIHZhbGlkYXRlU3RhdHVzOiBtZXJnZURpcmVjdEtleXMsXG4gICAgaGVhZGVyczogKGEsIGIgLCBwcm9wKSA9PiBtZXJnZURlZXBQcm9wZXJ0aWVzKGhlYWRlcnNUb09iamVjdChhKSwgaGVhZGVyc1RvT2JqZWN0KGIpLHByb3AsIHRydWUpXG4gIH07XG5cbiAgdXRpbHMuZm9yRWFjaChPYmplY3Qua2V5cyh7Li4uY29uZmlnMSwgLi4uY29uZmlnMn0pLCBmdW5jdGlvbiBjb21wdXRlQ29uZmlnVmFsdWUocHJvcCkge1xuICAgIGNvbnN0IG1lcmdlID0gbWVyZ2VNYXBbcHJvcF0gfHwgbWVyZ2VEZWVwUHJvcGVydGllcztcbiAgICBjb25zdCBjb25maWdWYWx1ZSA9IG1lcmdlKGNvbmZpZzFbcHJvcF0sIGNvbmZpZzJbcHJvcF0sIHByb3ApO1xuICAgICh1dGlscy5pc1VuZGVmaW5lZChjb25maWdWYWx1ZSkgJiYgbWVyZ2UgIT09IG1lcmdlRGlyZWN0S2V5cykgfHwgKGNvbmZpZ1twcm9wXSA9IGNvbmZpZ1ZhbHVlKTtcbiAgfSk7XG5cbiAgcmV0dXJuIGNvbmZpZztcbn1cbiIsImltcG9ydCBwbGF0Zm9ybSBmcm9tIFwiLi4vcGxhdGZvcm0vaW5kZXguanNcIjtcbmltcG9ydCB1dGlscyBmcm9tIFwiLi4vdXRpbHMuanNcIjtcbmltcG9ydCBpc1VSTFNhbWVPcmlnaW4gZnJvbSBcIi4vaXNVUkxTYW1lT3JpZ2luLmpzXCI7XG5pbXBvcnQgY29va2llcyBmcm9tIFwiLi9jb29raWVzLmpzXCI7XG5pbXBvcnQgYnVpbGRGdWxsUGF0aCBmcm9tIFwiLi4vY29yZS9idWlsZEZ1bGxQYXRoLmpzXCI7XG5pbXBvcnQgbWVyZ2VDb25maWcgZnJvbSBcIi4uL2NvcmUvbWVyZ2VDb25maWcuanNcIjtcbmltcG9ydCBBeGlvc0hlYWRlcnMgZnJvbSBcIi4uL2NvcmUvQXhpb3NIZWFkZXJzLmpzXCI7XG5pbXBvcnQgYnVpbGRVUkwgZnJvbSBcIi4vYnVpbGRVUkwuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgKGNvbmZpZykgPT4ge1xuICBjb25zdCBuZXdDb25maWcgPSBtZXJnZUNvbmZpZyh7fSwgY29uZmlnKTtcblxuICBsZXQgeyBkYXRhLCB3aXRoWFNSRlRva2VuLCB4c3JmSGVhZGVyTmFtZSwgeHNyZkNvb2tpZU5hbWUsIGhlYWRlcnMsIGF1dGggfSA9IG5ld0NvbmZpZztcblxuICBuZXdDb25maWcuaGVhZGVycyA9IGhlYWRlcnMgPSBBeGlvc0hlYWRlcnMuZnJvbShoZWFkZXJzKTtcblxuICBuZXdDb25maWcudXJsID0gYnVpbGRVUkwoYnVpbGRGdWxsUGF0aChuZXdDb25maWcuYmFzZVVSTCwgbmV3Q29uZmlnLnVybCwgbmV3Q29uZmlnLmFsbG93QWJzb2x1dGVVcmxzKSwgY29uZmlnLnBhcmFtcywgY29uZmlnLnBhcmFtc1NlcmlhbGl6ZXIpO1xuXG4gIC8vIEhUVFAgYmFzaWMgYXV0aGVudGljYXRpb25cbiAgaWYgKGF1dGgpIHtcbiAgICBoZWFkZXJzLnNldCgnQXV0aG9yaXphdGlvbicsICdCYXNpYyAnICtcbiAgICAgIGJ0b2EoKGF1dGgudXNlcm5hbWUgfHwgJycpICsgJzonICsgKGF1dGgucGFzc3dvcmQgPyB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoYXV0aC5wYXNzd29yZCkpIDogJycpKVxuICAgICk7XG4gIH1cblxuICBpZiAodXRpbHMuaXNGb3JtRGF0YShkYXRhKSkge1xuICAgIGlmIChwbGF0Zm9ybS5oYXNTdGFuZGFyZEJyb3dzZXJFbnYgfHwgcGxhdGZvcm0uaGFzU3RhbmRhcmRCcm93c2VyV2ViV29ya2VyRW52KSB7XG4gICAgICBoZWFkZXJzLnNldENvbnRlbnRUeXBlKHVuZGVmaW5lZCk7IC8vIGJyb3dzZXIgaGFuZGxlcyBpdFxuICAgIH0gZWxzZSBpZiAodXRpbHMuaXNGdW5jdGlvbihkYXRhLmdldEhlYWRlcnMpKSB7XG4gICAgICAvLyBOb2RlLmpzIEZvcm1EYXRhIChsaWtlIGZvcm0tZGF0YSBwYWNrYWdlKVxuICAgICAgY29uc3QgZm9ybUhlYWRlcnMgPSBkYXRhLmdldEhlYWRlcnMoKTtcbiAgICAgIC8vIE9ubHkgc2V0IHNhZmUgaGVhZGVycyB0byBhdm9pZCBvdmVyd3JpdGluZyBzZWN1cml0eSBoZWFkZXJzXG4gICAgICBjb25zdCBhbGxvd2VkSGVhZGVycyA9IFsnY29udGVudC10eXBlJywgJ2NvbnRlbnQtbGVuZ3RoJ107XG4gICAgICBPYmplY3QuZW50cmllcyhmb3JtSGVhZGVycykuZm9yRWFjaCgoW2tleSwgdmFsXSkgPT4ge1xuICAgICAgICBpZiAoYWxsb3dlZEhlYWRlcnMuaW5jbHVkZXMoa2V5LnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICAgICAgaGVhZGVycy5zZXQoa2V5LCB2YWwpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0gIFxuXG4gIC8vIEFkZCB4c3JmIGhlYWRlclxuICAvLyBUaGlzIGlzIG9ubHkgZG9uZSBpZiBydW5uaW5nIGluIGEgc3RhbmRhcmQgYnJvd3NlciBlbnZpcm9ubWVudC5cbiAgLy8gU3BlY2lmaWNhbGx5IG5vdCBpZiB3ZSdyZSBpbiBhIHdlYiB3b3JrZXIsIG9yIHJlYWN0LW5hdGl2ZS5cblxuICBpZiAocGxhdGZvcm0uaGFzU3RhbmRhcmRCcm93c2VyRW52KSB7XG4gICAgd2l0aFhTUkZUb2tlbiAmJiB1dGlscy5pc0Z1bmN0aW9uKHdpdGhYU1JGVG9rZW4pICYmICh3aXRoWFNSRlRva2VuID0gd2l0aFhTUkZUb2tlbihuZXdDb25maWcpKTtcblxuICAgIGlmICh3aXRoWFNSRlRva2VuIHx8ICh3aXRoWFNSRlRva2VuICE9PSBmYWxzZSAmJiBpc1VSTFNhbWVPcmlnaW4obmV3Q29uZmlnLnVybCkpKSB7XG4gICAgICAvLyBBZGQgeHNyZiBoZWFkZXJcbiAgICAgIGNvbnN0IHhzcmZWYWx1ZSA9IHhzcmZIZWFkZXJOYW1lICYmIHhzcmZDb29raWVOYW1lICYmIGNvb2tpZXMucmVhZCh4c3JmQ29va2llTmFtZSk7XG5cbiAgICAgIGlmICh4c3JmVmFsdWUpIHtcbiAgICAgICAgaGVhZGVycy5zZXQoeHNyZkhlYWRlck5hbWUsIHhzcmZWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld0NvbmZpZztcbn1cblxuIiwiaW1wb3J0IHV0aWxzIGZyb20gJy4vLi4vdXRpbHMuanMnO1xuaW1wb3J0IHNldHRsZSBmcm9tICcuLy4uL2NvcmUvc2V0dGxlLmpzJztcbmltcG9ydCB0cmFuc2l0aW9uYWxEZWZhdWx0cyBmcm9tICcuLi9kZWZhdWx0cy90cmFuc2l0aW9uYWwuanMnO1xuaW1wb3J0IEF4aW9zRXJyb3IgZnJvbSAnLi4vY29yZS9BeGlvc0Vycm9yLmpzJztcbmltcG9ydCBDYW5jZWxlZEVycm9yIGZyb20gJy4uL2NhbmNlbC9DYW5jZWxlZEVycm9yLmpzJztcbmltcG9ydCBwYXJzZVByb3RvY29sIGZyb20gJy4uL2hlbHBlcnMvcGFyc2VQcm90b2NvbC5qcyc7XG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnLi4vcGxhdGZvcm0vaW5kZXguanMnO1xuaW1wb3J0IEF4aW9zSGVhZGVycyBmcm9tICcuLi9jb3JlL0F4aW9zSGVhZGVycy5qcyc7XG5pbXBvcnQge3Byb2dyZXNzRXZlbnRSZWR1Y2VyfSBmcm9tICcuLi9oZWxwZXJzL3Byb2dyZXNzRXZlbnRSZWR1Y2VyLmpzJztcbmltcG9ydCByZXNvbHZlQ29uZmlnIGZyb20gXCIuLi9oZWxwZXJzL3Jlc29sdmVDb25maWcuanNcIjtcblxuY29uc3QgaXNYSFJBZGFwdGVyU3VwcG9ydGVkID0gdHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICE9PSAndW5kZWZpbmVkJztcblxuZXhwb3J0IGRlZmF1bHQgaXNYSFJBZGFwdGVyU3VwcG9ydGVkICYmIGZ1bmN0aW9uIChjb25maWcpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIGRpc3BhdGNoWGhyUmVxdWVzdChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBjb25zdCBfY29uZmlnID0gcmVzb2x2ZUNvbmZpZyhjb25maWcpO1xuICAgIGxldCByZXF1ZXN0RGF0YSA9IF9jb25maWcuZGF0YTtcbiAgICBjb25zdCByZXF1ZXN0SGVhZGVycyA9IEF4aW9zSGVhZGVycy5mcm9tKF9jb25maWcuaGVhZGVycykubm9ybWFsaXplKCk7XG4gICAgbGV0IHtyZXNwb25zZVR5cGUsIG9uVXBsb2FkUHJvZ3Jlc3MsIG9uRG93bmxvYWRQcm9ncmVzc30gPSBfY29uZmlnO1xuICAgIGxldCBvbkNhbmNlbGVkO1xuICAgIGxldCB1cGxvYWRUaHJvdHRsZWQsIGRvd25sb2FkVGhyb3R0bGVkO1xuICAgIGxldCBmbHVzaFVwbG9hZCwgZmx1c2hEb3dubG9hZDtcblxuICAgIGZ1bmN0aW9uIGRvbmUoKSB7XG4gICAgICBmbHVzaFVwbG9hZCAmJiBmbHVzaFVwbG9hZCgpOyAvLyBmbHVzaCBldmVudHNcbiAgICAgIGZsdXNoRG93bmxvYWQgJiYgZmx1c2hEb3dubG9hZCgpOyAvLyBmbHVzaCBldmVudHNcblxuICAgICAgX2NvbmZpZy5jYW5jZWxUb2tlbiAmJiBfY29uZmlnLmNhbmNlbFRva2VuLnVuc3Vic2NyaWJlKG9uQ2FuY2VsZWQpO1xuXG4gICAgICBfY29uZmlnLnNpZ25hbCAmJiBfY29uZmlnLnNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIG9uQ2FuY2VsZWQpO1xuICAgIH1cblxuICAgIGxldCByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICByZXF1ZXN0Lm9wZW4oX2NvbmZpZy5tZXRob2QudG9VcHBlckNhc2UoKSwgX2NvbmZpZy51cmwsIHRydWUpO1xuXG4gICAgLy8gU2V0IHRoZSByZXF1ZXN0IHRpbWVvdXQgaW4gTVNcbiAgICByZXF1ZXN0LnRpbWVvdXQgPSBfY29uZmlnLnRpbWVvdXQ7XG5cbiAgICBmdW5jdGlvbiBvbmxvYWRlbmQoKSB7XG4gICAgICBpZiAoIXJlcXVlc3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gUHJlcGFyZSB0aGUgcmVzcG9uc2VcbiAgICAgIGNvbnN0IHJlc3BvbnNlSGVhZGVycyA9IEF4aW9zSGVhZGVycy5mcm9tKFxuICAgICAgICAnZ2V0QWxsUmVzcG9uc2VIZWFkZXJzJyBpbiByZXF1ZXN0ICYmIHJlcXVlc3QuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKClcbiAgICAgICk7XG4gICAgICBjb25zdCByZXNwb25zZURhdGEgPSAhcmVzcG9uc2VUeXBlIHx8IHJlc3BvbnNlVHlwZSA9PT0gJ3RleHQnIHx8IHJlc3BvbnNlVHlwZSA9PT0gJ2pzb24nID9cbiAgICAgICAgcmVxdWVzdC5yZXNwb25zZVRleHQgOiByZXF1ZXN0LnJlc3BvbnNlO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSB7XG4gICAgICAgIGRhdGE6IHJlc3BvbnNlRGF0YSxcbiAgICAgICAgc3RhdHVzOiByZXF1ZXN0LnN0YXR1cyxcbiAgICAgICAgc3RhdHVzVGV4dDogcmVxdWVzdC5zdGF0dXNUZXh0LFxuICAgICAgICBoZWFkZXJzOiByZXNwb25zZUhlYWRlcnMsXG4gICAgICAgIGNvbmZpZyxcbiAgICAgICAgcmVxdWVzdFxuICAgICAgfTtcblxuICAgICAgc2V0dGxlKGZ1bmN0aW9uIF9yZXNvbHZlKHZhbHVlKSB7XG4gICAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgICAgICBkb25lKCk7XG4gICAgICB9LCBmdW5jdGlvbiBfcmVqZWN0KGVycikge1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfSwgcmVzcG9uc2UpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoJ29ubG9hZGVuZCcgaW4gcmVxdWVzdCkge1xuICAgICAgLy8gVXNlIG9ubG9hZGVuZCBpZiBhdmFpbGFibGVcbiAgICAgIHJlcXVlc3Qub25sb2FkZW5kID0gb25sb2FkZW5kO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBMaXN0ZW4gZm9yIHJlYWR5IHN0YXRlIHRvIGVtdWxhdGUgb25sb2FkZW5kXG4gICAgICByZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZUxvYWQoKSB7XG4gICAgICAgIGlmICghcmVxdWVzdCB8fCByZXF1ZXN0LnJlYWR5U3RhdGUgIT09IDQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgcmVxdWVzdCBlcnJvcmVkIG91dCBhbmQgd2UgZGlkbid0IGdldCBhIHJlc3BvbnNlLCB0aGlzIHdpbGwgYmVcbiAgICAgICAgLy8gaGFuZGxlZCBieSBvbmVycm9yIGluc3RlYWRcbiAgICAgICAgLy8gV2l0aCBvbmUgZXhjZXB0aW9uOiByZXF1ZXN0IHRoYXQgdXNpbmcgZmlsZTogcHJvdG9jb2wsIG1vc3QgYnJvd3NlcnNcbiAgICAgICAgLy8gd2lsbCByZXR1cm4gc3RhdHVzIGFzIDAgZXZlbiB0aG91Z2ggaXQncyBhIHN1Y2Nlc3NmdWwgcmVxdWVzdFxuICAgICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPT09IDAgJiYgIShyZXF1ZXN0LnJlc3BvbnNlVVJMICYmIHJlcXVlc3QucmVzcG9uc2VVUkwuaW5kZXhPZignZmlsZTonKSA9PT0gMCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVhZHlzdGF0ZSBoYW5kbGVyIGlzIGNhbGxpbmcgYmVmb3JlIG9uZXJyb3Igb3Igb250aW1lb3V0IGhhbmRsZXJzLFxuICAgICAgICAvLyBzbyB3ZSBzaG91bGQgY2FsbCBvbmxvYWRlbmQgb24gdGhlIG5leHQgJ3RpY2snXG4gICAgICAgIHNldFRpbWVvdXQob25sb2FkZW5kKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIGJyb3dzZXIgcmVxdWVzdCBjYW5jZWxsYXRpb24gKGFzIG9wcG9zZWQgdG8gYSBtYW51YWwgY2FuY2VsbGF0aW9uKVxuICAgIHJlcXVlc3Qub25hYm9ydCA9IGZ1bmN0aW9uIGhhbmRsZUFib3J0KCkge1xuICAgICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmVqZWN0KG5ldyBBeGlvc0Vycm9yKCdSZXF1ZXN0IGFib3J0ZWQnLCBBeGlvc0Vycm9yLkVDT05OQUJPUlRFRCwgY29uZmlnLCByZXF1ZXN0KSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBIYW5kbGUgbG93IGxldmVsIG5ldHdvcmsgZXJyb3JzXG4gIHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uIGhhbmRsZUVycm9yKGV2ZW50KSB7XG4gICAgICAgLy8gQnJvd3NlcnMgZGVsaXZlciBhIFByb2dyZXNzRXZlbnQgaW4gWEhSIG9uZXJyb3JcbiAgICAgICAvLyAobWVzc2FnZSBtYXkgYmUgZW1wdHk7IHdoZW4gcHJlc2VudCwgc3VyZmFjZSBpdClcbiAgICAgICAvLyBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL1hNTEh0dHBSZXF1ZXN0L2Vycm9yX2V2ZW50XG4gICAgICAgY29uc3QgbXNnID0gZXZlbnQgJiYgZXZlbnQubWVzc2FnZSA/IGV2ZW50Lm1lc3NhZ2UgOiAnTmV0d29yayBFcnJvcic7XG4gICAgICAgY29uc3QgZXJyID0gbmV3IEF4aW9zRXJyb3IobXNnLCBBeGlvc0Vycm9yLkVSUl9ORVRXT1JLLCBjb25maWcsIHJlcXVlc3QpO1xuICAgICAgIC8vIGF0dGFjaCB0aGUgdW5kZXJseWluZyBldmVudCBmb3IgY29uc3VtZXJzIHdobyB3YW50IGRldGFpbHNcbiAgICAgICBlcnIuZXZlbnQgPSBldmVudCB8fCBudWxsO1xuICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG4gICAgXG4gICAgLy8gSGFuZGxlIHRpbWVvdXRcbiAgICByZXF1ZXN0Lm9udGltZW91dCA9IGZ1bmN0aW9uIGhhbmRsZVRpbWVvdXQoKSB7XG4gICAgICBsZXQgdGltZW91dEVycm9yTWVzc2FnZSA9IF9jb25maWcudGltZW91dCA/ICd0aW1lb3V0IG9mICcgKyBfY29uZmlnLnRpbWVvdXQgKyAnbXMgZXhjZWVkZWQnIDogJ3RpbWVvdXQgZXhjZWVkZWQnO1xuICAgICAgY29uc3QgdHJhbnNpdGlvbmFsID0gX2NvbmZpZy50cmFuc2l0aW9uYWwgfHwgdHJhbnNpdGlvbmFsRGVmYXVsdHM7XG4gICAgICBpZiAoX2NvbmZpZy50aW1lb3V0RXJyb3JNZXNzYWdlKSB7XG4gICAgICAgIHRpbWVvdXRFcnJvck1lc3NhZ2UgPSBfY29uZmlnLnRpbWVvdXRFcnJvck1lc3NhZ2U7XG4gICAgICB9XG4gICAgICByZWplY3QobmV3IEF4aW9zRXJyb3IoXG4gICAgICAgIHRpbWVvdXRFcnJvck1lc3NhZ2UsXG4gICAgICAgIHRyYW5zaXRpb25hbC5jbGFyaWZ5VGltZW91dEVycm9yID8gQXhpb3NFcnJvci5FVElNRURPVVQgOiBBeGlvc0Vycm9yLkVDT05OQUJPUlRFRCxcbiAgICAgICAgY29uZmlnLFxuICAgICAgICByZXF1ZXN0KSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBSZW1vdmUgQ29udGVudC1UeXBlIGlmIGRhdGEgaXMgdW5kZWZpbmVkXG4gICAgcmVxdWVzdERhdGEgPT09IHVuZGVmaW5lZCAmJiByZXF1ZXN0SGVhZGVycy5zZXRDb250ZW50VHlwZShudWxsKTtcblxuICAgIC8vIEFkZCBoZWFkZXJzIHRvIHRoZSByZXF1ZXN0XG4gICAgaWYgKCdzZXRSZXF1ZXN0SGVhZGVyJyBpbiByZXF1ZXN0KSB7XG4gICAgICB1dGlscy5mb3JFYWNoKHJlcXVlc3RIZWFkZXJzLnRvSlNPTigpLCBmdW5jdGlvbiBzZXRSZXF1ZXN0SGVhZGVyKHZhbCwga2V5KSB7XG4gICAgICAgIHJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcihrZXksIHZhbCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBBZGQgd2l0aENyZWRlbnRpYWxzIHRvIHJlcXVlc3QgaWYgbmVlZGVkXG4gICAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChfY29uZmlnLndpdGhDcmVkZW50aWFscykpIHtcbiAgICAgIHJlcXVlc3Qud2l0aENyZWRlbnRpYWxzID0gISFfY29uZmlnLndpdGhDcmVkZW50aWFscztcbiAgICB9XG5cbiAgICAvLyBBZGQgcmVzcG9uc2VUeXBlIHRvIHJlcXVlc3QgaWYgbmVlZGVkXG4gICAgaWYgKHJlc3BvbnNlVHlwZSAmJiByZXNwb25zZVR5cGUgIT09ICdqc29uJykge1xuICAgICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSBfY29uZmlnLnJlc3BvbnNlVHlwZTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgcHJvZ3Jlc3MgaWYgbmVlZGVkXG4gICAgaWYgKG9uRG93bmxvYWRQcm9ncmVzcykge1xuICAgICAgKFtkb3dubG9hZFRocm90dGxlZCwgZmx1c2hEb3dubG9hZF0gPSBwcm9ncmVzc0V2ZW50UmVkdWNlcihvbkRvd25sb2FkUHJvZ3Jlc3MsIHRydWUpKTtcbiAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBkb3dubG9hZFRocm90dGxlZCk7XG4gICAgfVxuXG4gICAgLy8gTm90IGFsbCBicm93c2VycyBzdXBwb3J0IHVwbG9hZCBldmVudHNcbiAgICBpZiAob25VcGxvYWRQcm9ncmVzcyAmJiByZXF1ZXN0LnVwbG9hZCkge1xuICAgICAgKFt1cGxvYWRUaHJvdHRsZWQsIGZsdXNoVXBsb2FkXSA9IHByb2dyZXNzRXZlbnRSZWR1Y2VyKG9uVXBsb2FkUHJvZ3Jlc3MpKTtcblxuICAgICAgcmVxdWVzdC51cGxvYWQuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCB1cGxvYWRUaHJvdHRsZWQpO1xuXG4gICAgICByZXF1ZXN0LnVwbG9hZC5hZGRFdmVudExpc3RlbmVyKCdsb2FkZW5kJywgZmx1c2hVcGxvYWQpO1xuICAgIH1cblxuICAgIGlmIChfY29uZmlnLmNhbmNlbFRva2VuIHx8IF9jb25maWcuc2lnbmFsKSB7XG4gICAgICAvLyBIYW5kbGUgY2FuY2VsbGF0aW9uXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuICAgICAgb25DYW5jZWxlZCA9IGNhbmNlbCA9PiB7XG4gICAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZWplY3QoIWNhbmNlbCB8fCBjYW5jZWwudHlwZSA/IG5ldyBDYW5jZWxlZEVycm9yKG51bGwsIGNvbmZpZywgcmVxdWVzdCkgOiBjYW5jZWwpO1xuICAgICAgICByZXF1ZXN0LmFib3J0KCk7XG4gICAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgICAgfTtcblxuICAgICAgX2NvbmZpZy5jYW5jZWxUb2tlbiAmJiBfY29uZmlnLmNhbmNlbFRva2VuLnN1YnNjcmliZShvbkNhbmNlbGVkKTtcbiAgICAgIGlmIChfY29uZmlnLnNpZ25hbCkge1xuICAgICAgICBfY29uZmlnLnNpZ25hbC5hYm9ydGVkID8gb25DYW5jZWxlZCgpIDogX2NvbmZpZy5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBvbkNhbmNlbGVkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBwcm90b2NvbCA9IHBhcnNlUHJvdG9jb2woX2NvbmZpZy51cmwpO1xuXG4gICAgaWYgKHByb3RvY29sICYmIHBsYXRmb3JtLnByb3RvY29scy5pbmRleE9mKHByb3RvY29sKSA9PT0gLTEpIHtcbiAgICAgIHJlamVjdChuZXcgQXhpb3NFcnJvcignVW5zdXBwb3J0ZWQgcHJvdG9jb2wgJyArIHByb3RvY29sICsgJzonLCBBeGlvc0Vycm9yLkVSUl9CQURfUkVRVUVTVCwgY29uZmlnKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG5cbiAgICAvLyBTZW5kIHRoZSByZXF1ZXN0XG4gICAgcmVxdWVzdC5zZW5kKHJlcXVlc3REYXRhIHx8IG51bGwpO1xuICB9KTtcbn1cbiIsImltcG9ydCBDYW5jZWxlZEVycm9yIGZyb20gXCIuLi9jYW5jZWwvQ2FuY2VsZWRFcnJvci5qc1wiO1xuaW1wb3J0IEF4aW9zRXJyb3IgZnJvbSBcIi4uL2NvcmUvQXhpb3NFcnJvci5qc1wiO1xuaW1wb3J0IHV0aWxzIGZyb20gJy4uL3V0aWxzLmpzJztcblxuY29uc3QgY29tcG9zZVNpZ25hbHMgPSAoc2lnbmFscywgdGltZW91dCkgPT4ge1xuICBjb25zdCB7bGVuZ3RofSA9IChzaWduYWxzID0gc2lnbmFscyA/IHNpZ25hbHMuZmlsdGVyKEJvb2xlYW4pIDogW10pO1xuXG4gIGlmICh0aW1lb3V0IHx8IGxlbmd0aCkge1xuICAgIGxldCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuXG4gICAgbGV0IGFib3J0ZWQ7XG5cbiAgICBjb25zdCBvbmFib3J0ID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgaWYgKCFhYm9ydGVkKSB7XG4gICAgICAgIGFib3J0ZWQgPSB0cnVlO1xuICAgICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgICBjb25zdCBlcnIgPSByZWFzb24gaW5zdGFuY2VvZiBFcnJvciA/IHJlYXNvbiA6IHRoaXMucmVhc29uO1xuICAgICAgICBjb250cm9sbGVyLmFib3J0KGVyciBpbnN0YW5jZW9mIEF4aW9zRXJyb3IgPyBlcnIgOiBuZXcgQ2FuY2VsZWRFcnJvcihlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyci5tZXNzYWdlIDogZXJyKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHRpbWVyID0gdGltZW91dCAmJiBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRpbWVyID0gbnVsbDtcbiAgICAgIG9uYWJvcnQobmV3IEF4aW9zRXJyb3IoYHRpbWVvdXQgJHt0aW1lb3V0fSBvZiBtcyBleGNlZWRlZGAsIEF4aW9zRXJyb3IuRVRJTUVET1VUKSlcbiAgICB9LCB0aW1lb3V0KVxuXG4gICAgY29uc3QgdW5zdWJzY3JpYmUgPSAoKSA9PiB7XG4gICAgICBpZiAoc2lnbmFscykge1xuICAgICAgICB0aW1lciAmJiBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICB0aW1lciA9IG51bGw7XG4gICAgICAgIHNpZ25hbHMuZm9yRWFjaChzaWduYWwgPT4ge1xuICAgICAgICAgIHNpZ25hbC51bnN1YnNjcmliZSA/IHNpZ25hbC51bnN1YnNjcmliZShvbmFib3J0KSA6IHNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIG9uYWJvcnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgc2lnbmFscyA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2lnbmFscy5mb3JFYWNoKChzaWduYWwpID0+IHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIG9uYWJvcnQpKTtcblxuICAgIGNvbnN0IHtzaWduYWx9ID0gY29udHJvbGxlcjtcblxuICAgIHNpZ25hbC51bnN1YnNjcmliZSA9ICgpID0+IHV0aWxzLmFzYXAodW5zdWJzY3JpYmUpO1xuXG4gICAgcmV0dXJuIHNpZ25hbDtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBjb21wb3NlU2lnbmFscztcbiIsIlxuZXhwb3J0IGNvbnN0IHN0cmVhbUNodW5rID0gZnVuY3Rpb24qIChjaHVuaywgY2h1bmtTaXplKSB7XG4gIGxldCBsZW4gPSBjaHVuay5ieXRlTGVuZ3RoO1xuXG4gIGlmICghY2h1bmtTaXplIHx8IGxlbiA8IGNodW5rU2l6ZSkge1xuICAgIHlpZWxkIGNodW5rO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGxldCBwb3MgPSAwO1xuICBsZXQgZW5kO1xuXG4gIHdoaWxlIChwb3MgPCBsZW4pIHtcbiAgICBlbmQgPSBwb3MgKyBjaHVua1NpemU7XG4gICAgeWllbGQgY2h1bmsuc2xpY2UocG9zLCBlbmQpO1xuICAgIHBvcyA9IGVuZDtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgcmVhZEJ5dGVzID0gYXN5bmMgZnVuY3Rpb24qIChpdGVyYWJsZSwgY2h1bmtTaXplKSB7XG4gIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgcmVhZFN0cmVhbShpdGVyYWJsZSkpIHtcbiAgICB5aWVsZCogc3RyZWFtQ2h1bmsoY2h1bmssIGNodW5rU2l6ZSk7XG4gIH1cbn1cblxuY29uc3QgcmVhZFN0cmVhbSA9IGFzeW5jIGZ1bmN0aW9uKiAoc3RyZWFtKSB7XG4gIGlmIChzdHJlYW1bU3ltYm9sLmFzeW5jSXRlcmF0b3JdKSB7XG4gICAgeWllbGQqIHN0cmVhbTtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCByZWFkZXIgPSBzdHJlYW0uZ2V0UmVhZGVyKCk7XG4gIHRyeSB7XG4gICAgZm9yICg7Oykge1xuICAgICAgY29uc3Qge2RvbmUsIHZhbHVlfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICBpZiAoZG9uZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHlpZWxkIHZhbHVlO1xuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICBhd2FpdCByZWFkZXIuY2FuY2VsKCk7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHRyYWNrU3RyZWFtID0gKHN0cmVhbSwgY2h1bmtTaXplLCBvblByb2dyZXNzLCBvbkZpbmlzaCkgPT4ge1xuICBjb25zdCBpdGVyYXRvciA9IHJlYWRCeXRlcyhzdHJlYW0sIGNodW5rU2l6ZSk7XG5cbiAgbGV0IGJ5dGVzID0gMDtcbiAgbGV0IGRvbmU7XG4gIGxldCBfb25GaW5pc2ggPSAoZSkgPT4ge1xuICAgIGlmICghZG9uZSkge1xuICAgICAgZG9uZSA9IHRydWU7XG4gICAgICBvbkZpbmlzaCAmJiBvbkZpbmlzaChlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBhc3luYyBwdWxsKGNvbnRyb2xsZXIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHtkb25lLCB2YWx1ZX0gPSBhd2FpdCBpdGVyYXRvci5uZXh0KCk7XG5cbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgIF9vbkZpbmlzaCgpO1xuICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbGVuID0gdmFsdWUuYnl0ZUxlbmd0aDtcbiAgICAgICAgaWYgKG9uUHJvZ3Jlc3MpIHtcbiAgICAgICAgICBsZXQgbG9hZGVkQnl0ZXMgPSBieXRlcyArPSBsZW47XG4gICAgICAgICAgb25Qcm9ncmVzcyhsb2FkZWRCeXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKG5ldyBVaW50OEFycmF5KHZhbHVlKSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX29uRmluaXNoKGVycik7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9LFxuICAgIGNhbmNlbChyZWFzb24pIHtcbiAgICAgIF9vbkZpbmlzaChyZWFzb24pO1xuICAgICAgcmV0dXJuIGl0ZXJhdG9yLnJldHVybigpO1xuICAgIH1cbiAgfSwge1xuICAgIGhpZ2hXYXRlck1hcms6IDJcbiAgfSlcbn1cbiIsImltcG9ydCBwbGF0Zm9ybSBmcm9tIFwiLi4vcGxhdGZvcm0vaW5kZXguanNcIjtcbmltcG9ydCB1dGlscyBmcm9tIFwiLi4vdXRpbHMuanNcIjtcbmltcG9ydCBBeGlvc0Vycm9yIGZyb20gXCIuLi9jb3JlL0F4aW9zRXJyb3IuanNcIjtcbmltcG9ydCBjb21wb3NlU2lnbmFscyBmcm9tIFwiLi4vaGVscGVycy9jb21wb3NlU2lnbmFscy5qc1wiO1xuaW1wb3J0IHt0cmFja1N0cmVhbX0gZnJvbSBcIi4uL2hlbHBlcnMvdHJhY2tTdHJlYW0uanNcIjtcbmltcG9ydCBBeGlvc0hlYWRlcnMgZnJvbSBcIi4uL2NvcmUvQXhpb3NIZWFkZXJzLmpzXCI7XG5pbXBvcnQge3Byb2dyZXNzRXZlbnRSZWR1Y2VyLCBwcm9ncmVzc0V2ZW50RGVjb3JhdG9yLCBhc3luY0RlY29yYXRvcn0gZnJvbSBcIi4uL2hlbHBlcnMvcHJvZ3Jlc3NFdmVudFJlZHVjZXIuanNcIjtcbmltcG9ydCByZXNvbHZlQ29uZmlnIGZyb20gXCIuLi9oZWxwZXJzL3Jlc29sdmVDb25maWcuanNcIjtcbmltcG9ydCBzZXR0bGUgZnJvbSBcIi4uL2NvcmUvc2V0dGxlLmpzXCI7XG5cbmNvbnN0IERFRkFVTFRfQ0hVTktfU0laRSA9IDY0ICogMTAyNDtcblxuY29uc3Qge2lzRnVuY3Rpb259ID0gdXRpbHM7XG5cbmNvbnN0IGdsb2JhbEZldGNoQVBJID0gKCh7UmVxdWVzdCwgUmVzcG9uc2V9KSA9PiAoe1xuICBSZXF1ZXN0LCBSZXNwb25zZVxufSkpKHV0aWxzLmdsb2JhbCk7XG5cbmNvbnN0IHtcbiAgUmVhZGFibGVTdHJlYW0sIFRleHRFbmNvZGVyXG59ID0gdXRpbHMuZ2xvYmFsO1xuXG5cbmNvbnN0IHRlc3QgPSAoZm4sIC4uLmFyZ3MpID0+IHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFmbiguLi5hcmdzKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmNvbnN0IGZhY3RvcnkgPSAoZW52KSA9PiB7XG4gIGVudiA9IHV0aWxzLm1lcmdlLmNhbGwoe1xuICAgIHNraXBVbmRlZmluZWQ6IHRydWVcbiAgfSwgZ2xvYmFsRmV0Y2hBUEksIGVudik7XG5cbiAgY29uc3Qge2ZldGNoOiBlbnZGZXRjaCwgUmVxdWVzdCwgUmVzcG9uc2V9ID0gZW52O1xuICBjb25zdCBpc0ZldGNoU3VwcG9ydGVkID0gZW52RmV0Y2ggPyBpc0Z1bmN0aW9uKGVudkZldGNoKSA6IHR5cGVvZiBmZXRjaCA9PT0gJ2Z1bmN0aW9uJztcbiAgY29uc3QgaXNSZXF1ZXN0U3VwcG9ydGVkID0gaXNGdW5jdGlvbihSZXF1ZXN0KTtcbiAgY29uc3QgaXNSZXNwb25zZVN1cHBvcnRlZCA9IGlzRnVuY3Rpb24oUmVzcG9uc2UpO1xuXG4gIGlmICghaXNGZXRjaFN1cHBvcnRlZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IGlzUmVhZGFibGVTdHJlYW1TdXBwb3J0ZWQgPSBpc0ZldGNoU3VwcG9ydGVkICYmIGlzRnVuY3Rpb24oUmVhZGFibGVTdHJlYW0pO1xuXG4gIGNvbnN0IGVuY29kZVRleHQgPSBpc0ZldGNoU3VwcG9ydGVkICYmICh0eXBlb2YgVGV4dEVuY29kZXIgPT09ICdmdW5jdGlvbicgP1xuICAgICAgKChlbmNvZGVyKSA9PiAoc3RyKSA9PiBlbmNvZGVyLmVuY29kZShzdHIpKShuZXcgVGV4dEVuY29kZXIoKSkgOlxuICAgICAgYXN5bmMgKHN0cikgPT4gbmV3IFVpbnQ4QXJyYXkoYXdhaXQgbmV3IFJlcXVlc3Qoc3RyKS5hcnJheUJ1ZmZlcigpKVxuICApO1xuXG4gIGNvbnN0IHN1cHBvcnRzUmVxdWVzdFN0cmVhbSA9IGlzUmVxdWVzdFN1cHBvcnRlZCAmJiBpc1JlYWRhYmxlU3RyZWFtU3VwcG9ydGVkICYmIHRlc3QoKCkgPT4ge1xuICAgIGxldCBkdXBsZXhBY2Nlc3NlZCA9IGZhbHNlO1xuXG4gICAgY29uc3QgaGFzQ29udGVudFR5cGUgPSBuZXcgUmVxdWVzdChwbGF0Zm9ybS5vcmlnaW4sIHtcbiAgICAgIGJvZHk6IG5ldyBSZWFkYWJsZVN0cmVhbSgpLFxuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICBnZXQgZHVwbGV4KCkge1xuICAgICAgICBkdXBsZXhBY2Nlc3NlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiAnaGFsZic7XG4gICAgICB9LFxuICAgIH0pLmhlYWRlcnMuaGFzKCdDb250ZW50LVR5cGUnKTtcblxuICAgIHJldHVybiBkdXBsZXhBY2Nlc3NlZCAmJiAhaGFzQ29udGVudFR5cGU7XG4gIH0pO1xuXG4gIGNvbnN0IHN1cHBvcnRzUmVzcG9uc2VTdHJlYW0gPSBpc1Jlc3BvbnNlU3VwcG9ydGVkICYmIGlzUmVhZGFibGVTdHJlYW1TdXBwb3J0ZWQgJiZcbiAgICB0ZXN0KCgpID0+IHV0aWxzLmlzUmVhZGFibGVTdHJlYW0obmV3IFJlc3BvbnNlKCcnKS5ib2R5KSk7XG5cbiAgY29uc3QgcmVzb2x2ZXJzID0ge1xuICAgIHN0cmVhbTogc3VwcG9ydHNSZXNwb25zZVN0cmVhbSAmJiAoKHJlcykgPT4gcmVzLmJvZHkpXG4gIH07XG5cbiAgaXNGZXRjaFN1cHBvcnRlZCAmJiAoKCgpID0+IHtcbiAgICBbJ3RleHQnLCAnYXJyYXlCdWZmZXInLCAnYmxvYicsICdmb3JtRGF0YScsICdzdHJlYW0nXS5mb3JFYWNoKHR5cGUgPT4ge1xuICAgICAgIXJlc29sdmVyc1t0eXBlXSAmJiAocmVzb2x2ZXJzW3R5cGVdID0gKHJlcywgY29uZmlnKSA9PiB7XG4gICAgICAgIGxldCBtZXRob2QgPSByZXMgJiYgcmVzW3R5cGVdO1xuXG4gICAgICAgIGlmIChtZXRob2QpIHtcbiAgICAgICAgICByZXR1cm4gbWV0aG9kLmNhbGwocmVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IG5ldyBBeGlvc0Vycm9yKGBSZXNwb25zZSB0eXBlICcke3R5cGV9JyBpcyBub3Qgc3VwcG9ydGVkYCwgQXhpb3NFcnJvci5FUlJfTk9UX1NVUFBPUlQsIGNvbmZpZyk7XG4gICAgICB9KVxuICAgIH0pO1xuICB9KSgpKTtcblxuICBjb25zdCBnZXRCb2R5TGVuZ3RoID0gYXN5bmMgKGJvZHkpID0+IHtcbiAgICBpZiAoYm9keSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBpZiAodXRpbHMuaXNCbG9iKGJvZHkpKSB7XG4gICAgICByZXR1cm4gYm9keS5zaXplO1xuICAgIH1cblxuICAgIGlmICh1dGlscy5pc1NwZWNDb21wbGlhbnRGb3JtKGJvZHkpKSB7XG4gICAgICBjb25zdCBfcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KHBsYXRmb3JtLm9yaWdpbiwge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgYm9keSxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIChhd2FpdCBfcmVxdWVzdC5hcnJheUJ1ZmZlcigpKS5ieXRlTGVuZ3RoO1xuICAgIH1cblxuICAgIGlmICh1dGlscy5pc0FycmF5QnVmZmVyVmlldyhib2R5KSB8fCB1dGlscy5pc0FycmF5QnVmZmVyKGJvZHkpKSB7XG4gICAgICByZXR1cm4gYm9keS5ieXRlTGVuZ3RoO1xuICAgIH1cblxuICAgIGlmICh1dGlscy5pc1VSTFNlYXJjaFBhcmFtcyhib2R5KSkge1xuICAgICAgYm9keSA9IGJvZHkgKyAnJztcbiAgICB9XG5cbiAgICBpZiAodXRpbHMuaXNTdHJpbmcoYm9keSkpIHtcbiAgICAgIHJldHVybiAoYXdhaXQgZW5jb2RlVGV4dChib2R5KSkuYnl0ZUxlbmd0aDtcbiAgICB9XG4gIH1cblxuICBjb25zdCByZXNvbHZlQm9keUxlbmd0aCA9IGFzeW5jIChoZWFkZXJzLCBib2R5KSA9PiB7XG4gICAgY29uc3QgbGVuZ3RoID0gdXRpbHMudG9GaW5pdGVOdW1iZXIoaGVhZGVycy5nZXRDb250ZW50TGVuZ3RoKCkpO1xuXG4gICAgcmV0dXJuIGxlbmd0aCA9PSBudWxsID8gZ2V0Qm9keUxlbmd0aChib2R5KSA6IGxlbmd0aDtcbiAgfVxuXG4gIHJldHVybiBhc3luYyAoY29uZmlnKSA9PiB7XG4gICAgbGV0IHtcbiAgICAgIHVybCxcbiAgICAgIG1ldGhvZCxcbiAgICAgIGRhdGEsXG4gICAgICBzaWduYWwsXG4gICAgICBjYW5jZWxUb2tlbixcbiAgICAgIHRpbWVvdXQsXG4gICAgICBvbkRvd25sb2FkUHJvZ3Jlc3MsXG4gICAgICBvblVwbG9hZFByb2dyZXNzLFxuICAgICAgcmVzcG9uc2VUeXBlLFxuICAgICAgaGVhZGVycyxcbiAgICAgIHdpdGhDcmVkZW50aWFscyA9ICdzYW1lLW9yaWdpbicsXG4gICAgICBmZXRjaE9wdGlvbnNcbiAgICB9ID0gcmVzb2x2ZUNvbmZpZyhjb25maWcpO1xuXG4gICAgbGV0IF9mZXRjaCA9IGVudkZldGNoIHx8IGZldGNoO1xuXG4gICAgcmVzcG9uc2VUeXBlID0gcmVzcG9uc2VUeXBlID8gKHJlc3BvbnNlVHlwZSArICcnKS50b0xvd2VyQ2FzZSgpIDogJ3RleHQnO1xuXG4gICAgbGV0IGNvbXBvc2VkU2lnbmFsID0gY29tcG9zZVNpZ25hbHMoW3NpZ25hbCwgY2FuY2VsVG9rZW4gJiYgY2FuY2VsVG9rZW4udG9BYm9ydFNpZ25hbCgpXSwgdGltZW91dCk7XG5cbiAgICBsZXQgcmVxdWVzdCA9IG51bGw7XG5cbiAgICBjb25zdCB1bnN1YnNjcmliZSA9IGNvbXBvc2VkU2lnbmFsICYmIGNvbXBvc2VkU2lnbmFsLnVuc3Vic2NyaWJlICYmICgoKSA9PiB7XG4gICAgICBjb21wb3NlZFNpZ25hbC51bnN1YnNjcmliZSgpO1xuICAgIH0pO1xuXG4gICAgbGV0IHJlcXVlc3RDb250ZW50TGVuZ3RoO1xuXG4gICAgdHJ5IHtcbiAgICAgIGlmIChcbiAgICAgICAgb25VcGxvYWRQcm9ncmVzcyAmJiBzdXBwb3J0c1JlcXVlc3RTdHJlYW0gJiYgbWV0aG9kICE9PSAnZ2V0JyAmJiBtZXRob2QgIT09ICdoZWFkJyAmJlxuICAgICAgICAocmVxdWVzdENvbnRlbnRMZW5ndGggPSBhd2FpdCByZXNvbHZlQm9keUxlbmd0aChoZWFkZXJzLCBkYXRhKSkgIT09IDBcbiAgICAgICkge1xuICAgICAgICBsZXQgX3JlcXVlc3QgPSBuZXcgUmVxdWVzdCh1cmwsIHtcbiAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICBib2R5OiBkYXRhLFxuICAgICAgICAgIGR1cGxleDogXCJoYWxmXCJcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbGV0IGNvbnRlbnRUeXBlSGVhZGVyO1xuXG4gICAgICAgIGlmICh1dGlscy5pc0Zvcm1EYXRhKGRhdGEpICYmIChjb250ZW50VHlwZUhlYWRlciA9IF9yZXF1ZXN0LmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKSkpIHtcbiAgICAgICAgICBoZWFkZXJzLnNldENvbnRlbnRUeXBlKGNvbnRlbnRUeXBlSGVhZGVyKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF9yZXF1ZXN0LmJvZHkpIHtcbiAgICAgICAgICBjb25zdCBbb25Qcm9ncmVzcywgZmx1c2hdID0gcHJvZ3Jlc3NFdmVudERlY29yYXRvcihcbiAgICAgICAgICAgIHJlcXVlc3RDb250ZW50TGVuZ3RoLFxuICAgICAgICAgICAgcHJvZ3Jlc3NFdmVudFJlZHVjZXIoYXN5bmNEZWNvcmF0b3Iob25VcGxvYWRQcm9ncmVzcykpXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGRhdGEgPSB0cmFja1N0cmVhbShfcmVxdWVzdC5ib2R5LCBERUZBVUxUX0NIVU5LX1NJWkUsIG9uUHJvZ3Jlc3MsIGZsdXNoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXV0aWxzLmlzU3RyaW5nKHdpdGhDcmVkZW50aWFscykpIHtcbiAgICAgICAgd2l0aENyZWRlbnRpYWxzID0gd2l0aENyZWRlbnRpYWxzID8gJ2luY2x1ZGUnIDogJ29taXQnO1xuICAgICAgfVxuXG4gICAgICAvLyBDbG91ZGZsYXJlIFdvcmtlcnMgdGhyb3dzIHdoZW4gY3JlZGVudGlhbHMgYXJlIGRlZmluZWRcbiAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vY2xvdWRmbGFyZS93b3JrZXJkL2lzc3Vlcy85MDJcbiAgICAgIGNvbnN0IGlzQ3JlZGVudGlhbHNTdXBwb3J0ZWQgPSBpc1JlcXVlc3RTdXBwb3J0ZWQgJiYgXCJjcmVkZW50aWFsc1wiIGluIFJlcXVlc3QucHJvdG90eXBlO1xuXG4gICAgICBjb25zdCByZXNvbHZlZE9wdGlvbnMgPSB7XG4gICAgICAgIC4uLmZldGNoT3B0aW9ucyxcbiAgICAgICAgc2lnbmFsOiBjb21wb3NlZFNpZ25hbCxcbiAgICAgICAgbWV0aG9kOiBtZXRob2QudG9VcHBlckNhc2UoKSxcbiAgICAgICAgaGVhZGVyczogaGVhZGVycy5ub3JtYWxpemUoKS50b0pTT04oKSxcbiAgICAgICAgYm9keTogZGF0YSxcbiAgICAgICAgZHVwbGV4OiBcImhhbGZcIixcbiAgICAgICAgY3JlZGVudGlhbHM6IGlzQ3JlZGVudGlhbHNTdXBwb3J0ZWQgPyB3aXRoQ3JlZGVudGlhbHMgOiB1bmRlZmluZWRcbiAgICAgIH07XG5cbiAgICAgIHJlcXVlc3QgPSBpc1JlcXVlc3RTdXBwb3J0ZWQgJiYgbmV3IFJlcXVlc3QodXJsLCByZXNvbHZlZE9wdGlvbnMpO1xuXG4gICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCAoaXNSZXF1ZXN0U3VwcG9ydGVkID8gX2ZldGNoKHJlcXVlc3QsIGZldGNoT3B0aW9ucykgOiBfZmV0Y2godXJsLCByZXNvbHZlZE9wdGlvbnMpKTtcblxuICAgICAgY29uc3QgaXNTdHJlYW1SZXNwb25zZSA9IHN1cHBvcnRzUmVzcG9uc2VTdHJlYW0gJiYgKHJlc3BvbnNlVHlwZSA9PT0gJ3N0cmVhbScgfHwgcmVzcG9uc2VUeXBlID09PSAncmVzcG9uc2UnKTtcblxuICAgICAgaWYgKHN1cHBvcnRzUmVzcG9uc2VTdHJlYW0gJiYgKG9uRG93bmxvYWRQcm9ncmVzcyB8fCAoaXNTdHJlYW1SZXNwb25zZSAmJiB1bnN1YnNjcmliZSkpKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7fTtcblxuICAgICAgICBbJ3N0YXR1cycsICdzdGF0dXNUZXh0JywgJ2hlYWRlcnMnXS5mb3JFYWNoKHByb3AgPT4ge1xuICAgICAgICAgIG9wdGlvbnNbcHJvcF0gPSByZXNwb25zZVtwcm9wXTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgcmVzcG9uc2VDb250ZW50TGVuZ3RoID0gdXRpbHMudG9GaW5pdGVOdW1iZXIocmVzcG9uc2UuaGVhZGVycy5nZXQoJ2NvbnRlbnQtbGVuZ3RoJykpO1xuXG4gICAgICAgIGNvbnN0IFtvblByb2dyZXNzLCBmbHVzaF0gPSBvbkRvd25sb2FkUHJvZ3Jlc3MgJiYgcHJvZ3Jlc3NFdmVudERlY29yYXRvcihcbiAgICAgICAgICByZXNwb25zZUNvbnRlbnRMZW5ndGgsXG4gICAgICAgICAgcHJvZ3Jlc3NFdmVudFJlZHVjZXIoYXN5bmNEZWNvcmF0b3Iob25Eb3dubG9hZFByb2dyZXNzKSwgdHJ1ZSlcbiAgICAgICAgKSB8fCBbXTtcblxuICAgICAgICByZXNwb25zZSA9IG5ldyBSZXNwb25zZShcbiAgICAgICAgICB0cmFja1N0cmVhbShyZXNwb25zZS5ib2R5LCBERUZBVUxUX0NIVU5LX1NJWkUsIG9uUHJvZ3Jlc3MsICgpID0+IHtcbiAgICAgICAgICAgIGZsdXNoICYmIGZsdXNoKCk7XG4gICAgICAgICAgICB1bnN1YnNjcmliZSAmJiB1bnN1YnNjcmliZSgpO1xuICAgICAgICAgIH0pLFxuICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgcmVzcG9uc2VUeXBlID0gcmVzcG9uc2VUeXBlIHx8ICd0ZXh0JztcblxuICAgICAgbGV0IHJlc3BvbnNlRGF0YSA9IGF3YWl0IHJlc29sdmVyc1t1dGlscy5maW5kS2V5KHJlc29sdmVycywgcmVzcG9uc2VUeXBlKSB8fCAndGV4dCddKHJlc3BvbnNlLCBjb25maWcpO1xuXG4gICAgICAhaXNTdHJlYW1SZXNwb25zZSAmJiB1bnN1YnNjcmliZSAmJiB1bnN1YnNjcmliZSgpO1xuXG4gICAgICByZXR1cm4gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB7XG4gICAgICAgICAgZGF0YTogcmVzcG9uc2VEYXRhLFxuICAgICAgICAgIGhlYWRlcnM6IEF4aW9zSGVhZGVycy5mcm9tKHJlc3BvbnNlLmhlYWRlcnMpLFxuICAgICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgIHN0YXR1c1RleHQ6IHJlc3BvbnNlLnN0YXR1c1RleHQsXG4gICAgICAgICAgY29uZmlnLFxuICAgICAgICAgIHJlcXVlc3RcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB1bnN1YnNjcmliZSAmJiB1bnN1YnNjcmliZSgpO1xuXG4gICAgICBpZiAoZXJyICYmIGVyci5uYW1lID09PSAnVHlwZUVycm9yJyAmJiAvTG9hZCBmYWlsZWR8ZmV0Y2gvaS50ZXN0KGVyci5tZXNzYWdlKSkge1xuICAgICAgICB0aHJvdyBPYmplY3QuYXNzaWduKFxuICAgICAgICAgIG5ldyBBeGlvc0Vycm9yKCdOZXR3b3JrIEVycm9yJywgQXhpb3NFcnJvci5FUlJfTkVUV09SSywgY29uZmlnLCByZXF1ZXN0KSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjYXVzZTogZXJyLmNhdXNlIHx8IGVyclxuICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBBeGlvc0Vycm9yLmZyb20oZXJyLCBlcnIgJiYgZXJyLmNvZGUsIGNvbmZpZywgcmVxdWVzdCk7XG4gICAgfVxuICB9XG59XG5cbmNvbnN0IHNlZWRDYWNoZSA9IG5ldyBNYXAoKTtcblxuZXhwb3J0IGNvbnN0IGdldEZldGNoID0gKGNvbmZpZykgPT4ge1xuICBsZXQgZW52ID0gY29uZmlnID8gY29uZmlnLmVudiA6IHt9O1xuICBjb25zdCB7ZmV0Y2gsIFJlcXVlc3QsIFJlc3BvbnNlfSA9IGVudjtcbiAgY29uc3Qgc2VlZHMgPSBbXG4gICAgUmVxdWVzdCwgUmVzcG9uc2UsIGZldGNoXG4gIF07XG5cbiAgbGV0IGxlbiA9IHNlZWRzLmxlbmd0aCwgaSA9IGxlbixcbiAgICBzZWVkLCB0YXJnZXQsIG1hcCA9IHNlZWRDYWNoZTtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgc2VlZCA9IHNlZWRzW2ldO1xuICAgIHRhcmdldCA9IG1hcC5nZXQoc2VlZCk7XG5cbiAgICB0YXJnZXQgPT09IHVuZGVmaW5lZCAmJiBtYXAuc2V0KHNlZWQsIHRhcmdldCA9IChpID8gbmV3IE1hcCgpIDogZmFjdG9yeShlbnYpKSlcblxuICAgIG1hcCA9IHRhcmdldDtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG5jb25zdCBhZGFwdGVyID0gZ2V0RmV0Y2goKTtcblxuZXhwb3J0IGRlZmF1bHQgYWRhcHRlcjtcbiIsImltcG9ydCB1dGlscyBmcm9tICcuLi91dGlscy5qcyc7XG5pbXBvcnQgaHR0cEFkYXB0ZXIgZnJvbSAnLi9odHRwLmpzJztcbmltcG9ydCB4aHJBZGFwdGVyIGZyb20gJy4veGhyLmpzJztcbmltcG9ydCAqIGFzIGZldGNoQWRhcHRlciBmcm9tICcuL2ZldGNoLmpzJztcbmltcG9ydCBBeGlvc0Vycm9yIGZyb20gXCIuLi9jb3JlL0F4aW9zRXJyb3IuanNcIjtcblxuY29uc3Qga25vd25BZGFwdGVycyA9IHtcbiAgaHR0cDogaHR0cEFkYXB0ZXIsXG4gIHhocjogeGhyQWRhcHRlcixcbiAgZmV0Y2g6IHtcbiAgICBnZXQ6IGZldGNoQWRhcHRlci5nZXRGZXRjaCxcbiAgfVxufVxuXG51dGlscy5mb3JFYWNoKGtub3duQWRhcHRlcnMsIChmbiwgdmFsdWUpID0+IHtcbiAgaWYgKGZuKSB7XG4gICAgdHJ5IHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbiwgJ25hbWUnLCB7dmFsdWV9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZW1wdHlcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZuLCAnYWRhcHRlck5hbWUnLCB7dmFsdWV9KTtcbiAgfVxufSk7XG5cbmNvbnN0IHJlbmRlclJlYXNvbiA9IChyZWFzb24pID0+IGAtICR7cmVhc29ufWA7XG5cbmNvbnN0IGlzUmVzb2x2ZWRIYW5kbGUgPSAoYWRhcHRlcikgPT4gdXRpbHMuaXNGdW5jdGlvbihhZGFwdGVyKSB8fCBhZGFwdGVyID09PSBudWxsIHx8IGFkYXB0ZXIgPT09IGZhbHNlO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGdldEFkYXB0ZXI6IChhZGFwdGVycywgY29uZmlnKSA9PiB7XG4gICAgYWRhcHRlcnMgPSB1dGlscy5pc0FycmF5KGFkYXB0ZXJzKSA/IGFkYXB0ZXJzIDogW2FkYXB0ZXJzXTtcblxuICAgIGNvbnN0IHtsZW5ndGh9ID0gYWRhcHRlcnM7XG4gICAgbGV0IG5hbWVPckFkYXB0ZXI7XG4gICAgbGV0IGFkYXB0ZXI7XG5cbiAgICBjb25zdCByZWplY3RlZFJlYXNvbnMgPSB7fTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIG5hbWVPckFkYXB0ZXIgPSBhZGFwdGVyc1tpXTtcbiAgICAgIGxldCBpZDtcblxuICAgICAgYWRhcHRlciA9IG5hbWVPckFkYXB0ZXI7XG5cbiAgICAgIGlmICghaXNSZXNvbHZlZEhhbmRsZShuYW1lT3JBZGFwdGVyKSkge1xuICAgICAgICBhZGFwdGVyID0ga25vd25BZGFwdGVyc1soaWQgPSBTdHJpbmcobmFtZU9yQWRhcHRlcikpLnRvTG93ZXJDYXNlKCldO1xuXG4gICAgICAgIGlmIChhZGFwdGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgQXhpb3NFcnJvcihgVW5rbm93biBhZGFwdGVyICcke2lkfSdgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoYWRhcHRlciAmJiAodXRpbHMuaXNGdW5jdGlvbihhZGFwdGVyKSB8fCAoYWRhcHRlciA9IGFkYXB0ZXIuZ2V0KGNvbmZpZykpKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgcmVqZWN0ZWRSZWFzb25zW2lkIHx8ICcjJyArIGldID0gYWRhcHRlcjtcbiAgICB9XG5cbiAgICBpZiAoIWFkYXB0ZXIpIHtcblxuICAgICAgY29uc3QgcmVhc29ucyA9IE9iamVjdC5lbnRyaWVzKHJlamVjdGVkUmVhc29ucylcbiAgICAgICAgLm1hcCgoW2lkLCBzdGF0ZV0pID0+IGBhZGFwdGVyICR7aWR9IGAgK1xuICAgICAgICAgIChzdGF0ZSA9PT0gZmFsc2UgPyAnaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgZW52aXJvbm1lbnQnIDogJ2lzIG5vdCBhdmFpbGFibGUgaW4gdGhlIGJ1aWxkJylcbiAgICAgICAgKTtcblxuICAgICAgbGV0IHMgPSBsZW5ndGggP1xuICAgICAgICAocmVhc29ucy5sZW5ndGggPiAxID8gJ3NpbmNlIDpcXG4nICsgcmVhc29ucy5tYXAocmVuZGVyUmVhc29uKS5qb2luKCdcXG4nKSA6ICcgJyArIHJlbmRlclJlYXNvbihyZWFzb25zWzBdKSkgOlxuICAgICAgICAnYXMgbm8gYWRhcHRlciBzcGVjaWZpZWQnO1xuXG4gICAgICB0aHJvdyBuZXcgQXhpb3NFcnJvcihcbiAgICAgICAgYFRoZXJlIGlzIG5vIHN1aXRhYmxlIGFkYXB0ZXIgdG8gZGlzcGF0Y2ggdGhlIHJlcXVlc3QgYCArIHMsXG4gICAgICAgICdFUlJfTk9UX1NVUFBPUlQnXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBhZGFwdGVyO1xuICB9LFxuICBhZGFwdGVyczoga25vd25BZGFwdGVyc1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgdHJhbnNmb3JtRGF0YSBmcm9tICcuL3RyYW5zZm9ybURhdGEuanMnO1xuaW1wb3J0IGlzQ2FuY2VsIGZyb20gJy4uL2NhbmNlbC9pc0NhbmNlbC5qcyc7XG5pbXBvcnQgZGVmYXVsdHMgZnJvbSAnLi4vZGVmYXVsdHMvaW5kZXguanMnO1xuaW1wb3J0IENhbmNlbGVkRXJyb3IgZnJvbSAnLi4vY2FuY2VsL0NhbmNlbGVkRXJyb3IuanMnO1xuaW1wb3J0IEF4aW9zSGVhZGVycyBmcm9tICcuLi9jb3JlL0F4aW9zSGVhZGVycy5qcyc7XG5pbXBvcnQgYWRhcHRlcnMgZnJvbSBcIi4uL2FkYXB0ZXJzL2FkYXB0ZXJzLmpzXCI7XG5cbi8qKlxuICogVGhyb3dzIGEgYENhbmNlbGVkRXJyb3JgIGlmIGNhbmNlbGxhdGlvbiBoYXMgYmVlbiByZXF1ZXN0ZWQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnIHRoYXQgaXMgdG8gYmUgdXNlZCBmb3IgdGhlIHJlcXVlc3RcbiAqXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpIHtcbiAgaWYgKGNvbmZpZy5jYW5jZWxUb2tlbikge1xuICAgIGNvbmZpZy5jYW5jZWxUb2tlbi50aHJvd0lmUmVxdWVzdGVkKCk7XG4gIH1cblxuICBpZiAoY29uZmlnLnNpZ25hbCAmJiBjb25maWcuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICB0aHJvdyBuZXcgQ2FuY2VsZWRFcnJvcihudWxsLCBjb25maWcpO1xuICB9XG59XG5cbi8qKlxuICogRGlzcGF0Y2ggYSByZXF1ZXN0IHRvIHRoZSBzZXJ2ZXIgdXNpbmcgdGhlIGNvbmZpZ3VyZWQgYWRhcHRlci5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gY29uZmlnIFRoZSBjb25maWcgdGhhdCBpcyB0byBiZSB1c2VkIGZvciB0aGUgcmVxdWVzdFxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgUHJvbWlzZSB0byBiZSBmdWxmaWxsZWRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZGlzcGF0Y2hSZXF1ZXN0KGNvbmZpZykge1xuICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgY29uZmlnLmhlYWRlcnMgPSBBeGlvc0hlYWRlcnMuZnJvbShjb25maWcuaGVhZGVycyk7XG5cbiAgLy8gVHJhbnNmb3JtIHJlcXVlc3QgZGF0YVxuICBjb25maWcuZGF0YSA9IHRyYW5zZm9ybURhdGEuY2FsbChcbiAgICBjb25maWcsXG4gICAgY29uZmlnLnRyYW5zZm9ybVJlcXVlc3RcbiAgKTtcblxuICBpZiAoWydwb3N0JywgJ3B1dCcsICdwYXRjaCddLmluZGV4T2YoY29uZmlnLm1ldGhvZCkgIT09IC0xKSB7XG4gICAgY29uZmlnLmhlYWRlcnMuc2V0Q29udGVudFR5cGUoJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsIGZhbHNlKTtcbiAgfVxuXG4gIGNvbnN0IGFkYXB0ZXIgPSBhZGFwdGVycy5nZXRBZGFwdGVyKGNvbmZpZy5hZGFwdGVyIHx8IGRlZmF1bHRzLmFkYXB0ZXIsIGNvbmZpZyk7XG5cbiAgcmV0dXJuIGFkYXB0ZXIoY29uZmlnKS50aGVuKGZ1bmN0aW9uIG9uQWRhcHRlclJlc29sdXRpb24ocmVzcG9uc2UpIHtcbiAgICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgICAvLyBUcmFuc2Zvcm0gcmVzcG9uc2UgZGF0YVxuICAgIHJlc3BvbnNlLmRhdGEgPSB0cmFuc2Zvcm1EYXRhLmNhbGwoXG4gICAgICBjb25maWcsXG4gICAgICBjb25maWcudHJhbnNmb3JtUmVzcG9uc2UsXG4gICAgICByZXNwb25zZVxuICAgICk7XG5cbiAgICByZXNwb25zZS5oZWFkZXJzID0gQXhpb3NIZWFkZXJzLmZyb20ocmVzcG9uc2UuaGVhZGVycyk7XG5cbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH0sIGZ1bmN0aW9uIG9uQWRhcHRlclJlamVjdGlvbihyZWFzb24pIHtcbiAgICBpZiAoIWlzQ2FuY2VsKHJlYXNvbikpIHtcbiAgICAgIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKTtcblxuICAgICAgLy8gVHJhbnNmb3JtIHJlc3BvbnNlIGRhdGFcbiAgICAgIGlmIChyZWFzb24gJiYgcmVhc29uLnJlc3BvbnNlKSB7XG4gICAgICAgIHJlYXNvbi5yZXNwb25zZS5kYXRhID0gdHJhbnNmb3JtRGF0YS5jYWxsKFxuICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICBjb25maWcudHJhbnNmb3JtUmVzcG9uc2UsXG4gICAgICAgICAgcmVhc29uLnJlc3BvbnNlXG4gICAgICAgICk7XG4gICAgICAgIHJlYXNvbi5yZXNwb25zZS5oZWFkZXJzID0gQXhpb3NIZWFkZXJzLmZyb20ocmVhc29uLnJlc3BvbnNlLmhlYWRlcnMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChyZWFzb24pO1xuICB9KTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHtWRVJTSU9OfSBmcm9tICcuLi9lbnYvZGF0YS5qcyc7XG5pbXBvcnQgQXhpb3NFcnJvciBmcm9tICcuLi9jb3JlL0F4aW9zRXJyb3IuanMnO1xuXG5jb25zdCB2YWxpZGF0b3JzID0ge307XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5bJ29iamVjdCcsICdib29sZWFuJywgJ251bWJlcicsICdmdW5jdGlvbicsICdzdHJpbmcnLCAnc3ltYm9sJ10uZm9yRWFjaCgodHlwZSwgaSkgPT4ge1xuICB2YWxpZGF0b3JzW3R5cGVdID0gZnVuY3Rpb24gdmFsaWRhdG9yKHRoaW5nKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0aGluZyA9PT0gdHlwZSB8fCAnYScgKyAoaSA8IDEgPyAnbiAnIDogJyAnKSArIHR5cGU7XG4gIH07XG59KTtcblxuY29uc3QgZGVwcmVjYXRlZFdhcm5pbmdzID0ge307XG5cbi8qKlxuICogVHJhbnNpdGlvbmFsIG9wdGlvbiB2YWxpZGF0b3JcbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufGJvb2xlYW4/fSB2YWxpZGF0b3IgLSBzZXQgdG8gZmFsc2UgaWYgdGhlIHRyYW5zaXRpb25hbCBvcHRpb24gaGFzIGJlZW4gcmVtb3ZlZFxuICogQHBhcmFtIHtzdHJpbmc/fSB2ZXJzaW9uIC0gZGVwcmVjYXRlZCB2ZXJzaW9uIC8gcmVtb3ZlZCBzaW5jZSB2ZXJzaW9uXG4gKiBAcGFyYW0ge3N0cmluZz99IG1lc3NhZ2UgLSBzb21lIG1lc3NhZ2Ugd2l0aCBhZGRpdGlvbmFsIGluZm9cbiAqXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb259XG4gKi9cbnZhbGlkYXRvcnMudHJhbnNpdGlvbmFsID0gZnVuY3Rpb24gdHJhbnNpdGlvbmFsKHZhbGlkYXRvciwgdmVyc2lvbiwgbWVzc2FnZSkge1xuICBmdW5jdGlvbiBmb3JtYXRNZXNzYWdlKG9wdCwgZGVzYykge1xuICAgIHJldHVybiAnW0F4aW9zIHYnICsgVkVSU0lPTiArICddIFRyYW5zaXRpb25hbCBvcHRpb24gXFwnJyArIG9wdCArICdcXCcnICsgZGVzYyArIChtZXNzYWdlID8gJy4gJyArIG1lc3NhZ2UgOiAnJyk7XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuICByZXR1cm4gKHZhbHVlLCBvcHQsIG9wdHMpID0+IHtcbiAgICBpZiAodmFsaWRhdG9yID09PSBmYWxzZSkge1xuICAgICAgdGhyb3cgbmV3IEF4aW9zRXJyb3IoXG4gICAgICAgIGZvcm1hdE1lc3NhZ2Uob3B0LCAnIGhhcyBiZWVuIHJlbW92ZWQnICsgKHZlcnNpb24gPyAnIGluICcgKyB2ZXJzaW9uIDogJycpKSxcbiAgICAgICAgQXhpb3NFcnJvci5FUlJfREVQUkVDQVRFRFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAodmVyc2lvbiAmJiAhZGVwcmVjYXRlZFdhcm5pbmdzW29wdF0pIHtcbiAgICAgIGRlcHJlY2F0ZWRXYXJuaW5nc1tvcHRdID0gdHJ1ZTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIGZvcm1hdE1lc3NhZ2UoXG4gICAgICAgICAgb3B0LFxuICAgICAgICAgICcgaGFzIGJlZW4gZGVwcmVjYXRlZCBzaW5jZSB2JyArIHZlcnNpb24gKyAnIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5lYXIgZnV0dXJlJ1xuICAgICAgICApXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiB2YWxpZGF0b3IgPyB2YWxpZGF0b3IodmFsdWUsIG9wdCwgb3B0cykgOiB0cnVlO1xuICB9O1xufTtcblxudmFsaWRhdG9ycy5zcGVsbGluZyA9IGZ1bmN0aW9uIHNwZWxsaW5nKGNvcnJlY3RTcGVsbGluZykge1xuICByZXR1cm4gKHZhbHVlLCBvcHQpID0+IHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgIGNvbnNvbGUud2FybihgJHtvcHR9IGlzIGxpa2VseSBhIG1pc3NwZWxsaW5nIG9mICR7Y29ycmVjdFNwZWxsaW5nfWApO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG4vKipcbiAqIEFzc2VydCBvYmplY3QncyBwcm9wZXJ0aWVzIHR5cGVcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtvYmplY3R9IHNjaGVtYVxuICogQHBhcmFtIHtib29sZWFuP30gYWxsb3dVbmtub3duXG4gKlxuICogQHJldHVybnMge29iamVjdH1cbiAqL1xuXG5mdW5jdGlvbiBhc3NlcnRPcHRpb25zKG9wdGlvbnMsIHNjaGVtYSwgYWxsb3dVbmtub3duKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgQXhpb3NFcnJvcignb3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdCcsIEF4aW9zRXJyb3IuRVJSX0JBRF9PUFRJT05fVkFMVUUpO1xuICB9XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvcHRpb25zKTtcbiAgbGV0IGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSA+IDApIHtcbiAgICBjb25zdCBvcHQgPSBrZXlzW2ldO1xuICAgIGNvbnN0IHZhbGlkYXRvciA9IHNjaGVtYVtvcHRdO1xuICAgIGlmICh2YWxpZGF0b3IpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gb3B0aW9uc1tvcHRdO1xuICAgICAgY29uc3QgcmVzdWx0ID0gdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWxpZGF0b3IodmFsdWUsIG9wdCwgb3B0aW9ucyk7XG4gICAgICBpZiAocmVzdWx0ICE9PSB0cnVlKSB7XG4gICAgICAgIHRocm93IG5ldyBBeGlvc0Vycm9yKCdvcHRpb24gJyArIG9wdCArICcgbXVzdCBiZSAnICsgcmVzdWx0LCBBeGlvc0Vycm9yLkVSUl9CQURfT1BUSU9OX1ZBTFVFKTtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoYWxsb3dVbmtub3duICE9PSB0cnVlKSB7XG4gICAgICB0aHJvdyBuZXcgQXhpb3NFcnJvcignVW5rbm93biBvcHRpb24gJyArIG9wdCwgQXhpb3NFcnJvci5FUlJfQkFEX09QVElPTik7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgYXNzZXJ0T3B0aW9ucyxcbiAgdmFsaWRhdG9yc1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4vLi4vdXRpbHMuanMnO1xuaW1wb3J0IGJ1aWxkVVJMIGZyb20gJy4uL2hlbHBlcnMvYnVpbGRVUkwuanMnO1xuaW1wb3J0IEludGVyY2VwdG9yTWFuYWdlciBmcm9tICcuL0ludGVyY2VwdG9yTWFuYWdlci5qcyc7XG5pbXBvcnQgZGlzcGF0Y2hSZXF1ZXN0IGZyb20gJy4vZGlzcGF0Y2hSZXF1ZXN0LmpzJztcbmltcG9ydCBtZXJnZUNvbmZpZyBmcm9tICcuL21lcmdlQ29uZmlnLmpzJztcbmltcG9ydCBidWlsZEZ1bGxQYXRoIGZyb20gJy4vYnVpbGRGdWxsUGF0aC5qcyc7XG5pbXBvcnQgdmFsaWRhdG9yIGZyb20gJy4uL2hlbHBlcnMvdmFsaWRhdG9yLmpzJztcbmltcG9ydCBBeGlvc0hlYWRlcnMgZnJvbSAnLi9BeGlvc0hlYWRlcnMuanMnO1xuXG5jb25zdCB2YWxpZGF0b3JzID0gdmFsaWRhdG9yLnZhbGlkYXRvcnM7XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIEF4aW9zXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGluc3RhbmNlQ29uZmlnIFRoZSBkZWZhdWx0IGNvbmZpZyBmb3IgdGhlIGluc3RhbmNlXG4gKlxuICogQHJldHVybiB7QXhpb3N9IEEgbmV3IGluc3RhbmNlIG9mIEF4aW9zXG4gKi9cbmNsYXNzIEF4aW9zIHtcbiAgY29uc3RydWN0b3IoaW5zdGFuY2VDb25maWcpIHtcbiAgICB0aGlzLmRlZmF1bHRzID0gaW5zdGFuY2VDb25maWcgfHwge307XG4gICAgdGhpcy5pbnRlcmNlcHRvcnMgPSB7XG4gICAgICByZXF1ZXN0OiBuZXcgSW50ZXJjZXB0b3JNYW5hZ2VyKCksXG4gICAgICByZXNwb25zZTogbmV3IEludGVyY2VwdG9yTWFuYWdlcigpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwYXRjaCBhIHJlcXVlc3RcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBjb25maWdPclVybCBUaGUgY29uZmlnIHNwZWNpZmljIGZvciB0aGlzIHJlcXVlc3QgKG1lcmdlZCB3aXRoIHRoaXMuZGVmYXVsdHMpXG4gICAqIEBwYXJhbSB7P09iamVjdH0gY29uZmlnXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgUHJvbWlzZSB0byBiZSBmdWxmaWxsZWRcbiAgICovXG4gIGFzeW5jIHJlcXVlc3QoY29uZmlnT3JVcmwsIGNvbmZpZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5fcmVxdWVzdChjb25maWdPclVybCwgY29uZmlnKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICBsZXQgZHVtbXkgPSB7fTtcblxuICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSA/IEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKGR1bW15KSA6IChkdW1teSA9IG5ldyBFcnJvcigpKTtcblxuICAgICAgICAvLyBzbGljZSBvZmYgdGhlIEVycm9yOiAuLi4gbGluZVxuICAgICAgICBjb25zdCBzdGFjayA9IGR1bW15LnN0YWNrID8gZHVtbXkuc3RhY2sucmVwbGFjZSgvXi4rXFxuLywgJycpIDogJyc7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKCFlcnIuc3RhY2spIHtcbiAgICAgICAgICAgIGVyci5zdGFjayA9IHN0YWNrO1xuICAgICAgICAgICAgLy8gbWF0Y2ggd2l0aG91dCB0aGUgMiB0b3Agc3RhY2sgbGluZXNcbiAgICAgICAgICB9IGVsc2UgaWYgKHN0YWNrICYmICFTdHJpbmcoZXJyLnN0YWNrKS5lbmRzV2l0aChzdGFjay5yZXBsYWNlKC9eLitcXG4uK1xcbi8sICcnKSkpIHtcbiAgICAgICAgICAgIGVyci5zdGFjayArPSAnXFxuJyArIHN0YWNrXG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gaWdub3JlIHRoZSBjYXNlIHdoZXJlIFwic3RhY2tcIiBpcyBhbiB1bi13cml0YWJsZSBwcm9wZXJ0eVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gIH1cblxuICBfcmVxdWVzdChjb25maWdPclVybCwgY29uZmlnKSB7XG4gICAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gICAgLy8gQWxsb3cgZm9yIGF4aW9zKCdleGFtcGxlL3VybCdbLCBjb25maWddKSBhIGxhIGZldGNoIEFQSVxuICAgIGlmICh0eXBlb2YgY29uZmlnT3JVcmwgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25maWcgPSBjb25maWcgfHwge307XG4gICAgICBjb25maWcudXJsID0gY29uZmlnT3JVcmw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbmZpZyA9IGNvbmZpZ09yVXJsIHx8IHt9O1xuICAgIH1cblxuICAgIGNvbmZpZyA9IG1lcmdlQ29uZmlnKHRoaXMuZGVmYXVsdHMsIGNvbmZpZyk7XG5cbiAgICBjb25zdCB7dHJhbnNpdGlvbmFsLCBwYXJhbXNTZXJpYWxpemVyLCBoZWFkZXJzfSA9IGNvbmZpZztcblxuICAgIGlmICh0cmFuc2l0aW9uYWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFsaWRhdG9yLmFzc2VydE9wdGlvbnModHJhbnNpdGlvbmFsLCB7XG4gICAgICAgIHNpbGVudEpTT05QYXJzaW5nOiB2YWxpZGF0b3JzLnRyYW5zaXRpb25hbCh2YWxpZGF0b3JzLmJvb2xlYW4pLFxuICAgICAgICBmb3JjZWRKU09OUGFyc2luZzogdmFsaWRhdG9ycy50cmFuc2l0aW9uYWwodmFsaWRhdG9ycy5ib29sZWFuKSxcbiAgICAgICAgY2xhcmlmeVRpbWVvdXRFcnJvcjogdmFsaWRhdG9ycy50cmFuc2l0aW9uYWwodmFsaWRhdG9ycy5ib29sZWFuKVxuICAgICAgfSwgZmFsc2UpO1xuICAgIH1cblxuICAgIGlmIChwYXJhbXNTZXJpYWxpemVyICE9IG51bGwpIHtcbiAgICAgIGlmICh1dGlscy5pc0Z1bmN0aW9uKHBhcmFtc1NlcmlhbGl6ZXIpKSB7XG4gICAgICAgIGNvbmZpZy5wYXJhbXNTZXJpYWxpemVyID0ge1xuICAgICAgICAgIHNlcmlhbGl6ZTogcGFyYW1zU2VyaWFsaXplclxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWxpZGF0b3IuYXNzZXJ0T3B0aW9ucyhwYXJhbXNTZXJpYWxpemVyLCB7XG4gICAgICAgICAgZW5jb2RlOiB2YWxpZGF0b3JzLmZ1bmN0aW9uLFxuICAgICAgICAgIHNlcmlhbGl6ZTogdmFsaWRhdG9ycy5mdW5jdGlvblxuICAgICAgICB9LCB0cnVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTZXQgY29uZmlnLmFsbG93QWJzb2x1dGVVcmxzXG4gICAgaWYgKGNvbmZpZy5hbGxvd0Fic29sdXRlVXJscyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBkbyBub3RoaW5nXG4gICAgfSBlbHNlIGlmICh0aGlzLmRlZmF1bHRzLmFsbG93QWJzb2x1dGVVcmxzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbmZpZy5hbGxvd0Fic29sdXRlVXJscyA9IHRoaXMuZGVmYXVsdHMuYWxsb3dBYnNvbHV0ZVVybHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbmZpZy5hbGxvd0Fic29sdXRlVXJscyA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFsaWRhdG9yLmFzc2VydE9wdGlvbnMoY29uZmlnLCB7XG4gICAgICBiYXNlVXJsOiB2YWxpZGF0b3JzLnNwZWxsaW5nKCdiYXNlVVJMJyksXG4gICAgICB3aXRoWHNyZlRva2VuOiB2YWxpZGF0b3JzLnNwZWxsaW5nKCd3aXRoWFNSRlRva2VuJylcbiAgICB9LCB0cnVlKTtcblxuICAgIC8vIFNldCBjb25maWcubWV0aG9kXG4gICAgY29uZmlnLm1ldGhvZCA9IChjb25maWcubWV0aG9kIHx8IHRoaXMuZGVmYXVsdHMubWV0aG9kIHx8ICdnZXQnKS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgLy8gRmxhdHRlbiBoZWFkZXJzXG4gICAgbGV0IGNvbnRleHRIZWFkZXJzID0gaGVhZGVycyAmJiB1dGlscy5tZXJnZShcbiAgICAgIGhlYWRlcnMuY29tbW9uLFxuICAgICAgaGVhZGVyc1tjb25maWcubWV0aG9kXVxuICAgICk7XG5cbiAgICBoZWFkZXJzICYmIHV0aWxzLmZvckVhY2goXG4gICAgICBbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCcsICdwb3N0JywgJ3B1dCcsICdwYXRjaCcsICdjb21tb24nXSxcbiAgICAgIChtZXRob2QpID0+IHtcbiAgICAgICAgZGVsZXRlIGhlYWRlcnNbbWV0aG9kXTtcbiAgICAgIH1cbiAgICApO1xuXG4gICAgY29uZmlnLmhlYWRlcnMgPSBBeGlvc0hlYWRlcnMuY29uY2F0KGNvbnRleHRIZWFkZXJzLCBoZWFkZXJzKTtcblxuICAgIC8vIGZpbHRlciBvdXQgc2tpcHBlZCBpbnRlcmNlcHRvcnNcbiAgICBjb25zdCByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbiA9IFtdO1xuICAgIGxldCBzeW5jaHJvbm91c1JlcXVlc3RJbnRlcmNlcHRvcnMgPSB0cnVlO1xuICAgIHRoaXMuaW50ZXJjZXB0b3JzLnJlcXVlc3QuZm9yRWFjaChmdW5jdGlvbiB1bnNoaWZ0UmVxdWVzdEludGVyY2VwdG9ycyhpbnRlcmNlcHRvcikge1xuICAgICAgaWYgKHR5cGVvZiBpbnRlcmNlcHRvci5ydW5XaGVuID09PSAnZnVuY3Rpb24nICYmIGludGVyY2VwdG9yLnJ1bldoZW4oY29uZmlnKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBzeW5jaHJvbm91c1JlcXVlc3RJbnRlcmNlcHRvcnMgPSBzeW5jaHJvbm91c1JlcXVlc3RJbnRlcmNlcHRvcnMgJiYgaW50ZXJjZXB0b3Iuc3luY2hyb25vdXM7XG5cbiAgICAgIHJlcXVlc3RJbnRlcmNlcHRvckNoYWluLnVuc2hpZnQoaW50ZXJjZXB0b3IuZnVsZmlsbGVkLCBpbnRlcmNlcHRvci5yZWplY3RlZCk7XG4gICAgfSk7XG5cbiAgICBjb25zdCByZXNwb25zZUludGVyY2VwdG9yQ2hhaW4gPSBbXTtcbiAgICB0aGlzLmludGVyY2VwdG9ycy5yZXNwb25zZS5mb3JFYWNoKGZ1bmN0aW9uIHB1c2hSZXNwb25zZUludGVyY2VwdG9ycyhpbnRlcmNlcHRvcikge1xuICAgICAgcmVzcG9uc2VJbnRlcmNlcHRvckNoYWluLnB1c2goaW50ZXJjZXB0b3IuZnVsZmlsbGVkLCBpbnRlcmNlcHRvci5yZWplY3RlZCk7XG4gICAgfSk7XG5cbiAgICBsZXQgcHJvbWlzZTtcbiAgICBsZXQgaSA9IDA7XG4gICAgbGV0IGxlbjtcblxuICAgIGlmICghc3luY2hyb25vdXNSZXF1ZXN0SW50ZXJjZXB0b3JzKSB7XG4gICAgICBjb25zdCBjaGFpbiA9IFtkaXNwYXRjaFJlcXVlc3QuYmluZCh0aGlzKSwgdW5kZWZpbmVkXTtcbiAgICAgIGNoYWluLnVuc2hpZnQoLi4ucmVxdWVzdEludGVyY2VwdG9yQ2hhaW4pO1xuICAgICAgY2hhaW4ucHVzaCguLi5yZXNwb25zZUludGVyY2VwdG9yQ2hhaW4pO1xuICAgICAgbGVuID0gY2hhaW4ubGVuZ3RoO1xuXG4gICAgICBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKGNvbmZpZyk7XG5cbiAgICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oY2hhaW5baSsrXSwgY2hhaW5baSsrXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cblxuICAgIGxlbiA9IHJlcXVlc3RJbnRlcmNlcHRvckNoYWluLmxlbmd0aDtcblxuICAgIGxldCBuZXdDb25maWcgPSBjb25maWc7XG5cbiAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgY29uc3Qgb25GdWxmaWxsZWQgPSByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbltpKytdO1xuICAgICAgY29uc3Qgb25SZWplY3RlZCA9IHJlcXVlc3RJbnRlcmNlcHRvckNoYWluW2krK107XG4gICAgICB0cnkge1xuICAgICAgICBuZXdDb25maWcgPSBvbkZ1bGZpbGxlZChuZXdDb25maWcpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgb25SZWplY3RlZC5jYWxsKHRoaXMsIGVycm9yKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHByb21pc2UgPSBkaXNwYXRjaFJlcXVlc3QuY2FsbCh0aGlzLCBuZXdDb25maWcpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgIH1cblxuICAgIGkgPSAwO1xuICAgIGxlbiA9IHJlc3BvbnNlSW50ZXJjZXB0b3JDaGFpbi5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihyZXNwb25zZUludGVyY2VwdG9yQ2hhaW5baSsrXSwgcmVzcG9uc2VJbnRlcmNlcHRvckNoYWluW2krK10pO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG5cbiAgZ2V0VXJpKGNvbmZpZykge1xuICAgIGNvbmZpZyA9IG1lcmdlQ29uZmlnKHRoaXMuZGVmYXVsdHMsIGNvbmZpZyk7XG4gICAgY29uc3QgZnVsbFBhdGggPSBidWlsZEZ1bGxQYXRoKGNvbmZpZy5iYXNlVVJMLCBjb25maWcudXJsLCBjb25maWcuYWxsb3dBYnNvbHV0ZVVybHMpO1xuICAgIHJldHVybiBidWlsZFVSTChmdWxsUGF0aCwgY29uZmlnLnBhcmFtcywgY29uZmlnLnBhcmFtc1NlcmlhbGl6ZXIpO1xuICB9XG59XG5cbi8vIFByb3ZpZGUgYWxpYXNlcyBmb3Igc3VwcG9ydGVkIHJlcXVlc3QgbWV0aG9kc1xudXRpbHMuZm9yRWFjaChbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCcsICdvcHRpb25zJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2ROb0RhdGEobWV0aG9kKSB7XG4gIC8qZXNsaW50IGZ1bmMtbmFtZXM6MCovXG4gIEF4aW9zLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24odXJsLCBjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KG1lcmdlQ29uZmlnKGNvbmZpZyB8fCB7fSwge1xuICAgICAgbWV0aG9kLFxuICAgICAgdXJsLFxuICAgICAgZGF0YTogKGNvbmZpZyB8fCB7fSkuZGF0YVxuICAgIH0pKTtcbiAgfTtcbn0pO1xuXG51dGlscy5mb3JFYWNoKFsncG9zdCcsICdwdXQnLCAncGF0Y2gnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZFdpdGhEYXRhKG1ldGhvZCkge1xuICAvKmVzbGludCBmdW5jLW5hbWVzOjAqL1xuXG4gIGZ1bmN0aW9uIGdlbmVyYXRlSFRUUE1ldGhvZChpc0Zvcm0pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gaHR0cE1ldGhvZCh1cmwsIGRhdGEsIGNvbmZpZykge1xuICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChtZXJnZUNvbmZpZyhjb25maWcgfHwge30sIHtcbiAgICAgICAgbWV0aG9kLFxuICAgICAgICBoZWFkZXJzOiBpc0Zvcm0gPyB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdtdWx0aXBhcnQvZm9ybS1kYXRhJ1xuICAgICAgICB9IDoge30sXG4gICAgICAgIHVybCxcbiAgICAgICAgZGF0YVxuICAgICAgfSkpO1xuICAgIH07XG4gIH1cblxuICBBeGlvcy5wcm90b3R5cGVbbWV0aG9kXSA9IGdlbmVyYXRlSFRUUE1ldGhvZCgpO1xuXG4gIEF4aW9zLnByb3RvdHlwZVttZXRob2QgKyAnRm9ybSddID0gZ2VuZXJhdGVIVFRQTWV0aG9kKHRydWUpO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IEF4aW9zO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgQ2FuY2VsZWRFcnJvciBmcm9tICcuL0NhbmNlbGVkRXJyb3IuanMnO1xuXG4vKipcbiAqIEEgYENhbmNlbFRva2VuYCBpcyBhbiBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byByZXF1ZXN0IGNhbmNlbGxhdGlvbiBvZiBhbiBvcGVyYXRpb24uXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXhlY3V0b3IgVGhlIGV4ZWN1dG9yIGZ1bmN0aW9uLlxuICpcbiAqIEByZXR1cm5zIHtDYW5jZWxUb2tlbn1cbiAqL1xuY2xhc3MgQ2FuY2VsVG9rZW4ge1xuICBjb25zdHJ1Y3RvcihleGVjdXRvcikge1xuICAgIGlmICh0eXBlb2YgZXhlY3V0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4ZWN1dG9yIG11c3QgYmUgYSBmdW5jdGlvbi4nKTtcbiAgICB9XG5cbiAgICBsZXQgcmVzb2x2ZVByb21pc2U7XG5cbiAgICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiBwcm9taXNlRXhlY3V0b3IocmVzb2x2ZSkge1xuICAgICAgcmVzb2x2ZVByb21pc2UgPSByZXNvbHZlO1xuICAgIH0pO1xuXG4gICAgY29uc3QgdG9rZW4gPSB0aGlzO1xuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbiAgICB0aGlzLnByb21pc2UudGhlbihjYW5jZWwgPT4ge1xuICAgICAgaWYgKCF0b2tlbi5fbGlzdGVuZXJzKSByZXR1cm47XG5cbiAgICAgIGxldCBpID0gdG9rZW4uX2xpc3RlbmVycy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChpLS0gPiAwKSB7XG4gICAgICAgIHRva2VuLl9saXN0ZW5lcnNbaV0oY2FuY2VsKTtcbiAgICAgIH1cbiAgICAgIHRva2VuLl9saXN0ZW5lcnMgPSBudWxsO1xuICAgIH0pO1xuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbiAgICB0aGlzLnByb21pc2UudGhlbiA9IG9uZnVsZmlsbGVkID0+IHtcbiAgICAgIGxldCBfcmVzb2x2ZTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG4gICAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIHRva2VuLnN1YnNjcmliZShyZXNvbHZlKTtcbiAgICAgICAgX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgICAgfSkudGhlbihvbmZ1bGZpbGxlZCk7XG5cbiAgICAgIHByb21pc2UuY2FuY2VsID0gZnVuY3Rpb24gcmVqZWN0KCkge1xuICAgICAgICB0b2tlbi51bnN1YnNjcmliZShfcmVzb2x2ZSk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9O1xuXG4gICAgZXhlY3V0b3IoZnVuY3Rpb24gY2FuY2VsKG1lc3NhZ2UsIGNvbmZpZywgcmVxdWVzdCkge1xuICAgICAgaWYgKHRva2VuLnJlYXNvbikge1xuICAgICAgICAvLyBDYW5jZWxsYXRpb24gaGFzIGFscmVhZHkgYmVlbiByZXF1ZXN0ZWRcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0b2tlbi5yZWFzb24gPSBuZXcgQ2FuY2VsZWRFcnJvcihtZXNzYWdlLCBjb25maWcsIHJlcXVlc3QpO1xuICAgICAgcmVzb2x2ZVByb21pc2UodG9rZW4ucmVhc29uKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaHJvd3MgYSBgQ2FuY2VsZWRFcnJvcmAgaWYgY2FuY2VsbGF0aW9uIGhhcyBiZWVuIHJlcXVlc3RlZC5cbiAgICovXG4gIHRocm93SWZSZXF1ZXN0ZWQoKSB7XG4gICAgaWYgKHRoaXMucmVhc29uKSB7XG4gICAgICB0aHJvdyB0aGlzLnJlYXNvbjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3Vic2NyaWJlIHRvIHRoZSBjYW5jZWwgc2lnbmFsXG4gICAqL1xuXG4gIHN1YnNjcmliZShsaXN0ZW5lcikge1xuICAgIGlmICh0aGlzLnJlYXNvbikge1xuICAgICAgbGlzdGVuZXIodGhpcy5yZWFzb24pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9saXN0ZW5lcnMpIHtcbiAgICAgIHRoaXMuX2xpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fbGlzdGVuZXJzID0gW2xpc3RlbmVyXTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVW5zdWJzY3JpYmUgZnJvbSB0aGUgY2FuY2VsIHNpZ25hbFxuICAgKi9cblxuICB1bnN1YnNjcmliZShsaXN0ZW5lcikge1xuICAgIGlmICghdGhpcy5fbGlzdGVuZXJzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fbGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIHRoaXMuX2xpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgfVxuXG4gIHRvQWJvcnRTaWduYWwoKSB7XG4gICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcblxuICAgIGNvbnN0IGFib3J0ID0gKGVycikgPT4ge1xuICAgICAgY29udHJvbGxlci5hYm9ydChlcnIpO1xuICAgIH07XG5cbiAgICB0aGlzLnN1YnNjcmliZShhYm9ydCk7XG5cbiAgICBjb250cm9sbGVyLnNpZ25hbC51bnN1YnNjcmliZSA9ICgpID0+IHRoaXMudW5zdWJzY3JpYmUoYWJvcnQpO1xuXG4gICAgcmV0dXJuIGNvbnRyb2xsZXIuc2lnbmFsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgYSBuZXcgYENhbmNlbFRva2VuYCBhbmQgYSBmdW5jdGlvbiB0aGF0LCB3aGVuIGNhbGxlZCxcbiAgICogY2FuY2VscyB0aGUgYENhbmNlbFRva2VuYC5cbiAgICovXG4gIHN0YXRpYyBzb3VyY2UoKSB7XG4gICAgbGV0IGNhbmNlbDtcbiAgICBjb25zdCB0b2tlbiA9IG5ldyBDYW5jZWxUb2tlbihmdW5jdGlvbiBleGVjdXRvcihjKSB7XG4gICAgICBjYW5jZWwgPSBjO1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICB0b2tlbixcbiAgICAgIGNhbmNlbFxuICAgIH07XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ2FuY2VsVG9rZW47XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogU3ludGFjdGljIHN1Z2FyIGZvciBpbnZva2luZyBhIGZ1bmN0aW9uIGFuZCBleHBhbmRpbmcgYW4gYXJyYXkgZm9yIGFyZ3VtZW50cy5cbiAqXG4gKiBDb21tb24gdXNlIGNhc2Ugd291bGQgYmUgdG8gdXNlIGBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHlgLlxuICpcbiAqICBgYGBqc1xuICogIGZ1bmN0aW9uIGYoeCwgeSwgeikge31cbiAqICB2YXIgYXJncyA9IFsxLCAyLCAzXTtcbiAqICBmLmFwcGx5KG51bGwsIGFyZ3MpO1xuICogIGBgYFxuICpcbiAqIFdpdGggYHNwcmVhZGAgdGhpcyBleGFtcGxlIGNhbiBiZSByZS13cml0dGVuLlxuICpcbiAqICBgYGBqc1xuICogIHNwcmVhZChmdW5jdGlvbih4LCB5LCB6KSB7fSkoWzEsIDIsIDNdKTtcbiAqICBgYGBcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICpcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc3ByZWFkKGNhbGxiYWNrKSB7XG4gIHJldHVybiBmdW5jdGlvbiB3cmFwKGFycikge1xuICAgIHJldHVybiBjYWxsYmFjay5hcHBseShudWxsLCBhcnIpO1xuICB9O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgdXRpbHMgZnJvbSAnLi8uLi91dGlscy5qcyc7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBwYXlsb2FkIGlzIGFuIGVycm9yIHRocm93biBieSBBeGlvc1xuICpcbiAqIEBwYXJhbSB7Kn0gcGF5bG9hZCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBwYXlsb2FkIGlzIGFuIGVycm9yIHRocm93biBieSBBeGlvcywgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzQXhpb3NFcnJvcihwYXlsb2FkKSB7XG4gIHJldHVybiB1dGlscy5pc09iamVjdChwYXlsb2FkKSAmJiAocGF5bG9hZC5pc0F4aW9zRXJyb3IgPT09IHRydWUpO1xufVxuIiwiY29uc3QgSHR0cFN0YXR1c0NvZGUgPSB7XG4gIENvbnRpbnVlOiAxMDAsXG4gIFN3aXRjaGluZ1Byb3RvY29sczogMTAxLFxuICBQcm9jZXNzaW5nOiAxMDIsXG4gIEVhcmx5SGludHM6IDEwMyxcbiAgT2s6IDIwMCxcbiAgQ3JlYXRlZDogMjAxLFxuICBBY2NlcHRlZDogMjAyLFxuICBOb25BdXRob3JpdGF0aXZlSW5mb3JtYXRpb246IDIwMyxcbiAgTm9Db250ZW50OiAyMDQsXG4gIFJlc2V0Q29udGVudDogMjA1LFxuICBQYXJ0aWFsQ29udGVudDogMjA2LFxuICBNdWx0aVN0YXR1czogMjA3LFxuICBBbHJlYWR5UmVwb3J0ZWQ6IDIwOCxcbiAgSW1Vc2VkOiAyMjYsXG4gIE11bHRpcGxlQ2hvaWNlczogMzAwLFxuICBNb3ZlZFBlcm1hbmVudGx5OiAzMDEsXG4gIEZvdW5kOiAzMDIsXG4gIFNlZU90aGVyOiAzMDMsXG4gIE5vdE1vZGlmaWVkOiAzMDQsXG4gIFVzZVByb3h5OiAzMDUsXG4gIFVudXNlZDogMzA2LFxuICBUZW1wb3JhcnlSZWRpcmVjdDogMzA3LFxuICBQZXJtYW5lbnRSZWRpcmVjdDogMzA4LFxuICBCYWRSZXF1ZXN0OiA0MDAsXG4gIFVuYXV0aG9yaXplZDogNDAxLFxuICBQYXltZW50UmVxdWlyZWQ6IDQwMixcbiAgRm9yYmlkZGVuOiA0MDMsXG4gIE5vdEZvdW5kOiA0MDQsXG4gIE1ldGhvZE5vdEFsbG93ZWQ6IDQwNSxcbiAgTm90QWNjZXB0YWJsZTogNDA2LFxuICBQcm94eUF1dGhlbnRpY2F0aW9uUmVxdWlyZWQ6IDQwNyxcbiAgUmVxdWVzdFRpbWVvdXQ6IDQwOCxcbiAgQ29uZmxpY3Q6IDQwOSxcbiAgR29uZTogNDEwLFxuICBMZW5ndGhSZXF1aXJlZDogNDExLFxuICBQcmVjb25kaXRpb25GYWlsZWQ6IDQxMixcbiAgUGF5bG9hZFRvb0xhcmdlOiA0MTMsXG4gIFVyaVRvb0xvbmc6IDQxNCxcbiAgVW5zdXBwb3J0ZWRNZWRpYVR5cGU6IDQxNSxcbiAgUmFuZ2VOb3RTYXRpc2ZpYWJsZTogNDE2LFxuICBFeHBlY3RhdGlvbkZhaWxlZDogNDE3LFxuICBJbUFUZWFwb3Q6IDQxOCxcbiAgTWlzZGlyZWN0ZWRSZXF1ZXN0OiA0MjEsXG4gIFVucHJvY2Vzc2FibGVFbnRpdHk6IDQyMixcbiAgTG9ja2VkOiA0MjMsXG4gIEZhaWxlZERlcGVuZGVuY3k6IDQyNCxcbiAgVG9vRWFybHk6IDQyNSxcbiAgVXBncmFkZVJlcXVpcmVkOiA0MjYsXG4gIFByZWNvbmRpdGlvblJlcXVpcmVkOiA0MjgsXG4gIFRvb01hbnlSZXF1ZXN0czogNDI5LFxuICBSZXF1ZXN0SGVhZGVyRmllbGRzVG9vTGFyZ2U6IDQzMSxcbiAgVW5hdmFpbGFibGVGb3JMZWdhbFJlYXNvbnM6IDQ1MSxcbiAgSW50ZXJuYWxTZXJ2ZXJFcnJvcjogNTAwLFxuICBOb3RJbXBsZW1lbnRlZDogNTAxLFxuICBCYWRHYXRld2F5OiA1MDIsXG4gIFNlcnZpY2VVbmF2YWlsYWJsZTogNTAzLFxuICBHYXRld2F5VGltZW91dDogNTA0LFxuICBIdHRwVmVyc2lvbk5vdFN1cHBvcnRlZDogNTA1LFxuICBWYXJpYW50QWxzb05lZ290aWF0ZXM6IDUwNixcbiAgSW5zdWZmaWNpZW50U3RvcmFnZTogNTA3LFxuICBMb29wRGV0ZWN0ZWQ6IDUwOCxcbiAgTm90RXh0ZW5kZWQ6IDUxMCxcbiAgTmV0d29ya0F1dGhlbnRpY2F0aW9uUmVxdWlyZWQ6IDUxMSxcbn07XG5cbk9iamVjdC5lbnRyaWVzKEh0dHBTdGF0dXNDb2RlKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgSHR0cFN0YXR1c0NvZGVbdmFsdWVdID0ga2V5O1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IEh0dHBTdGF0dXNDb2RlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgdXRpbHMgZnJvbSAnLi91dGlscy5qcyc7XG5pbXBvcnQgYmluZCBmcm9tICcuL2hlbHBlcnMvYmluZC5qcyc7XG5pbXBvcnQgQXhpb3MgZnJvbSAnLi9jb3JlL0F4aW9zLmpzJztcbmltcG9ydCBtZXJnZUNvbmZpZyBmcm9tICcuL2NvcmUvbWVyZ2VDb25maWcuanMnO1xuaW1wb3J0IGRlZmF1bHRzIGZyb20gJy4vZGVmYXVsdHMvaW5kZXguanMnO1xuaW1wb3J0IGZvcm1EYXRhVG9KU09OIGZyb20gJy4vaGVscGVycy9mb3JtRGF0YVRvSlNPTi5qcyc7XG5pbXBvcnQgQ2FuY2VsZWRFcnJvciBmcm9tICcuL2NhbmNlbC9DYW5jZWxlZEVycm9yLmpzJztcbmltcG9ydCBDYW5jZWxUb2tlbiBmcm9tICcuL2NhbmNlbC9DYW5jZWxUb2tlbi5qcyc7XG5pbXBvcnQgaXNDYW5jZWwgZnJvbSAnLi9jYW5jZWwvaXNDYW5jZWwuanMnO1xuaW1wb3J0IHtWRVJTSU9OfSBmcm9tICcuL2Vudi9kYXRhLmpzJztcbmltcG9ydCB0b0Zvcm1EYXRhIGZyb20gJy4vaGVscGVycy90b0Zvcm1EYXRhLmpzJztcbmltcG9ydCBBeGlvc0Vycm9yIGZyb20gJy4vY29yZS9BeGlvc0Vycm9yLmpzJztcbmltcG9ydCBzcHJlYWQgZnJvbSAnLi9oZWxwZXJzL3NwcmVhZC5qcyc7XG5pbXBvcnQgaXNBeGlvc0Vycm9yIGZyb20gJy4vaGVscGVycy9pc0F4aW9zRXJyb3IuanMnO1xuaW1wb3J0IEF4aW9zSGVhZGVycyBmcm9tIFwiLi9jb3JlL0F4aW9zSGVhZGVycy5qc1wiO1xuaW1wb3J0IGFkYXB0ZXJzIGZyb20gJy4vYWRhcHRlcnMvYWRhcHRlcnMuanMnO1xuaW1wb3J0IEh0dHBTdGF0dXNDb2RlIGZyb20gJy4vaGVscGVycy9IdHRwU3RhdHVzQ29kZS5qcyc7XG5cbi8qKlxuICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIEF4aW9zXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRlZmF1bHRDb25maWcgVGhlIGRlZmF1bHQgY29uZmlnIGZvciB0aGUgaW5zdGFuY2VcbiAqXG4gKiBAcmV0dXJucyB7QXhpb3N9IEEgbmV3IGluc3RhbmNlIG9mIEF4aW9zXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlKGRlZmF1bHRDb25maWcpIHtcbiAgY29uc3QgY29udGV4dCA9IG5ldyBBeGlvcyhkZWZhdWx0Q29uZmlnKTtcbiAgY29uc3QgaW5zdGFuY2UgPSBiaW5kKEF4aW9zLnByb3RvdHlwZS5yZXF1ZXN0LCBjb250ZXh0KTtcblxuICAvLyBDb3B5IGF4aW9zLnByb3RvdHlwZSB0byBpbnN0YW5jZVxuICB1dGlscy5leHRlbmQoaW5zdGFuY2UsIEF4aW9zLnByb3RvdHlwZSwgY29udGV4dCwge2FsbE93bktleXM6IHRydWV9KTtcblxuICAvLyBDb3B5IGNvbnRleHQgdG8gaW5zdGFuY2VcbiAgdXRpbHMuZXh0ZW5kKGluc3RhbmNlLCBjb250ZXh0LCBudWxsLCB7YWxsT3duS2V5czogdHJ1ZX0pO1xuXG4gIC8vIEZhY3RvcnkgZm9yIGNyZWF0aW5nIG5ldyBpbnN0YW5jZXNcbiAgaW5zdGFuY2UuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGluc3RhbmNlQ29uZmlnKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUluc3RhbmNlKG1lcmdlQ29uZmlnKGRlZmF1bHRDb25maWcsIGluc3RhbmNlQ29uZmlnKSk7XG4gIH07XG5cbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuXG4vLyBDcmVhdGUgdGhlIGRlZmF1bHQgaW5zdGFuY2UgdG8gYmUgZXhwb3J0ZWRcbmNvbnN0IGF4aW9zID0gY3JlYXRlSW5zdGFuY2UoZGVmYXVsdHMpO1xuXG4vLyBFeHBvc2UgQXhpb3MgY2xhc3MgdG8gYWxsb3cgY2xhc3MgaW5oZXJpdGFuY2VcbmF4aW9zLkF4aW9zID0gQXhpb3M7XG5cbi8vIEV4cG9zZSBDYW5jZWwgJiBDYW5jZWxUb2tlblxuYXhpb3MuQ2FuY2VsZWRFcnJvciA9IENhbmNlbGVkRXJyb3I7XG5heGlvcy5DYW5jZWxUb2tlbiA9IENhbmNlbFRva2VuO1xuYXhpb3MuaXNDYW5jZWwgPSBpc0NhbmNlbDtcbmF4aW9zLlZFUlNJT04gPSBWRVJTSU9OO1xuYXhpb3MudG9Gb3JtRGF0YSA9IHRvRm9ybURhdGE7XG5cbi8vIEV4cG9zZSBBeGlvc0Vycm9yIGNsYXNzXG5heGlvcy5BeGlvc0Vycm9yID0gQXhpb3NFcnJvcjtcblxuLy8gYWxpYXMgZm9yIENhbmNlbGVkRXJyb3IgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbmF4aW9zLkNhbmNlbCA9IGF4aW9zLkNhbmNlbGVkRXJyb3I7XG5cbi8vIEV4cG9zZSBhbGwvc3ByZWFkXG5heGlvcy5hbGwgPSBmdW5jdGlvbiBhbGwocHJvbWlzZXMpIHtcbiAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcbn07XG5cbmF4aW9zLnNwcmVhZCA9IHNwcmVhZDtcblxuLy8gRXhwb3NlIGlzQXhpb3NFcnJvclxuYXhpb3MuaXNBeGlvc0Vycm9yID0gaXNBeGlvc0Vycm9yO1xuXG4vLyBFeHBvc2UgbWVyZ2VDb25maWdcbmF4aW9zLm1lcmdlQ29uZmlnID0gbWVyZ2VDb25maWc7XG5cbmF4aW9zLkF4aW9zSGVhZGVycyA9IEF4aW9zSGVhZGVycztcblxuYXhpb3MuZm9ybVRvSlNPTiA9IHRoaW5nID0+IGZvcm1EYXRhVG9KU09OKHV0aWxzLmlzSFRNTEZvcm0odGhpbmcpID8gbmV3IEZvcm1EYXRhKHRoaW5nKSA6IHRoaW5nKTtcblxuYXhpb3MuZ2V0QWRhcHRlciA9IGFkYXB0ZXJzLmdldEFkYXB0ZXI7XG5cbmF4aW9zLkh0dHBTdGF0dXNDb2RlID0gSHR0cFN0YXR1c0NvZGU7XG5cbmF4aW9zLmRlZmF1bHQgPSBheGlvcztcblxuLy8gdGhpcyBtb2R1bGUgc2hvdWxkIG9ubHkgaGF2ZSBhIGRlZmF1bHQgZXhwb3J0XG5leHBvcnQgZGVmYXVsdCBheGlvc1xuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVlLFNBQVNBLElBQUlBLENBQUNDLEVBQUUsRUFBRUMsT0FBTyxFQUFFO0VBQ3hDLE9BQU8sU0FBU0MsSUFBSUEsQ0FBQSxFQUFHO0lBQ3JCLE9BQU9GLEVBQUUsQ0FBQ0csS0FBSyxDQUFDRixPQUFPLEVBQUVHLFNBQVMsQ0FBQztFQUN2QyxDQUFHO0FBQ0g7O0FDRkE7O0FBRUEsTUFBTTtFQUFDQztBQUFRLENBQUMsR0FBR0MsTUFBTSxDQUFDQyxTQUFTO0FBQ25DLE1BQU07RUFBQ0M7QUFBYyxDQUFDLEdBQUdGLE1BQU07QUFDL0IsTUFBTTtFQUFDRyxRQUFRO0VBQUVDO0FBQVcsQ0FBQyxHQUFHQyxNQUFNO0FBRXRDLE1BQU1DLE1BQU0sR0FBRyxDQUFDQyxLQUFLLElBQUlDLEtBQUssSUFBSTtFQUM5QixNQUFNQyxHQUFHLEdBQUdWLFFBQVEsQ0FBQ1csSUFBSSxDQUFDRixLQUFLLENBQUM7RUFDaEMsT0FBT0QsS0FBSyxDQUFDRSxHQUFHLENBQUMsS0FBS0YsS0FBSyxDQUFDRSxHQUFHLENBQUMsR0FBR0EsR0FB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