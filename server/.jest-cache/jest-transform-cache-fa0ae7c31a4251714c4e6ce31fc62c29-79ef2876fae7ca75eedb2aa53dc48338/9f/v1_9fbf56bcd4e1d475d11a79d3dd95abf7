628acf5efdb4bdd953a860d265c5e30d
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _rng = _interopRequireDefault(require("./rng.js"));
var _stringify = require("./stringify.js");
function _interopRequireDefault(e) {
  return e && e.__esModule ? e : {
    default: e
  };
}
// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html

let _nodeId;
let _clockseq;

// Previous uuid creation time
let _lastMSecs = 0;
let _lastNSecs = 0;

// See https://github.com/uuidjs/uuid for API details
function v1(options, buf, offset) {
  let i = buf && offset || 0;
  const b = buf || new Array(16);
  options = options || {};
  let node = options.node;
  let clockseq = options.clockseq;

  // v1 only: Use cached `node` and `clockseq` values
  if (!options._v6) {
    if (!node) {
      node = _nodeId;
    }
    if (clockseq == null) {
      clockseq = _clockseq;
    }
  }

  // Handle cases where we need entropy.  We do this lazily to minimize issues
  // related to insufficient system entropy.  See #189
  if (node == null || clockseq == null) {
    const seedBytes = options.random || (options.rng || _rng.default)();

    // Randomize node
    if (node == null) {
      node = [seedBytes[0], seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];

      // v1 only: cache node value for reuse
      if (!_nodeId && !options._v6) {
        // per RFC4122 4.5: Set MAC multicast bit (v1 only)
        node[0] |= 0x01; // Set multicast bit

        _nodeId = node;
      }
    }

    // Randomize clockseq
    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
      if (_clockseq === undefined && !options._v6) {
        _clockseq = clockseq;
      }
    }
  }

  // v1 & v6 timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so time is
  // handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
  let msecs = options.msecs !== undefined ? options.msecs : Date.now();

  // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock
  let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;

  // Time since last uuid creation (in msecs)
  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000;

  // Per 4.2.1.2, Bump clockseq on clock regression
  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  }

  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  }

  // Per 4.2.1.2 Throw error if too many uuids are requested
  if (nsecs >= 10000) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }
  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;

  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
  msecs += 12219292800000;

  // `time_low`
  const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff;

  // `time_mid`
  const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff;

  // `time_high_and_version`
  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
  b[i++] = tmh >>> 16 & 0xff;

  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
  b[i++] = clockseq >>> 8 | 0x80;

  // `clock_seq_low`
  b[i++] = clockseq & 0xff;

  // `node`
  for (let n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }
  return buf || (0, _stringify.unsafeStringify)(b);
}
var _default = exports.default = v1;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImRlZmF1bHQiLCJfcm5nIiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsInJlcXVpcmUiLCJfc3RyaW5naWZ5IiwiZSIsIl9fZXNNb2R1bGUiLCJfbm9kZUlkIiwiX2Nsb2Nrc2VxIiwiX2xhc3RNU2VjcyIsIl9sYXN0TlNlY3MiLCJ2MSIsIm9wdGlvbnMiLCJidWYiLCJvZmZzZXQiLCJpIiwiYiIsIkFycmF5Iiwibm9kZSIsImNsb2Nrc2VxIiwiX3Y2Iiwic2VlZEJ5dGVzIiwicmFuZG9tIiwicm5nIiwidW5kZWZpbmVkIiwibXNlY3MiLCJEYXRlIiwibm93IiwibnNlY3MiLCJkdCIsIkVycm9yIiwidGwiLCJ0bWgiLCJuIiwidW5zYWZlU3RyaW5naWZ5IiwiX2RlZmF1bHQiXSwic291cmNlcyI6WyJ2MS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBfcm5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9ybmcuanNcIikpO1xudmFyIF9zdHJpbmdpZnkgPSByZXF1aXJlKFwiLi9zdHJpbmdpZnkuanNcIik7XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KGUpIHsgcmV0dXJuIGUgJiYgZS5fX2VzTW9kdWxlID8gZSA6IHsgZGVmYXVsdDogZSB9OyB9XG4vLyAqKmB2MSgpYCAtIEdlbmVyYXRlIHRpbWUtYmFzZWQgVVVJRCoqXG4vL1xuLy8gSW5zcGlyZWQgYnkgaHR0cHM6Ly9naXRodWIuY29tL0xpb3NLL1VVSUQuanNcbi8vIGFuZCBodHRwOi8vZG9jcy5weXRob24ub3JnL2xpYnJhcnkvdXVpZC5odG1sXG5cbmxldCBfbm9kZUlkO1xubGV0IF9jbG9ja3NlcTtcblxuLy8gUHJldmlvdXMgdXVpZCBjcmVhdGlvbiB0aW1lXG5sZXQgX2xhc3RNU2VjcyA9IDA7XG5sZXQgX2xhc3ROU2VjcyA9IDA7XG5cbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdXVpZGpzL3V1aWQgZm9yIEFQSSBkZXRhaWxzXG5mdW5jdGlvbiB2MShvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICBsZXQgaSA9IGJ1ZiAmJiBvZmZzZXQgfHwgMDtcbiAgY29uc3QgYiA9IGJ1ZiB8fCBuZXcgQXJyYXkoMTYpO1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgbGV0IG5vZGUgPSBvcHRpb25zLm5vZGU7XG4gIGxldCBjbG9ja3NlcSA9IG9wdGlvbnMuY2xvY2tzZXE7XG5cbiAgLy8gdjEgb25seTogVXNlIGNhY2hlZCBgbm9kZWAgYW5kIGBjbG9ja3NlcWAgdmFsdWVzXG4gIGlmICghb3B0aW9ucy5fdjYpIHtcbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgIG5vZGUgPSBfbm9kZUlkO1xuICAgIH1cbiAgICBpZiAoY2xvY2tzZXEgPT0gbnVsbCkge1xuICAgICAgY2xvY2tzZXEgPSBfY2xvY2tzZXE7XG4gICAgfVxuICB9XG5cbiAgLy8gSGFuZGxlIGNhc2VzIHdoZXJlIHdlIG5lZWQgZW50cm9weS4gIFdlIGRvIHRoaXMgbGF6aWx5IHRvIG1pbmltaXplIGlzc3Vlc1xuICAvLyByZWxhdGVkIHRvIGluc3VmZmljaWVudCBzeXN0ZW0gZW50cm9weS4gIFNlZSAjMTg5XG4gIGlmIChub2RlID09IG51bGwgfHwgY2xvY2tzZXEgPT0gbnVsbCkge1xuICAgIGNvbnN0IHNlZWRCeXRlcyA9IG9wdGlvbnMucmFuZG9tIHx8IChvcHRpb25zLnJuZyB8fCBfcm5nLmRlZmF1bHQpKCk7XG5cbiAgICAvLyBSYW5kb21pemUgbm9kZVxuICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgIG5vZGUgPSBbc2VlZEJ5dGVzWzBdLCBzZWVkQnl0ZXNbMV0sIHNlZWRCeXRlc1syXSwgc2VlZEJ5dGVzWzNdLCBzZWVkQnl0ZXNbNF0sIHNlZWRCeXRlc1s1XV07XG5cbiAgICAgIC8vIHYxIG9ubHk6IGNhY2hlIG5vZGUgdmFsdWUgZm9yIHJldXNlXG4gICAgICBpZiAoIV9ub2RlSWQgJiYgIW9wdGlvbnMuX3Y2KSB7XG4gICAgICAgIC8vIHBlciBSRkM0MTIyIDQuNTogU2V0IE1BQyBtdWx0aWNhc3QgYml0ICh2MSBvbmx5KVxuICAgICAgICBub2RlWzBdIHw9IDB4MDE7IC8vIFNldCBtdWx0aWNhc3QgYml0XG5cbiAgICAgICAgX25vZGVJZCA9IG5vZGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmFuZG9taXplIGNsb2Nrc2VxXG4gICAgaWYgKGNsb2Nrc2VxID09IG51bGwpIHtcbiAgICAgIC8vIFBlciA0LjIuMiwgcmFuZG9taXplICgxNCBiaXQpIGNsb2Nrc2VxXG4gICAgICBjbG9ja3NlcSA9IChzZWVkQnl0ZXNbNl0gPDwgOCB8IHNlZWRCeXRlc1s3XSkgJiAweDNmZmY7XG4gICAgICBpZiAoX2Nsb2Nrc2VxID09PSB1bmRlZmluZWQgJiYgIW9wdGlvbnMuX3Y2KSB7XG4gICAgICAgIF9jbG9ja3NlcSA9IGNsb2Nrc2VxO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIHYxICYgdjYgdGltZXN0YW1wcyBhcmUgMTAwIG5hbm8tc2Vjb25kIHVuaXRzIHNpbmNlIHRoZSBHcmVnb3JpYW4gZXBvY2gsXG4gIC8vICgxNTgyLTEwLTE1IDAwOjAwKS4gIEpTTnVtYmVycyBhcmVuJ3QgcHJlY2lzZSBlbm91Z2ggZm9yIHRoaXMsIHNvIHRpbWUgaXNcbiAgLy8gaGFuZGxlZCBpbnRlcm5hbGx5IGFzICdtc2VjcycgKGludGVnZXIgbWlsbGlzZWNvbmRzKSBhbmQgJ25zZWNzJ1xuICAvLyAoMTAwLW5hbm9zZWNvbmRzIG9mZnNldCBmcm9tIG1zZWNzKSBzaW5jZSB1bml4IGVwb2NoLCAxOTcwLTAxLTAxIDAwOjAwLlxuICBsZXQgbXNlY3MgPSBvcHRpb25zLm1zZWNzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm1zZWNzIDogRGF0ZS5ub3coKTtcblxuICAvLyBQZXIgNC4yLjEuMiwgdXNlIGNvdW50IG9mIHV1aWQncyBnZW5lcmF0ZWQgZHVyaW5nIHRoZSBjdXJyZW50IGNsb2NrXG4gIC8vIGN5Y2xlIHRvIHNpbXVsYXRlIGhpZ2hlciByZXNvbHV0aW9uIGNsb2NrXG4gIGxldCBuc2VjcyA9IG9wdGlvbnMubnNlY3MgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubnNlY3MgOiBfbGFzdE5TZWNzICsgMTtcblxuICAvLyBUaW1lIHNpbmNlIGxhc3QgdXVpZCBjcmVhdGlvbiAoaW4gbXNlY3MpXG4gIGNvbnN0IGR0ID0gbXNlY3MgLSBfbGFzdE1TZWNzICsgKG5zZWNzIC0gX2xhc3ROU2VjcykgLyAxMDAwMDtcblxuICAvLyBQZXIgNC4yLjEuMiwgQnVtcCBjbG9ja3NlcSBvbiBjbG9jayByZWdyZXNzaW9uXG4gIGlmIChkdCA8IDAgJiYgb3B0aW9ucy5jbG9ja3NlcSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY2xvY2tzZXEgPSBjbG9ja3NlcSArIDEgJiAweDNmZmY7XG4gIH1cblxuICAvLyBSZXNldCBuc2VjcyBpZiBjbG9jayByZWdyZXNzZXMgKG5ldyBjbG9ja3NlcSkgb3Igd2UndmUgbW92ZWQgb250byBhIG5ld1xuICAvLyB0aW1lIGludGVydmFsXG4gIGlmICgoZHQgPCAwIHx8IG1zZWNzID4gX2xhc3RNU2VjcykgJiYgb3B0aW9ucy5uc2VjcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbnNlY3MgPSAwO1xuICB9XG5cbiAgLy8gUGVyIDQuMi4xLjIgVGhyb3cgZXJyb3IgaWYgdG9vIG1hbnkgdXVpZHMgYXJlIHJlcXVlc3RlZFxuICBpZiAobnNlY3MgPj0gMTAwMDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1dWlkLnYxKCk6IENhbid0IGNyZWF0ZSBtb3JlIHRoYW4gMTBNIHV1aWRzL3NlY1wiKTtcbiAgfVxuICBfbGFzdE1TZWNzID0gbXNlY3M7XG4gIF9sYXN0TlNlY3MgPSBuc2VjcztcbiAgX2Nsb2Nrc2VxID0gY2xvY2tzZXE7XG5cbiAgLy8gUGVyIDQuMS40IC0gQ29udmVydCBmcm9tIHVuaXggZXBvY2ggdG8gR3JlZ29yaWFuIGVwb2NoXG4gIG1zZWNzICs9IDEyMjE5MjkyODAwMDAwO1xuXG4gIC8vIGB0aW1lX2xvd2BcbiAgY29uc3QgdGwgPSAoKG1zZWNzICYgMHhmZmZmZmZmKSAqIDEwMDAwICsgbnNlY3MpICUgMHgxMDAwMDAwMDA7XG4gIGJbaSsrXSA9IHRsID4+PiAyNCAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRsID4+PiAxNiAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRsID4+PiA4ICYgMHhmZjtcbiAgYltpKytdID0gdGwgJiAweGZmO1xuXG4gIC8vIGB0aW1lX21pZGBcbiAgY29uc3QgdG1oID0gbXNlY3MgLyAweDEwMDAwMDAwMCAqIDEwMDAwICYgMHhmZmZmZmZmO1xuICBiW2krK10gPSB0bWggPj4+IDggJiAweGZmO1xuICBiW2krK10gPSB0bWggJiAweGZmO1xuXG4gIC8vIGB0aW1lX2hpZ2hfYW5kX3ZlcnNpb25gXG4gIGJbaSsrXSA9IHRtaCA+Pj4gMjQgJiAweGYgfCAweDEwOyAvLyBpbmNsdWRlIHZlcnNpb25cbiAgYltpKytdID0gdG1oID4+PiAxNiAmIDB4ZmY7XG5cbiAgLy8gYGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRgIChQZXIgNC4yLjIgLSBpbmNsdWRlIHZhcmlhbnQpXG4gIGJbaSsrXSA9IGNsb2Nrc2VxID4+PiA4IHwgMHg4MDtcblxuICAvLyBgY2xvY2tfc2VxX2xvd2BcbiAgYltpKytdID0gY2xvY2tzZXEgJiAweGZmO1xuXG4gIC8vIGBub2RlYFxuICBmb3IgKGxldCBuID0gMDsgbiA8IDY7ICsrbikge1xuICAgIGJbaSArIG5dID0gbm9kZVtuXTtcbiAgfVxuICByZXR1cm4gYnVmIHx8ICgwLCBfc3RyaW5naWZ5LnVuc2FmZVN0cmluZ2lmeSkoYik7XG59XG52YXIgX2RlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQgPSB2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